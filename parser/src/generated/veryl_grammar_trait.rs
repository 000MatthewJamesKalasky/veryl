// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

use parol_runtime::derive_builder::Builder;
use parol_runtime::id_tree::Tree;
use parol_runtime::lexer::Token;
use parol_runtime::log::trace;
#[allow(unused_imports)]
use parol_runtime::miette::{bail, miette, IntoDiagnostic, Result};
#[allow(unused_imports)]
use parol_runtime::parol_macros::{pop_and_reverse_item, pop_item};
use parol_runtime::parser::{ParseTreeStackEntry, ParseTreeType, UserActionsTrait};

/// Semantic actions trait generated for the user grammar
/// All functions have default implementations.
pub trait VerylGrammarTrait<'t> {
    /// Semantic action for non-terminal 'BasedBinary'
    fn based_binary(&mut self, _arg: &BasedBinary<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BasedOctal'
    fn based_octal(&mut self, _arg: &BasedOctal<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BasedDecimal'
    fn based_decimal(&mut self, _arg: &BasedDecimal<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BasedHex'
    fn based_hex(&mut self, _arg: &BasedHex<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BaseLess'
    fn base_less(&mut self, _arg: &BaseLess<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Plus'
    fn plus(&mut self, _arg: &Plus<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Minus'
    fn minus(&mut self, _arg: &Minus<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Mul'
    fn mul(&mut self, _arg: &Mul<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Div'
    fn div(&mut self, _arg: &Div<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Colon'
    fn colon(&mut self, _arg: &Colon<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'SemiColon'
    fn semi_colon(&mut self, _arg: &SemiColon<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Comma'
    fn comma(&mut self, _arg: &Comma<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LParen'
    fn l_paren(&mut self, _arg: &LParen<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RParen'
    fn r_paren(&mut self, _arg: &RParen<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LBracket'
    fn l_bracket(&mut self, _arg: &LBracket<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RBracket'
    fn r_bracket(&mut self, _arg: &RBracket<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LBrace'
    fn l_brace(&mut self, _arg: &LBrace<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RBrace'
    fn r_brace(&mut self, _arg: &RBrace<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Assignment'
    fn assignment(&mut self, _arg: &Assignment<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Sharp'
    fn sharp(&mut self, _arg: &Sharp<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Logic'
    fn logic(&mut self, _arg: &Logic<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Bit'
    fn bit(&mut self, _arg: &Bit<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AlwaysFF'
    fn always_f_f(&mut self, _arg: &AlwaysFF<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AlwaysComb'
    fn always_comb(&mut self, _arg: &AlwaysComb<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Posedge'
    fn posedge(&mut self, _arg: &Posedge<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Negedge'
    fn negedge(&mut self, _arg: &Negedge<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'If'
    fn r#if(&mut self, _arg: &If<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Else'
    fn r#else(&mut self, _arg: &Else<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Parameter'
    fn parameter(&mut self, _arg: &Parameter<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Localparam'
    fn localparam(&mut self, _arg: &Localparam<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Module'
    fn module(&mut self, _arg: &Module<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Interface'
    fn interface(&mut self, _arg: &Interface<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Input'
    fn input(&mut self, _arg: &Input<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Output'
    fn output(&mut self, _arg: &Output<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Inout'
    fn inout(&mut self, _arg: &Inout<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Modport'
    fn modport(&mut self, _arg: &Modport<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Identifier'
    fn identifier(&mut self, _arg: &Identifier<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Veryl'
    fn veryl(&mut self, _arg: &Veryl<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Description'
    fn description(&mut self, _arg: &Description<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Number'
    fn number(&mut self, _arg: &Number<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IntegralNumber'
    fn integral_number(&mut self, _arg: &IntegralNumber<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BinaryNumber'
    fn binary_number(&mut self, _arg: &BinaryNumber<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'OctalNumber'
    fn octal_number(&mut self, _arg: &OctalNumber<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DecimalNumber'
    fn decimal_number(&mut self, _arg: &DecimalNumber<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'HexNumber'
    fn hex_number(&mut self, _arg: &HexNumber<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BaseLessNumber'
    fn base_less_number(&mut self, _arg: &BaseLessNumber<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'OperatorPrecedence1'
    fn operator_precedence1(&mut self, _arg: &OperatorPrecedence1<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'OperatorPrecedence2'
    fn operator_precedence2(&mut self, _arg: &OperatorPrecedence2<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression'
    fn expression(&mut self, _arg: &Expression<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression0'
    fn expression0(&mut self, _arg: &Expression0<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression1'
    fn expression1(&mut self, _arg: &Expression1<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression2'
    fn expression2(&mut self, _arg: &Expression2<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Factor'
    fn factor(&mut self, _arg: &Factor<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Statement'
    fn statement(&mut self, _arg: &Statement<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AssignmentStatement'
    fn assignment_statement(&mut self, _arg: &AssignmentStatement<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IfStatement'
    fn if_statement(&mut self, _arg: &IfStatement<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Range'
    fn range(&mut self, _arg: &Range<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Width'
    fn width(&mut self, _arg: &Width<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BuiltinType'
    fn builtin_type(&mut self, _arg: &BuiltinType<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Type'
    fn r#type(&mut self, _arg: &Type<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WithParameter'
    fn with_parameter(&mut self, _arg: &WithParameter<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WithParameterList'
    fn with_parameter_list(&mut self, _arg: &WithParameterList<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WithParameterItem'
    fn with_parameter_item(&mut self, _arg: &WithParameterItem<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModuleDeclaration'
    fn module_declaration(&mut self, _arg: &ModuleDeclaration<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModulePort'
    fn module_port(&mut self, _arg: &ModulePort<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModulePortList'
    fn module_port_list(&mut self, _arg: &ModulePortList<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModulePortItem'
    fn module_port_item(&mut self, _arg: &ModulePortItem<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Direction'
    fn direction(&mut self, _arg: &Direction<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModuleItem'
    fn module_item(&mut self, _arg: &ModuleItem<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InterfaceDeclaration'
    fn interface_declaration(&mut self, _arg: &InterfaceDeclaration<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InterfaceItem'
    fn interface_item(&mut self, _arg: &InterfaceItem<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'VariableDeclaration'
    fn variable_declaration(&mut self, _arg: &VariableDeclaration<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ParameterDeclaration'
    fn parameter_declaration(&mut self, _arg: &ParameterDeclaration<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LocalparamDeclaration'
    fn localparam_declaration(&mut self, _arg: &LocalparamDeclaration<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AlwaysFFDeclaration'
    fn always_f_f_declaration(&mut self, _arg: &AlwaysFFDeclaration<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AlwaysFFConditions'
    fn always_f_f_conditions(&mut self, _arg: &AlwaysFFConditions<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AlwaysFFCondition'
    fn always_f_f_condition(&mut self, _arg: &AlwaysFFCondition<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AlwaysCombDeclaration'
    fn always_comb_declaration(&mut self, _arg: &AlwaysCombDeclaration<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModportDeclaration'
    fn modport_declaration(&mut self, _arg: &ModportDeclaration<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModportList'
    fn modport_list(&mut self, _arg: &ModportList<'t>) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModportItem'
    fn modport_item(&mut self, _arg: &ModportItem<'t>) -> Result<()> {
        Ok(())
    }
}

// -------------------------------------------------------------------------------------------------
//
// Output Types of productions deduced from the structure of the transformed grammar
//

///
/// Type derived for production 40
///
/// Description: ModuleDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Description0<'t> {
    pub module_declaration: Box<ModuleDeclaration<'t>>,
}

///
/// Type derived for production 41
///
/// Description: InterfaceDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Description1<'t> {
    pub interface_declaration: Box<InterfaceDeclaration<'t>>,
}

///
/// Type derived for production 43
///
/// IntegralNumber: BinaryNumber;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct IntegralNumber0<'t> {
    pub binary_number: Box<BinaryNumber<'t>>,
}

///
/// Type derived for production 44
///
/// IntegralNumber: OctalNumber;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct IntegralNumber1<'t> {
    pub octal_number: Box<OctalNumber<'t>>,
}

///
/// Type derived for production 45
///
/// IntegralNumber: DecimalNumber;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct IntegralNumber2<'t> {
    pub decimal_number: Box<DecimalNumber<'t>>,
}

///
/// Type derived for production 46
///
/// IntegralNumber: HexNumber;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct IntegralNumber3<'t> {
    pub hex_number: Box<HexNumber<'t>>,
}

///
/// Type derived for production 47
///
/// IntegralNumber: BaseLessNumber;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct IntegralNumber4<'t> {
    pub base_less_number: Box<BaseLessNumber<'t>>,
}

///
/// Type derived for production 53
///
/// OperatorPrecedence1: Plus;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct OperatorPrecedence3<'t> {
    pub plus: Box<Plus<'t>>,
}

///
/// Type derived for production 54
///
/// OperatorPrecedence1: Minus;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct OperatorPrecedence4<'t> {
    pub minus: Box<Minus<'t>>,
}

///
/// Type derived for production 55
///
/// OperatorPrecedence2: Mul;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct OperatorPrecedence5<'t> {
    pub mul: Box<Mul<'t>>,
}

///
/// Type derived for production 56
///
/// OperatorPrecedence2: Div;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct OperatorPrecedence6<'t> {
    pub div: Box<Div<'t>>,
}

///
/// Type derived for production 65
///
/// Factor: Number;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Factor0<'t> {
    pub number: Box<Number<'t>>,
}

///
/// Type derived for production 66
///
/// Factor: Identifier FactorOpt /* Option */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Factor1<'t> {
    pub identifier: Box<Identifier<'t>>,
    pub factor_opt: Option<Box<FactorOpt<'t>>>,
}

///
/// Type derived for production 67
///
/// Factor: LParen Expression RParen;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Factor2<'t> {
    pub l_paren: Box<LParen<'t>>,
    pub expression: Box<Expression<'t>>,
    pub r_paren: Box<RParen<'t>>,
}

///
/// Type derived for production 70
///
/// Statement: AssignmentStatement;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Statement0<'t> {
    pub assignment_statement: Box<AssignmentStatement<'t>>,
}

///
/// Type derived for production 71
///
/// Statement: IfStatement;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Statement1<'t> {
    pub if_statement: Box<IfStatement<'t>>,
}

///
/// Type derived for production 82
///
/// BuiltinType: Logic;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BuiltinType0<'t> {
    pub logic: Box<Logic<'t>>,
}

///
/// Type derived for production 83
///
/// BuiltinType: Bit;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BuiltinType1<'t> {
    pub bit: Box<Bit<'t>>,
}

///
/// Type derived for production 85
///
/// TypeGroup: BuiltinType;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct TypeGroup0<'t> {
    pub builtin_type: Box<BuiltinType<'t>>,
}

///
/// Type derived for production 86
///
/// TypeGroup: Identifier;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct TypeGroup1<'t> {
    pub identifier: Box<Identifier<'t>>,
}

///
/// Type derived for production 98
///
/// WithParameterItemGroup: Parameter;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct WithParameterItemGroup0<'t> {
    pub parameter: Box<Parameter<'t>>,
}

///
/// Type derived for production 99
///
/// WithParameterItemGroup: Localparam;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct WithParameterItemGroup1<'t> {
    pub localparam: Box<Localparam<'t>>,
}

///
/// Type derived for production 116
///
/// Direction: Input;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Direction0<'t> {
    pub input: Box<Input<'t>>,
}

///
/// Type derived for production 117
///
/// Direction: Output;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Direction1<'t> {
    pub output: Box<Output<'t>>,
}

///
/// Type derived for production 118
///
/// Direction: Inout;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Direction2<'t> {
    pub inout: Box<Inout<'t>>,
}

///
/// Type derived for production 119
///
/// ModuleItem: VariableDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModuleItem0<'t> {
    pub variable_declaration: Box<VariableDeclaration<'t>>,
}

///
/// Type derived for production 120
///
/// ModuleItem: ParameterDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModuleItem1<'t> {
    pub parameter_declaration: Box<ParameterDeclaration<'t>>,
}

///
/// Type derived for production 121
///
/// ModuleItem: LocalparamDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModuleItem2<'t> {
    pub localparam_declaration: Box<LocalparamDeclaration<'t>>,
}

///
/// Type derived for production 122
///
/// ModuleItem: AlwaysFFDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModuleItem3<'t> {
    pub always_f_f_declaration: Box<AlwaysFFDeclaration<'t>>,
}

///
/// Type derived for production 123
///
/// ModuleItem: AlwaysCombDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModuleItem4<'t> {
    pub always_comb_declaration: Box<AlwaysCombDeclaration<'t>>,
}

///
/// Type derived for production 129
///
/// InterfaceItem: VariableDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct InterfaceItem0<'t> {
    pub variable_declaration: Box<VariableDeclaration<'t>>,
}

///
/// Type derived for production 130
///
/// InterfaceItem: ParameterDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct InterfaceItem1<'t> {
    pub parameter_declaration: Box<ParameterDeclaration<'t>>,
}

///
/// Type derived for production 131
///
/// InterfaceItem: LocalparamDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct InterfaceItem2<'t> {
    pub localparam_declaration: Box<LocalparamDeclaration<'t>>,
}

///
/// Type derived for production 132
///
/// InterfaceItem: ModportDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct InterfaceItem3<'t> {
    pub modport_declaration: Box<ModportDeclaration<'t>>,
}

///
/// Type derived for production 145
///
/// AlwaysFFConditionGroup: Posedge;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AlwaysFFConditionGroup0<'t> {
    pub posedge: Box<Posedge<'t>>,
}

///
/// Type derived for production 146
///
/// AlwaysFFConditionGroup: Negedge;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AlwaysFFConditionGroup1<'t> {
    pub negedge: Box<Negedge<'t>>,
}

// -------------------------------------------------------------------------------------------------
//
// Types of non-terminals deduced from the structure of the transformed grammar
//

///
/// Type derived for non-terminal AlwaysComb
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AlwaysComb<'t> {
    pub always_comb: Token<'t>, /* always_comb */
}

///
/// Type derived for non-terminal AlwaysCombDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AlwaysCombDeclaration<'t> {
    pub always_comb: Box<AlwaysComb<'t>>,
    pub l_brace: Box<LBrace<'t>>,
    pub always_comb_declaration_list: Vec<AlwaysCombDeclarationList<'t>>,
    pub r_brace: Box<RBrace<'t>>,
}

///
/// Type derived for non-terminal AlwaysCombDeclarationList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AlwaysCombDeclarationList<'t> {
    pub statement: Box<Statement<'t>>,
}

///
/// Type derived for non-terminal AlwaysFF
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AlwaysFF<'t> {
    pub always_f_f: Token<'t>, /* always_ff */
}

///
/// Type derived for non-terminal AlwaysFFCondition
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AlwaysFFCondition<'t> {
    pub always_f_f_condition_group: Box<AlwaysFFConditionGroup<'t>>,
    pub identifier: Box<Identifier<'t>>,
}

///
/// Type derived for non-terminal AlwaysFFConditionGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum AlwaysFFConditionGroup<'t> {
    AlwaysFFConditionGroup0(AlwaysFFConditionGroup0<'t>),
    AlwaysFFConditionGroup1(AlwaysFFConditionGroup1<'t>),
}

///
/// Type derived for non-terminal AlwaysFFConditions
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AlwaysFFConditions<'t> {
    pub always_f_f_condition: Box<AlwaysFFCondition<'t>>,
    pub always_f_f_conditions_list: Vec<AlwaysFFConditionsList<'t>>,
    pub always_f_f_conditions_opt: Option<Box<AlwaysFFConditionsOpt<'t>>>,
}

///
/// Type derived for non-terminal AlwaysFFConditionsList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AlwaysFFConditionsList<'t> {
    pub comma: Box<Comma<'t>>,
    pub always_f_f_condition: Box<AlwaysFFCondition<'t>>,
}

///
/// Type derived for non-terminal AlwaysFFConditionsOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AlwaysFFConditionsOpt<'t> {
    pub comma: Box<Comma<'t>>,
}

///
/// Type derived for non-terminal AlwaysFFDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AlwaysFFDeclaration<'t> {
    pub always_f_f: Box<AlwaysFF<'t>>,
    pub l_paren: Box<LParen<'t>>,
    pub always_f_f_conditions: Box<AlwaysFFConditions<'t>>,
    pub r_paren: Box<RParen<'t>>,
    pub l_brace: Box<LBrace<'t>>,
    pub always_f_f_declaration_list: Vec<AlwaysFFDeclarationList<'t>>,
    pub r_brace: Box<RBrace<'t>>,
}

///
/// Type derived for non-terminal AlwaysFFDeclarationList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AlwaysFFDeclarationList<'t> {
    pub statement: Box<Statement<'t>>,
}

///
/// Type derived for non-terminal Assignment
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Assignment<'t> {
    pub assignment: Token<'t>, /* = */
}

///
/// Type derived for non-terminal AssignmentStatement
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AssignmentStatement<'t> {
    pub identifier: Box<Identifier<'t>>,
    pub assignment: Box<Assignment<'t>>,
    pub expression: Box<Expression<'t>>,
    pub semi_colon: Box<SemiColon<'t>>,
}

///
/// Type derived for non-terminal BaseLess
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BaseLess<'t> {
    pub base_less: Token<'t>, /* [0-9]+(?:_[0-9]+)* */
}

///
/// Type derived for non-terminal BaseLessNumber
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BaseLessNumber<'t> {
    pub base_less: Box<BaseLess<'t>>,
}

///
/// Type derived for non-terminal BasedBinary
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BasedBinary<'t> {
    pub based_binary: Token<'t>, /* 'b[0-1xzXZ]+(?:_[0-1xzXZ]+)* */
}

///
/// Type derived for non-terminal BasedDecimal
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BasedDecimal<'t> {
    pub based_decimal: Token<'t>, /* 'd[0-9]+(?:_[0-9]+)* */
}

///
/// Type derived for non-terminal BasedHex
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BasedHex<'t> {
    pub based_hex: Token<'t>, /* 'h[0-9a-fA-FxzXZ]+(?:_[0-9a-fA-FxzXZ]+)* */
}

///
/// Type derived for non-terminal BasedOctal
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BasedOctal<'t> {
    pub based_octal: Token<'t>, /* 'o[0-7xzXZ]+(?:_[0-7xzXZ]+)* */
}

///
/// Type derived for non-terminal BinaryNumber
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BinaryNumber<'t> {
    pub base_less: Box<BaseLess<'t>>,
    pub based_binary: Box<BasedBinary<'t>>,
}

///
/// Type derived for non-terminal Bit
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Bit<'t> {
    pub bit: Token<'t>, /* bit */
}

///
/// Type derived for non-terminal BuiltinType
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum BuiltinType<'t> {
    BuiltinType0(BuiltinType0<'t>),
    BuiltinType1(BuiltinType1<'t>),
}

///
/// Type derived for non-terminal Colon
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Colon<'t> {
    pub colon: Token<'t>, /* : */
}

///
/// Type derived for non-terminal Comma
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Comma<'t> {
    pub comma: Token<'t>, /* , */
}

///
/// Type derived for non-terminal DecimalNumber
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct DecimalNumber<'t> {
    pub base_less: Box<BaseLess<'t>>,
    pub based_decimal: Box<BasedDecimal<'t>>,
}

///
/// Type derived for non-terminal Description
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Description<'t> {
    Description0(Description0<'t>),
    Description1(Description1<'t>),
}

///
/// Type derived for non-terminal Direction
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Direction<'t> {
    Direction0(Direction0<'t>),
    Direction1(Direction1<'t>),
    Direction2(Direction2<'t>),
}

///
/// Type derived for non-terminal Div
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Div<'t> {
    pub div: Token<'t>, /* / */
}

///
/// Type derived for non-terminal Else
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Else<'t> {
    pub r#else: Token<'t>, /* else */
}

///
/// Type derived for non-terminal Expression
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Expression<'t> {
    pub expression0: Box<Expression0<'t>>,
}

///
/// Type derived for non-terminal Expression0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Expression0<'t> {
    pub expression1: Box<Expression1<'t>>,
    pub expression0_list: Vec<Expression0List<'t>>,
}

///
/// Type derived for non-terminal Expression0List
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Expression0List<'t> {
    pub operator_precedence1: Box<OperatorPrecedence1<'t>>,
    pub expression1: Box<Expression1<'t>>,
}

///
/// Type derived for non-terminal Expression1
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Expression1<'t> {
    pub expression2: Box<Expression2<'t>>,
    pub expression1_list: Vec<Expression1List<'t>>,
}

///
/// Type derived for non-terminal Expression1List
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Expression1List<'t> {
    pub operator_precedence2: Box<OperatorPrecedence2<'t>>,
    pub expression2: Box<Expression2<'t>>,
}

///
/// Type derived for non-terminal Expression2
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Expression2<'t> {
    pub factor: Box<Factor<'t>>,
}

///
/// Type derived for non-terminal Factor
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Factor<'t> {
    Factor0(Factor0<'t>),
    Factor1(Factor1<'t>),
    Factor2(Factor2<'t>),
}

///
/// Type derived for non-terminal FactorOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct FactorOpt<'t> {
    pub range: Box<Range<'t>>,
}

///
/// Type derived for non-terminal HexNumber
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct HexNumber<'t> {
    pub base_less: Box<BaseLess<'t>>,
    pub based_hex: Box<BasedHex<'t>>,
}

///
/// Type derived for non-terminal Identifier
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Identifier<'t> {
    pub identifier: Token<'t>, /* [a-zA-Z_][0-9a-zA-Z_]* */
}

///
/// Type derived for non-terminal If
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct If<'t> {
    pub r#if: Token<'t>, /* if */
}

///
/// Type derived for non-terminal IfStatement
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct IfStatement<'t> {
    pub r#if: Box<If<'t>>,
    pub expression: Box<Expression<'t>>,
    pub l_brace: Box<LBrace<'t>>,
    pub statement: Box<Statement<'t>>,
    pub r_brace: Box<RBrace<'t>>,
    pub if_statement_list: Vec<IfStatementList<'t>>,
    pub if_statement_opt: Option<Box<IfStatementOpt<'t>>>,
}

///
/// Type derived for non-terminal IfStatementList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct IfStatementList<'t> {
    pub r#else: Box<Else<'t>>,
    pub r#if: Box<If<'t>>,
    pub expression: Box<Expression<'t>>,
    pub l_brace: Box<LBrace<'t>>,
    pub statement: Box<Statement<'t>>,
    pub r_brace: Box<RBrace<'t>>,
}

///
/// Type derived for non-terminal IfStatementOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct IfStatementOpt<'t> {
    pub r#else: Box<Else<'t>>,
    pub l_brace: Box<LBrace<'t>>,
    pub statement: Box<Statement<'t>>,
    pub r_brace: Box<RBrace<'t>>,
}

///
/// Type derived for non-terminal Inout
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Inout<'t> {
    pub inout: Token<'t>, /* inout */
}

///
/// Type derived for non-terminal Input
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Input<'t> {
    pub input: Token<'t>, /* input */
}

///
/// Type derived for non-terminal IntegralNumber
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum IntegralNumber<'t> {
    IntegralNumber0(IntegralNumber0<'t>),
    IntegralNumber1(IntegralNumber1<'t>),
    IntegralNumber2(IntegralNumber2<'t>),
    IntegralNumber3(IntegralNumber3<'t>),
    IntegralNumber4(IntegralNumber4<'t>),
}

///
/// Type derived for non-terminal Interface
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Interface<'t> {
    pub interface: Token<'t>, /* interface */
}

///
/// Type derived for non-terminal InterfaceDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct InterfaceDeclaration<'t> {
    pub interface: Box<Interface<'t>>,
    pub identifier: Box<Identifier<'t>>,
    pub interface_declaration_opt: Option<Box<InterfaceDeclarationOpt<'t>>>,
    pub l_brace: Box<LBrace<'t>>,
    pub interface_declaration_list: Vec<InterfaceDeclarationList<'t>>,
    pub r_brace: Box<RBrace<'t>>,
}

///
/// Type derived for non-terminal InterfaceDeclarationList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct InterfaceDeclarationList<'t> {
    pub interface_item: Box<InterfaceItem<'t>>,
}

///
/// Type derived for non-terminal InterfaceDeclarationOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct InterfaceDeclarationOpt<'t> {
    pub with_parameter: Box<WithParameter<'t>>,
}

///
/// Type derived for non-terminal InterfaceItem
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum InterfaceItem<'t> {
    InterfaceItem0(InterfaceItem0<'t>),
    InterfaceItem1(InterfaceItem1<'t>),
    InterfaceItem2(InterfaceItem2<'t>),
    InterfaceItem3(InterfaceItem3<'t>),
}

///
/// Type derived for non-terminal LBrace
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LBrace<'t> {
    pub l_brace: Token<'t>, /* { */
}

///
/// Type derived for non-terminal LBracket
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LBracket<'t> {
    pub l_bracket: Token<'t>, /* [ */
}

///
/// Type derived for non-terminal LParen
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LParen<'t> {
    pub l_paren: Token<'t>, /* ( */
}

///
/// Type derived for non-terminal Localparam
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Localparam<'t> {
    pub localparam: Token<'t>, /* localparam */
}

///
/// Type derived for non-terminal LocalparamDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LocalparamDeclaration<'t> {
    pub localparam: Box<Localparam<'t>>,
    pub identifier: Box<Identifier<'t>>,
    pub colon: Box<Colon<'t>>,
    pub r#type: Box<Type<'t>>,
    pub assignment: Box<Assignment<'t>>,
    pub expression: Box<Expression<'t>>,
    pub semi_colon: Box<SemiColon<'t>>,
}

///
/// Type derived for non-terminal Logic
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Logic<'t> {
    pub logic: Token<'t>, /* logic */
}

///
/// Type derived for non-terminal Minus
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Minus<'t> {
    pub minus: Token<'t>, /* - */
}

///
/// Type derived for non-terminal Modport
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Modport<'t> {
    pub modport: Token<'t>, /* modport */
}

///
/// Type derived for non-terminal ModportDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModportDeclaration<'t> {
    pub modport: Box<Modport<'t>>,
    pub identifier: Box<Identifier<'t>>,
    pub l_brace: Box<LBrace<'t>>,
    pub modport_list: Box<ModportList<'t>>,
    pub r_brace: Box<RBrace<'t>>,
}

///
/// Type derived for non-terminal ModportItem
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModportItem<'t> {
    pub identifier: Box<Identifier<'t>>,
    pub colon: Box<Colon<'t>>,
    pub direction: Box<Direction<'t>>,
}

///
/// Type derived for non-terminal ModportList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModportList<'t> {
    pub modport_item: Box<ModportItem<'t>>,
    pub modport_list_list: Vec<ModportListList<'t>>,
    pub modport_list_opt: Option<Box<ModportListOpt<'t>>>,
}

///
/// Type derived for non-terminal ModportListList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModportListList<'t> {
    pub comma: Box<Comma<'t>>,
    pub modport_item: Box<ModportItem<'t>>,
}

///
/// Type derived for non-terminal ModportListOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModportListOpt<'t> {
    pub comma: Box<Comma<'t>>,
}

///
/// Type derived for non-terminal Module
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Module<'t> {
    pub module: Token<'t>, /* module */
}

///
/// Type derived for non-terminal ModuleDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModuleDeclaration<'t> {
    pub module: Box<Module<'t>>,
    pub identifier: Box<Identifier<'t>>,
    pub module_declaration_opt: Option<Box<ModuleDeclarationOpt<'t>>>,
    pub module_declaration_opt0: Option<Box<ModuleDeclarationOpt0<'t>>>,
    pub l_brace: Box<LBrace<'t>>,
    pub module_declaration_list: Vec<ModuleDeclarationList<'t>>,
    pub r_brace: Box<RBrace<'t>>,
}

///
/// Type derived for non-terminal ModuleDeclarationList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModuleDeclarationList<'t> {
    pub module_item: Box<ModuleItem<'t>>,
}

///
/// Type derived for non-terminal ModuleDeclarationOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModuleDeclarationOpt<'t> {
    pub with_parameter: Box<WithParameter<'t>>,
}

///
/// Type derived for non-terminal ModuleDeclarationOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModuleDeclarationOpt0<'t> {
    pub module_port: Box<ModulePort<'t>>,
}

///
/// Type derived for non-terminal ModuleItem
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ModuleItem<'t> {
    ModuleItem0(ModuleItem0<'t>),
    ModuleItem1(ModuleItem1<'t>),
    ModuleItem2(ModuleItem2<'t>),
    ModuleItem3(ModuleItem3<'t>),
    ModuleItem4(ModuleItem4<'t>),
}

///
/// Type derived for non-terminal ModulePort
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModulePort<'t> {
    pub l_paren: Box<LParen<'t>>,
    pub module_port_opt: Option<Box<ModulePortOpt<'t>>>,
    pub r_paren: Box<RParen<'t>>,
}

///
/// Type derived for non-terminal ModulePortItem
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModulePortItem<'t> {
    pub identifier: Box<Identifier<'t>>,
    pub colon: Box<Colon<'t>>,
    pub direction: Box<Direction<'t>>,
    pub r#type: Box<Type<'t>>,
}

///
/// Type derived for non-terminal ModulePortList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModulePortList<'t> {
    pub module_port_item: Box<ModulePortItem<'t>>,
    pub module_port_list_list: Vec<ModulePortListList<'t>>,
    pub module_port_list_opt: Option<Box<ModulePortListOpt<'t>>>,
}

///
/// Type derived for non-terminal ModulePortListList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModulePortListList<'t> {
    pub comma: Box<Comma<'t>>,
    pub module_port_item: Box<ModulePortItem<'t>>,
}

///
/// Type derived for non-terminal ModulePortListOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModulePortListOpt<'t> {
    pub comma: Box<Comma<'t>>,
}

///
/// Type derived for non-terminal ModulePortOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModulePortOpt<'t> {
    pub module_port_list: Box<ModulePortList<'t>>,
}

///
/// Type derived for non-terminal Mul
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Mul<'t> {
    pub mul: Token<'t>, /* * */
}

///
/// Type derived for non-terminal Negedge
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Negedge<'t> {
    pub negedge: Token<'t>, /* negedge */
}

///
/// Type derived for non-terminal Number
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Number<'t> {
    pub integral_number: Box<IntegralNumber<'t>>,
}

///
/// Type derived for non-terminal OctalNumber
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct OctalNumber<'t> {
    pub base_less: Box<BaseLess<'t>>,
    pub based_octal: Box<BasedOctal<'t>>,
}

///
/// Type derived for non-terminal OperatorPrecedence1
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum OperatorPrecedence1<'t> {
    OperatorPrecedence10(OperatorPrecedence3<'t>),
    OperatorPrecedence11(OperatorPrecedence4<'t>),
}

///
/// Type derived for non-terminal OperatorPrecedence2
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum OperatorPrecedence2<'t> {
    OperatorPrecedence20(OperatorPrecedence5<'t>),
    OperatorPrecedence21(OperatorPrecedence6<'t>),
}

///
/// Type derived for non-terminal Output
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Output<'t> {
    pub output: Token<'t>, /* output */
}

///
/// Type derived for non-terminal Parameter
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Parameter<'t> {
    pub parameter: Token<'t>, /* parameter */
}

///
/// Type derived for non-terminal ParameterDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ParameterDeclaration<'t> {
    pub parameter: Box<Parameter<'t>>,
    pub identifier: Box<Identifier<'t>>,
    pub colon: Box<Colon<'t>>,
    pub r#type: Box<Type<'t>>,
    pub assignment: Box<Assignment<'t>>,
    pub expression: Box<Expression<'t>>,
    pub semi_colon: Box<SemiColon<'t>>,
}

///
/// Type derived for non-terminal Plus
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Plus<'t> {
    pub plus: Token<'t>, /* + */
}

///
/// Type derived for non-terminal Posedge
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Posedge<'t> {
    pub posedge: Token<'t>, /* posedge */
}

///
/// Type derived for non-terminal RBrace
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct RBrace<'t> {
    pub r_brace: Token<'t>, /* } */
}

///
/// Type derived for non-terminal RBracket
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct RBracket<'t> {
    pub r_bracket: Token<'t>, /* ] */
}

///
/// Type derived for non-terminal RParen
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct RParen<'t> {
    pub r_paren: Token<'t>, /* ) */
}

///
/// Type derived for non-terminal Range
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Range<'t> {
    pub l_bracket: Box<LBracket<'t>>,
    pub expression: Box<Expression<'t>>,
    pub range_opt: Option<Box<RangeOpt<'t>>>,
    pub r_bracket: Box<RBracket<'t>>,
}

///
/// Type derived for non-terminal RangeOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct RangeOpt<'t> {
    pub colon: Box<Colon<'t>>,
    pub expression: Box<Expression<'t>>,
}

///
/// Type derived for non-terminal SemiColon
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct SemiColon<'t> {
    pub semi_colon: Token<'t>, /* ; */
}

///
/// Type derived for non-terminal Sharp
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Sharp<'t> {
    pub sharp: Token<'t>, /* # */
}

///
/// Type derived for non-terminal Statement
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Statement<'t> {
    Statement0(Statement0<'t>),
    Statement1(Statement1<'t>),
}

///
/// Type derived for non-terminal Type
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Type<'t> {
    pub type_group: Box<TypeGroup<'t>>,
    pub type_list: Vec<TypeList<'t>>,
}

///
/// Type derived for non-terminal TypeGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum TypeGroup<'t> {
    TypeGroup0(TypeGroup0<'t>),
    TypeGroup1(TypeGroup1<'t>),
}

///
/// Type derived for non-terminal TypeList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct TypeList<'t> {
    pub width: Box<Width<'t>>,
}

///
/// Type derived for non-terminal VariableDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct VariableDeclaration<'t> {
    pub identifier: Box<Identifier<'t>>,
    pub colon: Box<Colon<'t>>,
    pub r#type: Box<Type<'t>>,
    pub semi_colon: Box<SemiColon<'t>>,
}

///
/// Type derived for non-terminal Veryl
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Veryl<'t> {
    pub veryl_list: Vec<VerylList<'t>>,
}

///
/// Type derived for non-terminal VerylList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct VerylList<'t> {
    pub description: Box<Description<'t>>,
}

///
/// Type derived for non-terminal Width
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Width<'t> {
    pub l_bracket: Box<LBracket<'t>>,
    pub expression: Box<Expression<'t>>,
    pub r_bracket: Box<RBracket<'t>>,
}

///
/// Type derived for non-terminal WithParameter
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct WithParameter<'t> {
    pub sharp: Box<Sharp<'t>>,
    pub l_paren: Box<LParen<'t>>,
    pub with_parameter_opt: Option<Box<WithParameterOpt<'t>>>,
    pub r_paren: Box<RParen<'t>>,
}

///
/// Type derived for non-terminal WithParameterItem
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct WithParameterItem<'t> {
    pub with_parameter_item_group: Box<WithParameterItemGroup<'t>>,
    pub identifier: Box<Identifier<'t>>,
    pub colon: Box<Colon<'t>>,
    pub r#type: Box<Type<'t>>,
    pub assignment: Box<Assignment<'t>>,
    pub expression: Box<Expression<'t>>,
}

///
/// Type derived for non-terminal WithParameterItemGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum WithParameterItemGroup<'t> {
    WithParameterItemGroup0(WithParameterItemGroup0<'t>),
    WithParameterItemGroup1(WithParameterItemGroup1<'t>),
}

///
/// Type derived for non-terminal WithParameterList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct WithParameterList<'t> {
    pub with_parameter_item: Box<WithParameterItem<'t>>,
    pub with_parameter_list_list: Vec<WithParameterListList<'t>>,
    pub with_parameter_list_opt: Option<Box<WithParameterListOpt<'t>>>,
}

///
/// Type derived for non-terminal WithParameterListList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct WithParameterListList<'t> {
    pub comma: Box<Comma<'t>>,
    pub with_parameter_item: Box<WithParameterItem<'t>>,
}

///
/// Type derived for non-terminal WithParameterListOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct WithParameterListOpt<'t> {
    pub comma: Box<Comma<'t>>,
}

///
/// Type derived for non-terminal WithParameterOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct WithParameterOpt<'t> {
    pub with_parameter_list: Box<WithParameterList<'t>>,
}

// -------------------------------------------------------------------------------------------------

///
/// Deduced ASTType of expanded grammar
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ASTType<'t> {
    AlwaysComb(AlwaysComb<'t>),
    AlwaysCombDeclaration(AlwaysCombDeclaration<'t>),
    AlwaysCombDeclarationList(Vec<AlwaysCombDeclarationList<'t>>),
    AlwaysFF(AlwaysFF<'t>),
    AlwaysFFCondition(AlwaysFFCondition<'t>),
    AlwaysFFConditionGroup(AlwaysFFConditionGroup<'t>),
    AlwaysFFConditions(AlwaysFFConditions<'t>),
    AlwaysFFConditionsList(Vec<AlwaysFFConditionsList<'t>>),
    AlwaysFFConditionsOpt(Option<Box<AlwaysFFConditionsOpt<'t>>>),
    AlwaysFFDeclaration(AlwaysFFDeclaration<'t>),
    AlwaysFFDeclarationList(Vec<AlwaysFFDeclarationList<'t>>),
    Assignment(Assignment<'t>),
    AssignmentStatement(AssignmentStatement<'t>),
    BaseLess(BaseLess<'t>),
    BaseLessNumber(BaseLessNumber<'t>),
    BasedBinary(BasedBinary<'t>),
    BasedDecimal(BasedDecimal<'t>),
    BasedHex(BasedHex<'t>),
    BasedOctal(BasedOctal<'t>),
    BinaryNumber(BinaryNumber<'t>),
    Bit(Bit<'t>),
    BuiltinType(BuiltinType<'t>),
    Colon(Colon<'t>),
    Comma(Comma<'t>),
    DecimalNumber(DecimalNumber<'t>),
    Description(Description<'t>),
    Direction(Direction<'t>),
    Div(Div<'t>),
    Else(Else<'t>),
    Expression(Expression<'t>),
    Expression0(Expression0<'t>),
    Expression0List(Vec<Expression0List<'t>>),
    Expression1(Expression1<'t>),
    Expression1List(Vec<Expression1List<'t>>),
    Expression2(Expression2<'t>),
    Factor(Factor<'t>),
    FactorOpt(Option<Box<FactorOpt<'t>>>),
    HexNumber(HexNumber<'t>),
    Identifier(Identifier<'t>),
    If(If<'t>),
    IfStatement(IfStatement<'t>),
    IfStatementList(Vec<IfStatementList<'t>>),
    IfStatementOpt(Option<Box<IfStatementOpt<'t>>>),
    Inout(Inout<'t>),
    Input(Input<'t>),
    IntegralNumber(IntegralNumber<'t>),
    Interface(Interface<'t>),
    InterfaceDeclaration(InterfaceDeclaration<'t>),
    InterfaceDeclarationList(Vec<InterfaceDeclarationList<'t>>),
    InterfaceDeclarationOpt(Option<Box<InterfaceDeclarationOpt<'t>>>),
    InterfaceItem(InterfaceItem<'t>),
    LBrace(LBrace<'t>),
    LBracket(LBracket<'t>),
    LParen(LParen<'t>),
    Localparam(Localparam<'t>),
    LocalparamDeclaration(LocalparamDeclaration<'t>),
    Logic(Logic<'t>),
    Minus(Minus<'t>),
    Modport(Modport<'t>),
    ModportDeclaration(ModportDeclaration<'t>),
    ModportItem(ModportItem<'t>),
    ModportList(ModportList<'t>),
    ModportListList(Vec<ModportListList<'t>>),
    ModportListOpt(Option<Box<ModportListOpt<'t>>>),
    Module(Module<'t>),
    ModuleDeclaration(ModuleDeclaration<'t>),
    ModuleDeclarationList(Vec<ModuleDeclarationList<'t>>),
    ModuleDeclarationOpt(Option<Box<ModuleDeclarationOpt<'t>>>),
    ModuleDeclarationOpt0(Option<Box<ModuleDeclarationOpt0<'t>>>),
    ModuleItem(ModuleItem<'t>),
    ModulePort(ModulePort<'t>),
    ModulePortItem(ModulePortItem<'t>),
    ModulePortList(ModulePortList<'t>),
    ModulePortListList(Vec<ModulePortListList<'t>>),
    ModulePortListOpt(Option<Box<ModulePortListOpt<'t>>>),
    ModulePortOpt(Option<Box<ModulePortOpt<'t>>>),
    Mul(Mul<'t>),
    Negedge(Negedge<'t>),
    Number(Number<'t>),
    OctalNumber(OctalNumber<'t>),
    OperatorPrecedence1(OperatorPrecedence1<'t>),
    OperatorPrecedence2(OperatorPrecedence2<'t>),
    Output(Output<'t>),
    Parameter(Parameter<'t>),
    ParameterDeclaration(ParameterDeclaration<'t>),
    Plus(Plus<'t>),
    Posedge(Posedge<'t>),
    RBrace(RBrace<'t>),
    RBracket(RBracket<'t>),
    RParen(RParen<'t>),
    Range(Range<'t>),
    RangeOpt(Option<Box<RangeOpt<'t>>>),
    SemiColon(SemiColon<'t>),
    Sharp(Sharp<'t>),
    Statement(Statement<'t>),
    Type(Type<'t>),
    TypeGroup(TypeGroup<'t>),
    TypeList(Vec<TypeList<'t>>),
    VariableDeclaration(VariableDeclaration<'t>),
    Veryl(Veryl<'t>),
    VerylList(Vec<VerylList<'t>>),
    Width(Width<'t>),
    WithParameter(WithParameter<'t>),
    WithParameterItem(WithParameterItem<'t>),
    WithParameterItemGroup(WithParameterItemGroup<'t>),
    WithParameterList(WithParameterList<'t>),
    WithParameterListList(Vec<WithParameterListList<'t>>),
    WithParameterListOpt(Option<Box<WithParameterListOpt<'t>>>),
    WithParameterOpt(Option<Box<WithParameterOpt<'t>>>),
}

/// Auto-implemented adapter grammar
///
/// The lifetime parameter `'t` refers to the lifetime of the scanned text.
/// The lifetime parameter `'u` refers to the lifetime of user grammar object.
///
#[allow(dead_code)]
pub struct VerylGrammarAuto<'t, 'u>
where
    't: 'u,
{
    // Mutable reference of the actual user grammar to be able to call the semantic actions on it
    user_grammar: &'u mut dyn VerylGrammarTrait<'t>,
    // Stack to construct the AST on it
    item_stack: Vec<ASTType<'t>>,
}

///
/// The `VerylGrammarAuto` impl is automatically generated for the
/// given grammar.
///
impl<'t, 'u> VerylGrammarAuto<'t, 'u> {
    pub fn new(user_grammar: &'u mut dyn VerylGrammarTrait<'t>) -> Self {
        Self {
            user_grammar,
            item_stack: Vec::new(),
        }
    }

    #[allow(dead_code)]
    fn push(&mut self, item: ASTType<'t>, context: &str) {
        trace!("push    {}: {:?}", context, item);
        self.item_stack.push(item)
    }

    #[allow(dead_code)]
    fn pop(&mut self, context: &str) -> Option<ASTType<'t>> {
        if !self.item_stack.is_empty() {
            let item = self.item_stack.pop();
            if let Some(ref item) = item {
                trace!("pop     {}: {:?}", context, item);
            }
            item
        } else {
            None
        }
    }

    #[allow(dead_code)]
    // Use this function for debugging purposes:
    // trace!("{}", self.trace_item_stack(context));
    fn trace_item_stack(&self, context: &str) -> std::string::String {
        format!(
            "Item stack at {}:\n{}",
            context,
            self.item_stack
                .iter()
                .rev()
                .map(|s| format!("  {:?}", s))
                .collect::<Vec<std::string::String>>()
                .join("\n")
        )
    }

    /// Semantic action for production 0:
    ///
    /// BasedBinary: /'b[0-1xzXZ]+(?:_[0-1xzXZ]+)*/;
    ///
    #[parol_runtime::function_name::named]
    fn based_binary(
        &mut self,
        based_binary: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let based_binary = based_binary.token(parse_tree)?.clone();
        let based_binary_built = BasedBinaryBuilder::default()
            .based_binary(based_binary)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.based_binary(&based_binary_built)?;
        self.push(ASTType::BasedBinary(based_binary_built), context);
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// BasedOctal: /'o[0-7xzXZ]+(?:_[0-7xzXZ]+)*/;
    ///
    #[parol_runtime::function_name::named]
    fn based_octal(
        &mut self,
        based_octal: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let based_octal = based_octal.token(parse_tree)?.clone();
        let based_octal_built = BasedOctalBuilder::default()
            .based_octal(based_octal)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.based_octal(&based_octal_built)?;
        self.push(ASTType::BasedOctal(based_octal_built), context);
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// BasedDecimal: /'d[0-9]+(?:_[0-9]+)*/;
    ///
    #[parol_runtime::function_name::named]
    fn based_decimal(
        &mut self,
        based_decimal: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let based_decimal = based_decimal.token(parse_tree)?.clone();
        let based_decimal_built = BasedDecimalBuilder::default()
            .based_decimal(based_decimal)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.based_decimal(&based_decimal_built)?;
        self.push(ASTType::BasedDecimal(based_decimal_built), context);
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// BasedHex: /'h[0-9a-fA-FxzXZ]+(?:_[0-9a-fA-FxzXZ]+)*/;
    ///
    #[parol_runtime::function_name::named]
    fn based_hex(
        &mut self,
        based_hex: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let based_hex = based_hex.token(parse_tree)?.clone();
        let based_hex_built = BasedHexBuilder::default()
            .based_hex(based_hex)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.based_hex(&based_hex_built)?;
        self.push(ASTType::BasedHex(based_hex_built), context);
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// BaseLess: /[0-9]+(?:_[0-9]+)*/;
    ///
    #[parol_runtime::function_name::named]
    fn base_less(
        &mut self,
        base_less: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let base_less = base_less.token(parse_tree)?.clone();
        let base_less_built = BaseLessBuilder::default()
            .base_less(base_less)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.base_less(&base_less_built)?;
        self.push(ASTType::BaseLess(base_less_built), context);
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// Plus: '+';
    ///
    #[parol_runtime::function_name::named]
    fn plus(
        &mut self,
        plus: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let plus = plus.token(parse_tree)?.clone();
        let plus_built = PlusBuilder::default()
            .plus(plus)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.plus(&plus_built)?;
        self.push(ASTType::Plus(plus_built), context);
        Ok(())
    }

    /// Semantic action for production 6:
    ///
    /// Minus: '-';
    ///
    #[parol_runtime::function_name::named]
    fn minus(
        &mut self,
        minus: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let minus = minus.token(parse_tree)?.clone();
        let minus_built = MinusBuilder::default()
            .minus(minus)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.minus(&minus_built)?;
        self.push(ASTType::Minus(minus_built), context);
        Ok(())
    }

    /// Semantic action for production 7:
    ///
    /// Mul: '*';
    ///
    #[parol_runtime::function_name::named]
    fn mul(
        &mut self,
        mul: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mul = mul.token(parse_tree)?.clone();
        let mul_built = MulBuilder::default().mul(mul).build().into_diagnostic()?;
        // Calling user action here
        self.user_grammar.mul(&mul_built)?;
        self.push(ASTType::Mul(mul_built), context);
        Ok(())
    }

    /// Semantic action for production 8:
    ///
    /// Div: '/';
    ///
    #[parol_runtime::function_name::named]
    fn div(
        &mut self,
        div: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let div = div.token(parse_tree)?.clone();
        let div_built = DivBuilder::default().div(div).build().into_diagnostic()?;
        // Calling user action here
        self.user_grammar.div(&div_built)?;
        self.push(ASTType::Div(div_built), context);
        Ok(())
    }

    /// Semantic action for production 9:
    ///
    /// Colon: ':';
    ///
    #[parol_runtime::function_name::named]
    fn colon(
        &mut self,
        colon: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let colon = colon.token(parse_tree)?.clone();
        let colon_built = ColonBuilder::default()
            .colon(colon)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.colon(&colon_built)?;
        self.push(ASTType::Colon(colon_built), context);
        Ok(())
    }

    /// Semantic action for production 10:
    ///
    /// SemiColon: ';';
    ///
    #[parol_runtime::function_name::named]
    fn semi_colon(
        &mut self,
        semi_colon: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semi_colon = semi_colon.token(parse_tree)?.clone();
        let semi_colon_built = SemiColonBuilder::default()
            .semi_colon(semi_colon)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.semi_colon(&semi_colon_built)?;
        self.push(ASTType::SemiColon(semi_colon_built), context);
        Ok(())
    }

    /// Semantic action for production 11:
    ///
    /// Comma: ',';
    ///
    #[parol_runtime::function_name::named]
    fn comma(
        &mut self,
        comma: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = comma.token(parse_tree)?.clone();
        let comma_built = CommaBuilder::default()
            .comma(comma)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.comma(&comma_built)?;
        self.push(ASTType::Comma(comma_built), context);
        Ok(())
    }

    /// Semantic action for production 12:
    ///
    /// LParen: '(';
    ///
    #[parol_runtime::function_name::named]
    fn l_paren(
        &mut self,
        l_paren: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_paren = l_paren.token(parse_tree)?.clone();
        let l_paren_built = LParenBuilder::default()
            .l_paren(l_paren)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.l_paren(&l_paren_built)?;
        self.push(ASTType::LParen(l_paren_built), context);
        Ok(())
    }

    /// Semantic action for production 13:
    ///
    /// RParen: ')';
    ///
    #[parol_runtime::function_name::named]
    fn r_paren(
        &mut self,
        r_paren: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren = r_paren.token(parse_tree)?.clone();
        let r_paren_built = RParenBuilder::default()
            .r_paren(r_paren)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.r_paren(&r_paren_built)?;
        self.push(ASTType::RParen(r_paren_built), context);
        Ok(())
    }

    /// Semantic action for production 14:
    ///
    /// LBracket: '[';
    ///
    #[parol_runtime::function_name::named]
    fn l_bracket(
        &mut self,
        l_bracket: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_bracket = l_bracket.token(parse_tree)?.clone();
        let l_bracket_built = LBracketBuilder::default()
            .l_bracket(l_bracket)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.l_bracket(&l_bracket_built)?;
        self.push(ASTType::LBracket(l_bracket_built), context);
        Ok(())
    }

    /// Semantic action for production 15:
    ///
    /// RBracket: ']';
    ///
    #[parol_runtime::function_name::named]
    fn r_bracket(
        &mut self,
        r_bracket: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_bracket = r_bracket.token(parse_tree)?.clone();
        let r_bracket_built = RBracketBuilder::default()
            .r_bracket(r_bracket)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.r_bracket(&r_bracket_built)?;
        self.push(ASTType::RBracket(r_bracket_built), context);
        Ok(())
    }

    /// Semantic action for production 16:
    ///
    /// LBrace: '{';
    ///
    #[parol_runtime::function_name::named]
    fn l_brace(
        &mut self,
        l_brace: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_brace = l_brace.token(parse_tree)?.clone();
        let l_brace_built = LBraceBuilder::default()
            .l_brace(l_brace)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.l_brace(&l_brace_built)?;
        self.push(ASTType::LBrace(l_brace_built), context);
        Ok(())
    }

    /// Semantic action for production 17:
    ///
    /// RBrace: '}';
    ///
    #[parol_runtime::function_name::named]
    fn r_brace(
        &mut self,
        r_brace: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = r_brace.token(parse_tree)?.clone();
        let r_brace_built = RBraceBuilder::default()
            .r_brace(r_brace)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.r_brace(&r_brace_built)?;
        self.push(ASTType::RBrace(r_brace_built), context);
        Ok(())
    }

    /// Semantic action for production 18:
    ///
    /// Assignment: '=';
    ///
    #[parol_runtime::function_name::named]
    fn assignment(
        &mut self,
        assignment: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let assignment = assignment.token(parse_tree)?.clone();
        let assignment_built = AssignmentBuilder::default()
            .assignment(assignment)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.assignment(&assignment_built)?;
        self.push(ASTType::Assignment(assignment_built), context);
        Ok(())
    }

    /// Semantic action for production 19:
    ///
    /// Sharp: '#';
    ///
    #[parol_runtime::function_name::named]
    fn sharp(
        &mut self,
        sharp: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let sharp = sharp.token(parse_tree)?.clone();
        let sharp_built = SharpBuilder::default()
            .sharp(sharp)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.sharp(&sharp_built)?;
        self.push(ASTType::Sharp(sharp_built), context);
        Ok(())
    }

    /// Semantic action for production 20:
    ///
    /// Logic: 'logic';
    ///
    #[parol_runtime::function_name::named]
    fn logic(
        &mut self,
        logic: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logic = logic.token(parse_tree)?.clone();
        let logic_built = LogicBuilder::default()
            .logic(logic)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.logic(&logic_built)?;
        self.push(ASTType::Logic(logic_built), context);
        Ok(())
    }

    /// Semantic action for production 21:
    ///
    /// Bit: 'bit';
    ///
    #[parol_runtime::function_name::named]
    fn bit(
        &mut self,
        bit: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bit = bit.token(parse_tree)?.clone();
        let bit_built = BitBuilder::default().bit(bit).build().into_diagnostic()?;
        // Calling user action here
        self.user_grammar.bit(&bit_built)?;
        self.push(ASTType::Bit(bit_built), context);
        Ok(())
    }

    /// Semantic action for production 22:
    ///
    /// AlwaysFF: 'always_ff';
    ///
    #[parol_runtime::function_name::named]
    fn always_f_f(
        &mut self,
        always_f_f: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let always_f_f = always_f_f.token(parse_tree)?.clone();
        let always_f_f_built = AlwaysFFBuilder::default()
            .always_f_f(always_f_f)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.always_f_f(&always_f_f_built)?;
        self.push(ASTType::AlwaysFF(always_f_f_built), context);
        Ok(())
    }

    /// Semantic action for production 23:
    ///
    /// AlwaysComb: 'always_comb';
    ///
    #[parol_runtime::function_name::named]
    fn always_comb(
        &mut self,
        always_comb: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let always_comb = always_comb.token(parse_tree)?.clone();
        let always_comb_built = AlwaysCombBuilder::default()
            .always_comb(always_comb)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.always_comb(&always_comb_built)?;
        self.push(ASTType::AlwaysComb(always_comb_built), context);
        Ok(())
    }

    /// Semantic action for production 24:
    ///
    /// Posedge: 'posedge';
    ///
    #[parol_runtime::function_name::named]
    fn posedge(
        &mut self,
        posedge: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let posedge = posedge.token(parse_tree)?.clone();
        let posedge_built = PosedgeBuilder::default()
            .posedge(posedge)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.posedge(&posedge_built)?;
        self.push(ASTType::Posedge(posedge_built), context);
        Ok(())
    }

    /// Semantic action for production 25:
    ///
    /// Negedge: 'negedge';
    ///
    #[parol_runtime::function_name::named]
    fn negedge(
        &mut self,
        negedge: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let negedge = negedge.token(parse_tree)?.clone();
        let negedge_built = NegedgeBuilder::default()
            .negedge(negedge)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.negedge(&negedge_built)?;
        self.push(ASTType::Negedge(negedge_built), context);
        Ok(())
    }

    /// Semantic action for production 26:
    ///
    /// If: 'if';
    ///
    #[parol_runtime::function_name::named]
    fn r#if(
        &mut self,
        r#if: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#if = r#if.token(parse_tree)?.clone();
        let r#if_built = IfBuilder::default().r#if(r#if).build().into_diagnostic()?;
        // Calling user action here
        self.user_grammar.r#if(&r#if_built)?;
        self.push(ASTType::If(r#if_built), context);
        Ok(())
    }

    /// Semantic action for production 27:
    ///
    /// Else: 'else';
    ///
    #[parol_runtime::function_name::named]
    fn r#else(
        &mut self,
        r#else: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#else = r#else.token(parse_tree)?.clone();
        let r#else_built = ElseBuilder::default()
            .r#else(r#else)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.r#else(&r#else_built)?;
        self.push(ASTType::Else(r#else_built), context);
        Ok(())
    }

    /// Semantic action for production 28:
    ///
    /// Parameter: 'parameter';
    ///
    #[parol_runtime::function_name::named]
    fn parameter(
        &mut self,
        parameter: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let parameter = parameter.token(parse_tree)?.clone();
        let parameter_built = ParameterBuilder::default()
            .parameter(parameter)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.parameter(&parameter_built)?;
        self.push(ASTType::Parameter(parameter_built), context);
        Ok(())
    }

    /// Semantic action for production 29:
    ///
    /// Localparam: 'localparam';
    ///
    #[parol_runtime::function_name::named]
    fn localparam(
        &mut self,
        localparam: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let localparam = localparam.token(parse_tree)?.clone();
        let localparam_built = LocalparamBuilder::default()
            .localparam(localparam)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.localparam(&localparam_built)?;
        self.push(ASTType::Localparam(localparam_built), context);
        Ok(())
    }

    /// Semantic action for production 30:
    ///
    /// Module: 'module';
    ///
    #[parol_runtime::function_name::named]
    fn module(
        &mut self,
        module: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module = module.token(parse_tree)?.clone();
        let module_built = ModuleBuilder::default()
            .module(module)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.module(&module_built)?;
        self.push(ASTType::Module(module_built), context);
        Ok(())
    }

    /// Semantic action for production 31:
    ///
    /// Interface: 'interface';
    ///
    #[parol_runtime::function_name::named]
    fn interface(
        &mut self,
        interface: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let interface = interface.token(parse_tree)?.clone();
        let interface_built = InterfaceBuilder::default()
            .interface(interface)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.interface(&interface_built)?;
        self.push(ASTType::Interface(interface_built), context);
        Ok(())
    }

    /// Semantic action for production 32:
    ///
    /// Input: 'input';
    ///
    #[parol_runtime::function_name::named]
    fn input(
        &mut self,
        input: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let input = input.token(parse_tree)?.clone();
        let input_built = InputBuilder::default()
            .input(input)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.input(&input_built)?;
        self.push(ASTType::Input(input_built), context);
        Ok(())
    }

    /// Semantic action for production 33:
    ///
    /// Output: 'output';
    ///
    #[parol_runtime::function_name::named]
    fn output(
        &mut self,
        output: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let output = output.token(parse_tree)?.clone();
        let output_built = OutputBuilder::default()
            .output(output)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.output(&output_built)?;
        self.push(ASTType::Output(output_built), context);
        Ok(())
    }

    /// Semantic action for production 34:
    ///
    /// Inout: 'inout';
    ///
    #[parol_runtime::function_name::named]
    fn inout(
        &mut self,
        inout: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inout = inout.token(parse_tree)?.clone();
        let inout_built = InoutBuilder::default()
            .inout(inout)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.inout(&inout_built)?;
        self.push(ASTType::Inout(inout_built), context);
        Ok(())
    }

    /// Semantic action for production 35:
    ///
    /// Modport: 'modport';
    ///
    #[parol_runtime::function_name::named]
    fn modport(
        &mut self,
        modport: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let modport = modport.token(parse_tree)?.clone();
        let modport_built = ModportBuilder::default()
            .modport(modport)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.modport(&modport_built)?;
        self.push(ASTType::Modport(modport_built), context);
        Ok(())
    }

    /// Semantic action for production 36:
    ///
    /// Identifier: /[a-zA-Z_][0-9a-zA-Z_]*/;
    ///
    #[parol_runtime::function_name::named]
    fn identifier(
        &mut self,
        identifier: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let identifier = identifier.token(parse_tree)?.clone();
        let identifier_built = IdentifierBuilder::default()
            .identifier(identifier)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.identifier(&identifier_built)?;
        self.push(ASTType::Identifier(identifier_built), context);
        Ok(())
    }

    /// Semantic action for production 37:
    ///
    /// Veryl: VerylList /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn veryl(
        &mut self,
        _veryl_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let veryl_list = pop_and_reverse_item!(self, veryl_list, VerylList, context);
        let veryl_built = VerylBuilder::default()
            .veryl_list(veryl_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.veryl(&veryl_built)?;
        self.push(ASTType::Veryl(veryl_built), context);
        Ok(())
    }

    /// Semantic action for production 38:
    ///
    /// VerylList /* Vec<T>::Push */: Description VerylList;
    ///
    #[parol_runtime::function_name::named]
    fn veryl_list_0(
        &mut self,
        _description: &ParseTreeStackEntry<'t>,
        _veryl_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut veryl_list = pop_item!(self, veryl_list, VerylList, context);
        let description = pop_item!(self, description, Description, context);
        let veryl_list_0_built = VerylListBuilder::default()
            .description(Box::new(description))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        veryl_list.push(veryl_list_0_built);
        self.push(ASTType::VerylList(veryl_list), context);
        Ok(())
    }

    /// Semantic action for production 39:
    ///
    /// VerylList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn veryl_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let veryl_list_1_built = Vec::new();
        self.push(ASTType::VerylList(veryl_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 40:
    ///
    /// Description: ModuleDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn description_0(
        &mut self,
        _module_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module_declaration = pop_item!(self, module_declaration, ModuleDeclaration, context);
        let description_0_built = Description0Builder::default()
            .module_declaration(Box::new(module_declaration))
            .build()
            .into_diagnostic()?;
        let description_0_built = Description::Description0(description_0_built);
        // Calling user action here
        self.user_grammar.description(&description_0_built)?;
        self.push(ASTType::Description(description_0_built), context);
        Ok(())
    }

    /// Semantic action for production 41:
    ///
    /// Description: InterfaceDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn description_1(
        &mut self,
        _interface_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let interface_declaration =
            pop_item!(self, interface_declaration, InterfaceDeclaration, context);
        let description_1_built = Description1Builder::default()
            .interface_declaration(Box::new(interface_declaration))
            .build()
            .into_diagnostic()?;
        let description_1_built = Description::Description1(description_1_built);
        // Calling user action here
        self.user_grammar.description(&description_1_built)?;
        self.push(ASTType::Description(description_1_built), context);
        Ok(())
    }

    /// Semantic action for production 42:
    ///
    /// Number: IntegralNumber;
    ///
    #[parol_runtime::function_name::named]
    fn number(
        &mut self,
        _integral_number: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let integral_number = pop_item!(self, integral_number, IntegralNumber, context);
        let number_built = NumberBuilder::default()
            .integral_number(Box::new(integral_number))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.number(&number_built)?;
        self.push(ASTType::Number(number_built), context);
        Ok(())
    }

    /// Semantic action for production 43:
    ///
    /// IntegralNumber: BinaryNumber;
    ///
    #[parol_runtime::function_name::named]
    fn integral_number_0(
        &mut self,
        _binary_number: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let binary_number = pop_item!(self, binary_number, BinaryNumber, context);
        let integral_number_0_built = IntegralNumber0Builder::default()
            .binary_number(Box::new(binary_number))
            .build()
            .into_diagnostic()?;
        let integral_number_0_built = IntegralNumber::IntegralNumber0(integral_number_0_built);
        // Calling user action here
        self.user_grammar
            .integral_number(&integral_number_0_built)?;
        self.push(ASTType::IntegralNumber(integral_number_0_built), context);
        Ok(())
    }

    /// Semantic action for production 44:
    ///
    /// IntegralNumber: OctalNumber;
    ///
    #[parol_runtime::function_name::named]
    fn integral_number_1(
        &mut self,
        _octal_number: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let octal_number = pop_item!(self, octal_number, OctalNumber, context);
        let integral_number_1_built = IntegralNumber1Builder::default()
            .octal_number(Box::new(octal_number))
            .build()
            .into_diagnostic()?;
        let integral_number_1_built = IntegralNumber::IntegralNumber1(integral_number_1_built);
        // Calling user action here
        self.user_grammar
            .integral_number(&integral_number_1_built)?;
        self.push(ASTType::IntegralNumber(integral_number_1_built), context);
        Ok(())
    }

    /// Semantic action for production 45:
    ///
    /// IntegralNumber: DecimalNumber;
    ///
    #[parol_runtime::function_name::named]
    fn integral_number_2(
        &mut self,
        _decimal_number: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let decimal_number = pop_item!(self, decimal_number, DecimalNumber, context);
        let integral_number_2_built = IntegralNumber2Builder::default()
            .decimal_number(Box::new(decimal_number))
            .build()
            .into_diagnostic()?;
        let integral_number_2_built = IntegralNumber::IntegralNumber2(integral_number_2_built);
        // Calling user action here
        self.user_grammar
            .integral_number(&integral_number_2_built)?;
        self.push(ASTType::IntegralNumber(integral_number_2_built), context);
        Ok(())
    }

    /// Semantic action for production 46:
    ///
    /// IntegralNumber: HexNumber;
    ///
    #[parol_runtime::function_name::named]
    fn integral_number_3(
        &mut self,
        _hex_number: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let hex_number = pop_item!(self, hex_number, HexNumber, context);
        let integral_number_3_built = IntegralNumber3Builder::default()
            .hex_number(Box::new(hex_number))
            .build()
            .into_diagnostic()?;
        let integral_number_3_built = IntegralNumber::IntegralNumber3(integral_number_3_built);
        // Calling user action here
        self.user_grammar
            .integral_number(&integral_number_3_built)?;
        self.push(ASTType::IntegralNumber(integral_number_3_built), context);
        Ok(())
    }

    /// Semantic action for production 47:
    ///
    /// IntegralNumber: BaseLessNumber;
    ///
    #[parol_runtime::function_name::named]
    fn integral_number_4(
        &mut self,
        _base_less_number: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let base_less_number = pop_item!(self, base_less_number, BaseLessNumber, context);
        let integral_number_4_built = IntegralNumber4Builder::default()
            .base_less_number(Box::new(base_less_number))
            .build()
            .into_diagnostic()?;
        let integral_number_4_built = IntegralNumber::IntegralNumber4(integral_number_4_built);
        // Calling user action here
        self.user_grammar
            .integral_number(&integral_number_4_built)?;
        self.push(ASTType::IntegralNumber(integral_number_4_built), context);
        Ok(())
    }

    /// Semantic action for production 48:
    ///
    /// BinaryNumber: BaseLess BasedBinary;
    ///
    #[parol_runtime::function_name::named]
    fn binary_number(
        &mut self,
        _base_less: &ParseTreeStackEntry<'t>,
        _based_binary: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let based_binary = pop_item!(self, based_binary, BasedBinary, context);
        let base_less = pop_item!(self, base_less, BaseLess, context);
        let binary_number_built = BinaryNumberBuilder::default()
            .base_less(Box::new(base_less))
            .based_binary(Box::new(based_binary))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.binary_number(&binary_number_built)?;
        self.push(ASTType::BinaryNumber(binary_number_built), context);
        Ok(())
    }

    /// Semantic action for production 49:
    ///
    /// OctalNumber: BaseLess BasedOctal;
    ///
    #[parol_runtime::function_name::named]
    fn octal_number(
        &mut self,
        _base_less: &ParseTreeStackEntry<'t>,
        _based_octal: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let based_octal = pop_item!(self, based_octal, BasedOctal, context);
        let base_less = pop_item!(self, base_less, BaseLess, context);
        let octal_number_built = OctalNumberBuilder::default()
            .base_less(Box::new(base_less))
            .based_octal(Box::new(based_octal))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.octal_number(&octal_number_built)?;
        self.push(ASTType::OctalNumber(octal_number_built), context);
        Ok(())
    }

    /// Semantic action for production 50:
    ///
    /// DecimalNumber: BaseLess BasedDecimal;
    ///
    #[parol_runtime::function_name::named]
    fn decimal_number(
        &mut self,
        _base_less: &ParseTreeStackEntry<'t>,
        _based_decimal: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let based_decimal = pop_item!(self, based_decimal, BasedDecimal, context);
        let base_less = pop_item!(self, base_less, BaseLess, context);
        let decimal_number_built = DecimalNumberBuilder::default()
            .base_less(Box::new(base_less))
            .based_decimal(Box::new(based_decimal))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.decimal_number(&decimal_number_built)?;
        self.push(ASTType::DecimalNumber(decimal_number_built), context);
        Ok(())
    }

    /// Semantic action for production 51:
    ///
    /// HexNumber: BaseLess BasedHex;
    ///
    #[parol_runtime::function_name::named]
    fn hex_number(
        &mut self,
        _base_less: &ParseTreeStackEntry<'t>,
        _based_hex: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let based_hex = pop_item!(self, based_hex, BasedHex, context);
        let base_less = pop_item!(self, base_less, BaseLess, context);
        let hex_number_built = HexNumberBuilder::default()
            .base_less(Box::new(base_less))
            .based_hex(Box::new(based_hex))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.hex_number(&hex_number_built)?;
        self.push(ASTType::HexNumber(hex_number_built), context);
        Ok(())
    }

    /// Semantic action for production 52:
    ///
    /// BaseLessNumber: BaseLess;
    ///
    #[parol_runtime::function_name::named]
    fn base_less_number(
        &mut self,
        _base_less: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let base_less = pop_item!(self, base_less, BaseLess, context);
        let base_less_number_built = BaseLessNumberBuilder::default()
            .base_less(Box::new(base_less))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .base_less_number(&base_less_number_built)?;
        self.push(ASTType::BaseLessNumber(base_less_number_built), context);
        Ok(())
    }

    /// Semantic action for production 53:
    ///
    /// OperatorPrecedence1: Plus;
    ///
    #[parol_runtime::function_name::named]
    fn operator_precedence1_0(
        &mut self,
        _plus: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let plus = pop_item!(self, plus, Plus, context);
        let operator_precedence1_0_built = OperatorPrecedence3Builder::default()
            .plus(Box::new(plus))
            .build()
            .into_diagnostic()?;
        let operator_precedence1_0_built =
            OperatorPrecedence1::OperatorPrecedence10(operator_precedence1_0_built);
        // Calling user action here
        self.user_grammar
            .operator_precedence1(&operator_precedence1_0_built)?;
        self.push(
            ASTType::OperatorPrecedence1(operator_precedence1_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 54:
    ///
    /// OperatorPrecedence1: Minus;
    ///
    #[parol_runtime::function_name::named]
    fn operator_precedence1_1(
        &mut self,
        _minus: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let minus = pop_item!(self, minus, Minus, context);
        let operator_precedence1_1_built = OperatorPrecedence4Builder::default()
            .minus(Box::new(minus))
            .build()
            .into_diagnostic()?;
        let operator_precedence1_1_built =
            OperatorPrecedence1::OperatorPrecedence11(operator_precedence1_1_built);
        // Calling user action here
        self.user_grammar
            .operator_precedence1(&operator_precedence1_1_built)?;
        self.push(
            ASTType::OperatorPrecedence1(operator_precedence1_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 55:
    ///
    /// OperatorPrecedence2: Mul;
    ///
    #[parol_runtime::function_name::named]
    fn operator_precedence2_0(
        &mut self,
        _mul: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mul = pop_item!(self, mul, Mul, context);
        let operator_precedence2_0_built = OperatorPrecedence5Builder::default()
            .mul(Box::new(mul))
            .build()
            .into_diagnostic()?;
        let operator_precedence2_0_built =
            OperatorPrecedence2::OperatorPrecedence20(operator_precedence2_0_built);
        // Calling user action here
        self.user_grammar
            .operator_precedence2(&operator_precedence2_0_built)?;
        self.push(
            ASTType::OperatorPrecedence2(operator_precedence2_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 56:
    ///
    /// OperatorPrecedence2: Div;
    ///
    #[parol_runtime::function_name::named]
    fn operator_precedence2_1(
        &mut self,
        _div: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let div = pop_item!(self, div, Div, context);
        let operator_precedence2_1_built = OperatorPrecedence6Builder::default()
            .div(Box::new(div))
            .build()
            .into_diagnostic()?;
        let operator_precedence2_1_built =
            OperatorPrecedence2::OperatorPrecedence21(operator_precedence2_1_built);
        // Calling user action here
        self.user_grammar
            .operator_precedence2(&operator_precedence2_1_built)?;
        self.push(
            ASTType::OperatorPrecedence2(operator_precedence2_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 57:
    ///
    /// Expression: Expression0;
    ///
    #[parol_runtime::function_name::named]
    fn expression(
        &mut self,
        _expression0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression0 = pop_item!(self, expression0, Expression0, context);
        let expression_built = ExpressionBuilder::default()
            .expression0(Box::new(expression0))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.expression(&expression_built)?;
        self.push(ASTType::Expression(expression_built), context);
        Ok(())
    }

    /// Semantic action for production 58:
    ///
    /// Expression0: Expression1 Expression0List /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn expression0(
        &mut self,
        _expression1: &ParseTreeStackEntry<'t>,
        _expression0_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression0_list =
            pop_and_reverse_item!(self, expression0_list, Expression0List, context);
        let expression1 = pop_item!(self, expression1, Expression1, context);
        let expression0_built = Expression0Builder::default()
            .expression1(Box::new(expression1))
            .expression0_list(expression0_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.expression0(&expression0_built)?;
        self.push(ASTType::Expression0(expression0_built), context);
        Ok(())
    }

    /// Semantic action for production 59:
    ///
    /// Expression0List /* Vec<T>::Push */: OperatorPrecedence1 Expression1 Expression0List;
    ///
    #[parol_runtime::function_name::named]
    fn expression0_list_0(
        &mut self,
        _operator_precedence1: &ParseTreeStackEntry<'t>,
        _expression1: &ParseTreeStackEntry<'t>,
        _expression0_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression0_list = pop_item!(self, expression0_list, Expression0List, context);
        let expression1 = pop_item!(self, expression1, Expression1, context);
        let operator_precedence1 =
            pop_item!(self, operator_precedence1, OperatorPrecedence1, context);
        let expression0_list_0_built = Expression0ListBuilder::default()
            .expression1(Box::new(expression1))
            .operator_precedence1(Box::new(operator_precedence1))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        expression0_list.push(expression0_list_0_built);
        self.push(ASTType::Expression0List(expression0_list), context);
        Ok(())
    }

    /// Semantic action for production 60:
    ///
    /// Expression0List /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn expression0_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression0_list_1_built = Vec::new();
        self.push(ASTType::Expression0List(expression0_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 61:
    ///
    /// Expression1: Expression2 Expression1List /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn expression1(
        &mut self,
        _expression2: &ParseTreeStackEntry<'t>,
        _expression1_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression1_list =
            pop_and_reverse_item!(self, expression1_list, Expression1List, context);
        let expression2 = pop_item!(self, expression2, Expression2, context);
        let expression1_built = Expression1Builder::default()
            .expression2(Box::new(expression2))
            .expression1_list(expression1_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.expression1(&expression1_built)?;
        self.push(ASTType::Expression1(expression1_built), context);
        Ok(())
    }

    /// Semantic action for production 62:
    ///
    /// Expression1List /* Vec<T>::Push */: OperatorPrecedence2 Expression2 Expression1List;
    ///
    #[parol_runtime::function_name::named]
    fn expression1_list_0(
        &mut self,
        _operator_precedence2: &ParseTreeStackEntry<'t>,
        _expression2: &ParseTreeStackEntry<'t>,
        _expression1_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression1_list = pop_item!(self, expression1_list, Expression1List, context);
        let expression2 = pop_item!(self, expression2, Expression2, context);
        let operator_precedence2 =
            pop_item!(self, operator_precedence2, OperatorPrecedence2, context);
        let expression1_list_0_built = Expression1ListBuilder::default()
            .expression2(Box::new(expression2))
            .operator_precedence2(Box::new(operator_precedence2))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        expression1_list.push(expression1_list_0_built);
        self.push(ASTType::Expression1List(expression1_list), context);
        Ok(())
    }

    /// Semantic action for production 63:
    ///
    /// Expression1List /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn expression1_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression1_list_1_built = Vec::new();
        self.push(ASTType::Expression1List(expression1_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 64:
    ///
    /// Expression2: Factor;
    ///
    #[parol_runtime::function_name::named]
    fn expression2(
        &mut self,
        _factor: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let factor = pop_item!(self, factor, Factor, context);
        let expression2_built = Expression2Builder::default()
            .factor(Box::new(factor))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.expression2(&expression2_built)?;
        self.push(ASTType::Expression2(expression2_built), context);
        Ok(())
    }

    /// Semantic action for production 65:
    ///
    /// Factor: Number;
    ///
    #[parol_runtime::function_name::named]
    fn factor_0(
        &mut self,
        _number: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let number = pop_item!(self, number, Number, context);
        let factor_0_built = Factor0Builder::default()
            .number(Box::new(number))
            .build()
            .into_diagnostic()?;
        let factor_0_built = Factor::Factor0(factor_0_built);
        // Calling user action here
        self.user_grammar.factor(&factor_0_built)?;
        self.push(ASTType::Factor(factor_0_built), context);
        Ok(())
    }

    /// Semantic action for production 66:
    ///
    /// Factor: Identifier FactorOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn factor_1(
        &mut self,
        _identifier: &ParseTreeStackEntry<'t>,
        _factor_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let factor_opt = pop_item!(self, factor_opt, FactorOpt, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let factor_1_built = Factor1Builder::default()
            .identifier(Box::new(identifier))
            .factor_opt(factor_opt)
            .build()
            .into_diagnostic()?;
        let factor_1_built = Factor::Factor1(factor_1_built);
        // Calling user action here
        self.user_grammar.factor(&factor_1_built)?;
        self.push(ASTType::Factor(factor_1_built), context);
        Ok(())
    }

    /// Semantic action for production 67:
    ///
    /// Factor: LParen Expression RParen;
    ///
    #[parol_runtime::function_name::named]
    fn factor_2(
        &mut self,
        _l_paren: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _r_paren: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren = pop_item!(self, r_paren, RParen, context);
        let expression = pop_item!(self, expression, Expression, context);
        let l_paren = pop_item!(self, l_paren, LParen, context);
        let factor_2_built = Factor2Builder::default()
            .l_paren(Box::new(l_paren))
            .expression(Box::new(expression))
            .r_paren(Box::new(r_paren))
            .build()
            .into_diagnostic()?;
        let factor_2_built = Factor::Factor2(factor_2_built);
        // Calling user action here
        self.user_grammar.factor(&factor_2_built)?;
        self.push(ASTType::Factor(factor_2_built), context);
        Ok(())
    }

    /// Semantic action for production 68:
    ///
    /// FactorOpt /* Option<T>::Some */: Range;
    ///
    #[parol_runtime::function_name::named]
    fn factor_opt_0(
        &mut self,
        _range: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let range = pop_item!(self, range, Range, context);
        let factor_opt_0_built = FactorOptBuilder::default()
            .range(Box::new(range))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::FactorOpt(Some(Box::new(factor_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 69:
    ///
    /// FactorOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn factor_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::FactorOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 70:
    ///
    /// Statement: AssignmentStatement;
    ///
    #[parol_runtime::function_name::named]
    fn statement_0(
        &mut self,
        _assignment_statement: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let assignment_statement =
            pop_item!(self, assignment_statement, AssignmentStatement, context);
        let statement_0_built = Statement0Builder::default()
            .assignment_statement(Box::new(assignment_statement))
            .build()
            .into_diagnostic()?;
        let statement_0_built = Statement::Statement0(statement_0_built);
        // Calling user action here
        self.user_grammar.statement(&statement_0_built)?;
        self.push(ASTType::Statement(statement_0_built), context);
        Ok(())
    }

    /// Semantic action for production 71:
    ///
    /// Statement: IfStatement;
    ///
    #[parol_runtime::function_name::named]
    fn statement_1(
        &mut self,
        _if_statement: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_statement = pop_item!(self, if_statement, IfStatement, context);
        let statement_1_built = Statement1Builder::default()
            .if_statement(Box::new(if_statement))
            .build()
            .into_diagnostic()?;
        let statement_1_built = Statement::Statement1(statement_1_built);
        // Calling user action here
        self.user_grammar.statement(&statement_1_built)?;
        self.push(ASTType::Statement(statement_1_built), context);
        Ok(())
    }

    /// Semantic action for production 72:
    ///
    /// AssignmentStatement: Identifier Assignment Expression SemiColon;
    ///
    #[parol_runtime::function_name::named]
    fn assignment_statement(
        &mut self,
        _identifier: &ParseTreeStackEntry<'t>,
        _assignment: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _semi_colon: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semi_colon = pop_item!(self, semi_colon, SemiColon, context);
        let expression = pop_item!(self, expression, Expression, context);
        let assignment = pop_item!(self, assignment, Assignment, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let assignment_statement_built = AssignmentStatementBuilder::default()
            .identifier(Box::new(identifier))
            .assignment(Box::new(assignment))
            .expression(Box::new(expression))
            .semi_colon(Box::new(semi_colon))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .assignment_statement(&assignment_statement_built)?;
        self.push(
            ASTType::AssignmentStatement(assignment_statement_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 73:
    ///
    /// IfStatement: If Expression LBrace Statement RBrace IfStatementList /* Vec */ IfStatementOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn if_statement(
        &mut self,
        _if: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _l_brace: &ParseTreeStackEntry<'t>,
        _statement: &ParseTreeStackEntry<'t>,
        _r_brace: &ParseTreeStackEntry<'t>,
        _if_statement_list: &ParseTreeStackEntry<'t>,
        _if_statement_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_statement_opt = pop_item!(self, if_statement_opt, IfStatementOpt, context);
        let if_statement_list =
            pop_and_reverse_item!(self, if_statement_list, IfStatementList, context);
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let statement = pop_item!(self, statement, Statement, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let expression = pop_item!(self, expression, Expression, context);
        let r#if = pop_item!(self, r#if, If, context);
        let if_statement_built = IfStatementBuilder::default()
            .r#if(Box::new(r#if))
            .expression(Box::new(expression))
            .l_brace(Box::new(l_brace))
            .statement(Box::new(statement))
            .r_brace(Box::new(r_brace))
            .if_statement_list(if_statement_list)
            .if_statement_opt(if_statement_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.if_statement(&if_statement_built)?;
        self.push(ASTType::IfStatement(if_statement_built), context);
        Ok(())
    }

    /// Semantic action for production 74:
    ///
    /// IfStatementList /* Vec<T>::Push */: Else If Expression LBrace Statement RBrace IfStatementList;
    ///
    #[parol_runtime::function_name::named]
    fn if_statement_list_0(
        &mut self,
        _else: &ParseTreeStackEntry<'t>,
        _if: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _l_brace: &ParseTreeStackEntry<'t>,
        _statement: &ParseTreeStackEntry<'t>,
        _r_brace: &ParseTreeStackEntry<'t>,
        _if_statement_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut if_statement_list = pop_item!(self, if_statement_list, IfStatementList, context);
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let statement = pop_item!(self, statement, Statement, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let expression = pop_item!(self, expression, Expression, context);
        let r#if = pop_item!(self, r#if, If, context);
        let r#else = pop_item!(self, r#else, Else, context);
        let if_statement_list_0_built = IfStatementListBuilder::default()
            .r_brace(Box::new(r_brace))
            .statement(Box::new(statement))
            .l_brace(Box::new(l_brace))
            .expression(Box::new(expression))
            .r#if(Box::new(r#if))
            .r#else(Box::new(r#else))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        if_statement_list.push(if_statement_list_0_built);
        self.push(ASTType::IfStatementList(if_statement_list), context);
        Ok(())
    }

    /// Semantic action for production 75:
    ///
    /// IfStatementList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn if_statement_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_statement_list_1_built = Vec::new();
        self.push(ASTType::IfStatementList(if_statement_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 76:
    ///
    /// IfStatementOpt /* Option<T>::Some */: Else LBrace Statement RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn if_statement_opt_0(
        &mut self,
        _else: &ParseTreeStackEntry<'t>,
        _l_brace: &ParseTreeStackEntry<'t>,
        _statement: &ParseTreeStackEntry<'t>,
        _r_brace: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let statement = pop_item!(self, statement, Statement, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let r#else = pop_item!(self, r#else, Else, context);
        let if_statement_opt_0_built = IfStatementOptBuilder::default()
            .r#else(Box::new(r#else))
            .l_brace(Box::new(l_brace))
            .statement(Box::new(statement))
            .r_brace(Box::new(r_brace))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::IfStatementOpt(Some(Box::new(if_statement_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 77:
    ///
    /// IfStatementOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn if_statement_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::IfStatementOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 78:
    ///
    /// Range: LBracket Expression RangeOpt /* Option */ RBracket;
    ///
    #[parol_runtime::function_name::named]
    fn range(
        &mut self,
        _l_bracket: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _range_opt: &ParseTreeStackEntry<'t>,
        _r_bracket: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_bracket = pop_item!(self, r_bracket, RBracket, context);
        let range_opt = pop_item!(self, range_opt, RangeOpt, context);
        let expression = pop_item!(self, expression, Expression, context);
        let l_bracket = pop_item!(self, l_bracket, LBracket, context);
        let range_built = RangeBuilder::default()
            .l_bracket(Box::new(l_bracket))
            .expression(Box::new(expression))
            .range_opt(range_opt)
            .r_bracket(Box::new(r_bracket))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.range(&range_built)?;
        self.push(ASTType::Range(range_built), context);
        Ok(())
    }

    /// Semantic action for production 79:
    ///
    /// RangeOpt /* Option<T>::Some */: Colon Expression;
    ///
    #[parol_runtime::function_name::named]
    fn range_opt_0(
        &mut self,
        _colon: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = pop_item!(self, expression, Expression, context);
        let colon = pop_item!(self, colon, Colon, context);
        let range_opt_0_built = RangeOptBuilder::default()
            .colon(Box::new(colon))
            .expression(Box::new(expression))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::RangeOpt(Some(Box::new(range_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 80:
    ///
    /// RangeOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn range_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::RangeOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 81:
    ///
    /// Width: LBracket Expression RBracket;
    ///
    #[parol_runtime::function_name::named]
    fn width(
        &mut self,
        _l_bracket: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _r_bracket: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_bracket = pop_item!(self, r_bracket, RBracket, context);
        let expression = pop_item!(self, expression, Expression, context);
        let l_bracket = pop_item!(self, l_bracket, LBracket, context);
        let width_built = WidthBuilder::default()
            .l_bracket(Box::new(l_bracket))
            .expression(Box::new(expression))
            .r_bracket(Box::new(r_bracket))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.width(&width_built)?;
        self.push(ASTType::Width(width_built), context);
        Ok(())
    }

    /// Semantic action for production 82:
    ///
    /// BuiltinType: Logic;
    ///
    #[parol_runtime::function_name::named]
    fn builtin_type_0(
        &mut self,
        _logic: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logic = pop_item!(self, logic, Logic, context);
        let builtin_type_0_built = BuiltinType0Builder::default()
            .logic(Box::new(logic))
            .build()
            .into_diagnostic()?;
        let builtin_type_0_built = BuiltinType::BuiltinType0(builtin_type_0_built);
        // Calling user action here
        self.user_grammar.builtin_type(&builtin_type_0_built)?;
        self.push(ASTType::BuiltinType(builtin_type_0_built), context);
        Ok(())
    }

    /// Semantic action for production 83:
    ///
    /// BuiltinType: Bit;
    ///
    #[parol_runtime::function_name::named]
    fn builtin_type_1(
        &mut self,
        _bit: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bit = pop_item!(self, bit, Bit, context);
        let builtin_type_1_built = BuiltinType1Builder::default()
            .bit(Box::new(bit))
            .build()
            .into_diagnostic()?;
        let builtin_type_1_built = BuiltinType::BuiltinType1(builtin_type_1_built);
        // Calling user action here
        self.user_grammar.builtin_type(&builtin_type_1_built)?;
        self.push(ASTType::BuiltinType(builtin_type_1_built), context);
        Ok(())
    }

    /// Semantic action for production 84:
    ///
    /// Type: TypeGroup TypeList /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn r#type(
        &mut self,
        _type_group: &ParseTreeStackEntry<'t>,
        _type_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_list = pop_and_reverse_item!(self, type_list, TypeList, context);
        let type_group = pop_item!(self, type_group, TypeGroup, context);
        let r#type_built = TypeBuilder::default()
            .type_group(Box::new(type_group))
            .type_list(type_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.r#type(&r#type_built)?;
        self.push(ASTType::Type(r#type_built), context);
        Ok(())
    }

    /// Semantic action for production 85:
    ///
    /// TypeGroup: BuiltinType;
    ///
    #[parol_runtime::function_name::named]
    fn type_group_0(
        &mut self,
        _builtin_type: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let builtin_type = pop_item!(self, builtin_type, BuiltinType, context);
        let type_group_0_built = TypeGroup0Builder::default()
            .builtin_type(Box::new(builtin_type))
            .build()
            .into_diagnostic()?;
        let type_group_0_built = TypeGroup::TypeGroup0(type_group_0_built);
        self.push(ASTType::TypeGroup(type_group_0_built), context);
        Ok(())
    }

    /// Semantic action for production 86:
    ///
    /// TypeGroup: Identifier;
    ///
    #[parol_runtime::function_name::named]
    fn type_group_1(
        &mut self,
        _identifier: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let identifier = pop_item!(self, identifier, Identifier, context);
        let type_group_1_built = TypeGroup1Builder::default()
            .identifier(Box::new(identifier))
            .build()
            .into_diagnostic()?;
        let type_group_1_built = TypeGroup::TypeGroup1(type_group_1_built);
        self.push(ASTType::TypeGroup(type_group_1_built), context);
        Ok(())
    }

    /// Semantic action for production 87:
    ///
    /// TypeList /* Vec<T>::Push */: Width TypeList;
    ///
    #[parol_runtime::function_name::named]
    fn type_list_0(
        &mut self,
        _width: &ParseTreeStackEntry<'t>,
        _type_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut type_list = pop_item!(self, type_list, TypeList, context);
        let width = pop_item!(self, width, Width, context);
        let type_list_0_built = TypeListBuilder::default()
            .width(Box::new(width))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        type_list.push(type_list_0_built);
        self.push(ASTType::TypeList(type_list), context);
        Ok(())
    }

    /// Semantic action for production 88:
    ///
    /// TypeList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn type_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_list_1_built = Vec::new();
        self.push(ASTType::TypeList(type_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 89:
    ///
    /// WithParameter: Sharp LParen WithParameterOpt /* Option */ RParen;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter(
        &mut self,
        _sharp: &ParseTreeStackEntry<'t>,
        _l_paren: &ParseTreeStackEntry<'t>,
        _with_parameter_opt: &ParseTreeStackEntry<'t>,
        _r_paren: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren = pop_item!(self, r_paren, RParen, context);
        let with_parameter_opt = pop_item!(self, with_parameter_opt, WithParameterOpt, context);
        let l_paren = pop_item!(self, l_paren, LParen, context);
        let sharp = pop_item!(self, sharp, Sharp, context);
        let with_parameter_built = WithParameterBuilder::default()
            .sharp(Box::new(sharp))
            .l_paren(Box::new(l_paren))
            .with_parameter_opt(with_parameter_opt)
            .r_paren(Box::new(r_paren))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.with_parameter(&with_parameter_built)?;
        self.push(ASTType::WithParameter(with_parameter_built), context);
        Ok(())
    }

    /// Semantic action for production 90:
    ///
    /// WithParameterOpt /* Option<T>::Some */: WithParameterList;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_opt_0(
        &mut self,
        _with_parameter_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let with_parameter_list = pop_item!(self, with_parameter_list, WithParameterList, context);
        let with_parameter_opt_0_built = WithParameterOptBuilder::default()
            .with_parameter_list(Box::new(with_parameter_list))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::WithParameterOpt(Some(Box::new(with_parameter_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 91:
    ///
    /// WithParameterOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::WithParameterOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 92:
    ///
    /// WithParameterList: WithParameterItem WithParameterListList /* Vec */ WithParameterListOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_list(
        &mut self,
        _with_parameter_item: &ParseTreeStackEntry<'t>,
        _with_parameter_list_list: &ParseTreeStackEntry<'t>,
        _with_parameter_list_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let with_parameter_list_opt =
            pop_item!(self, with_parameter_list_opt, WithParameterListOpt, context);
        let with_parameter_list_list = pop_and_reverse_item!(
            self,
            with_parameter_list_list,
            WithParameterListList,
            context
        );
        let with_parameter_item = pop_item!(self, with_parameter_item, WithParameterItem, context);
        let with_parameter_list_built = WithParameterListBuilder::default()
            .with_parameter_item(Box::new(with_parameter_item))
            .with_parameter_list_list(with_parameter_list_list)
            .with_parameter_list_opt(with_parameter_list_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .with_parameter_list(&with_parameter_list_built)?;
        self.push(
            ASTType::WithParameterList(with_parameter_list_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 93:
    ///
    /// WithParameterListList /* Vec<T>::Push */: Comma WithParameterItem WithParameterListList;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_list_list_0(
        &mut self,
        _comma: &ParseTreeStackEntry<'t>,
        _with_parameter_item: &ParseTreeStackEntry<'t>,
        _with_parameter_list_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut with_parameter_list_list = pop_item!(
            self,
            with_parameter_list_list,
            WithParameterListList,
            context
        );
        let with_parameter_item = pop_item!(self, with_parameter_item, WithParameterItem, context);
        let comma = pop_item!(self, comma, Comma, context);
        let with_parameter_list_list_0_built = WithParameterListListBuilder::default()
            .with_parameter_item(Box::new(with_parameter_item))
            .comma(Box::new(comma))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        with_parameter_list_list.push(with_parameter_list_list_0_built);
        self.push(
            ASTType::WithParameterListList(with_parameter_list_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 94:
    ///
    /// WithParameterListList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_list_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let with_parameter_list_list_1_built = Vec::new();
        self.push(
            ASTType::WithParameterListList(with_parameter_list_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 95:
    ///
    /// WithParameterListOpt /* Option<T>::Some */: Comma;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_list_opt_0(
        &mut self,
        _comma: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = pop_item!(self, comma, Comma, context);
        let with_parameter_list_opt_0_built = WithParameterListOptBuilder::default()
            .comma(Box::new(comma))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::WithParameterListOpt(Some(Box::new(with_parameter_list_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 96:
    ///
    /// WithParameterListOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_list_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::WithParameterListOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 97:
    ///
    /// WithParameterItem: WithParameterItemGroup Identifier Colon Type Assignment Expression;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_item(
        &mut self,
        _with_parameter_item_group: &ParseTreeStackEntry<'t>,
        _identifier: &ParseTreeStackEntry<'t>,
        _colon: &ParseTreeStackEntry<'t>,
        _type: &ParseTreeStackEntry<'t>,
        _assignment: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = pop_item!(self, expression, Expression, context);
        let assignment = pop_item!(self, assignment, Assignment, context);
        let r#type = pop_item!(self, r#type, Type, context);
        let colon = pop_item!(self, colon, Colon, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let with_parameter_item_group = pop_item!(
            self,
            with_parameter_item_group,
            WithParameterItemGroup,
            context
        );
        let with_parameter_item_built = WithParameterItemBuilder::default()
            .with_parameter_item_group(Box::new(with_parameter_item_group))
            .identifier(Box::new(identifier))
            .colon(Box::new(colon))
            .r#type(Box::new(r#type))
            .assignment(Box::new(assignment))
            .expression(Box::new(expression))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .with_parameter_item(&with_parameter_item_built)?;
        self.push(
            ASTType::WithParameterItem(with_parameter_item_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 98:
    ///
    /// WithParameterItemGroup: Parameter;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_item_group_0(
        &mut self,
        _parameter: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let parameter = pop_item!(self, parameter, Parameter, context);
        let with_parameter_item_group_0_built = WithParameterItemGroup0Builder::default()
            .parameter(Box::new(parameter))
            .build()
            .into_diagnostic()?;
        let with_parameter_item_group_0_built =
            WithParameterItemGroup::WithParameterItemGroup0(with_parameter_item_group_0_built);
        self.push(
            ASTType::WithParameterItemGroup(with_parameter_item_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 99:
    ///
    /// WithParameterItemGroup: Localparam;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_item_group_1(
        &mut self,
        _localparam: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let localparam = pop_item!(self, localparam, Localparam, context);
        let with_parameter_item_group_1_built = WithParameterItemGroup1Builder::default()
            .localparam(Box::new(localparam))
            .build()
            .into_diagnostic()?;
        let with_parameter_item_group_1_built =
            WithParameterItemGroup::WithParameterItemGroup1(with_parameter_item_group_1_built);
        self.push(
            ASTType::WithParameterItemGroup(with_parameter_item_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 100:
    ///
    /// ModuleDeclaration: Module Identifier ModuleDeclarationOpt /* Option */ ModuleDeclarationOpt0 /* Option */ LBrace ModuleDeclarationList /* Vec */ RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn module_declaration(
        &mut self,
        _module: &ParseTreeStackEntry<'t>,
        _identifier: &ParseTreeStackEntry<'t>,
        _module_declaration_opt: &ParseTreeStackEntry<'t>,
        _module_declaration_opt0: &ParseTreeStackEntry<'t>,
        _l_brace: &ParseTreeStackEntry<'t>,
        _module_declaration_list: &ParseTreeStackEntry<'t>,
        _r_brace: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let module_declaration_list = pop_and_reverse_item!(
            self,
            module_declaration_list,
            ModuleDeclarationList,
            context
        );
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let module_declaration_opt0 = pop_item!(
            self,
            module_declaration_opt0,
            ModuleDeclarationOpt0,
            context
        );
        let module_declaration_opt =
            pop_item!(self, module_declaration_opt, ModuleDeclarationOpt, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let module = pop_item!(self, module, Module, context);
        let module_declaration_built = ModuleDeclarationBuilder::default()
            .module(Box::new(module))
            .identifier(Box::new(identifier))
            .module_declaration_opt(module_declaration_opt)
            .module_declaration_opt0(module_declaration_opt0)
            .l_brace(Box::new(l_brace))
            .module_declaration_list(module_declaration_list)
            .r_brace(Box::new(r_brace))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .module_declaration(&module_declaration_built)?;
        self.push(
            ASTType::ModuleDeclaration(module_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 101:
    ///
    /// ModuleDeclarationList /* Vec<T>::Push */: ModuleItem ModuleDeclarationList;
    ///
    #[parol_runtime::function_name::named]
    fn module_declaration_list_0(
        &mut self,
        _module_item: &ParseTreeStackEntry<'t>,
        _module_declaration_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut module_declaration_list = pop_item!(
            self,
            module_declaration_list,
            ModuleDeclarationList,
            context
        );
        let module_item = pop_item!(self, module_item, ModuleItem, context);
        let module_declaration_list_0_built = ModuleDeclarationListBuilder::default()
            .module_item(Box::new(module_item))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        module_declaration_list.push(module_declaration_list_0_built);
        self.push(
            ASTType::ModuleDeclarationList(module_declaration_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 102:
    ///
    /// ModuleDeclarationList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn module_declaration_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module_declaration_list_1_built = Vec::new();
        self.push(
            ASTType::ModuleDeclarationList(module_declaration_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 103:
    ///
    /// ModuleDeclarationOpt0 /* Option<T>::Some */: ModulePort;
    ///
    #[parol_runtime::function_name::named]
    fn module_declaration_opt0_0(
        &mut self,
        _module_port: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module_port = pop_item!(self, module_port, ModulePort, context);
        let module_declaration_opt0_0_built = ModuleDeclarationOpt0Builder::default()
            .module_port(Box::new(module_port))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::ModuleDeclarationOpt0(Some(Box::new(module_declaration_opt0_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 104:
    ///
    /// ModuleDeclarationOpt0 /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn module_declaration_opt0_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ModuleDeclarationOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 105:
    ///
    /// ModuleDeclarationOpt /* Option<T>::Some */: WithParameter;
    ///
    #[parol_runtime::function_name::named]
    fn module_declaration_opt_0(
        &mut self,
        _with_parameter: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let with_parameter = pop_item!(self, with_parameter, WithParameter, context);
        let module_declaration_opt_0_built = ModuleDeclarationOptBuilder::default()
            .with_parameter(Box::new(with_parameter))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::ModuleDeclarationOpt(Some(Box::new(module_declaration_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 106:
    ///
    /// ModuleDeclarationOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn module_declaration_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ModuleDeclarationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 107:
    ///
    /// ModulePort: LParen ModulePortOpt /* Option */ RParen;
    ///
    #[parol_runtime::function_name::named]
    fn module_port(
        &mut self,
        _l_paren: &ParseTreeStackEntry<'t>,
        _module_port_opt: &ParseTreeStackEntry<'t>,
        _r_paren: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren = pop_item!(self, r_paren, RParen, context);
        let module_port_opt = pop_item!(self, module_port_opt, ModulePortOpt, context);
        let l_paren = pop_item!(self, l_paren, LParen, context);
        let module_port_built = ModulePortBuilder::default()
            .l_paren(Box::new(l_paren))
            .module_port_opt(module_port_opt)
            .r_paren(Box::new(r_paren))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.module_port(&module_port_built)?;
        self.push(ASTType::ModulePort(module_port_built), context);
        Ok(())
    }

    /// Semantic action for production 108:
    ///
    /// ModulePortOpt /* Option<T>::Some */: ModulePortList;
    ///
    #[parol_runtime::function_name::named]
    fn module_port_opt_0(
        &mut self,
        _module_port_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module_port_list = pop_item!(self, module_port_list, ModulePortList, context);
        let module_port_opt_0_built = ModulePortOptBuilder::default()
            .module_port_list(Box::new(module_port_list))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::ModulePortOpt(Some(Box::new(module_port_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 109:
    ///
    /// ModulePortOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn module_port_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ModulePortOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 110:
    ///
    /// ModulePortList: ModulePortItem ModulePortListList /* Vec */ ModulePortListOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn module_port_list(
        &mut self,
        _module_port_item: &ParseTreeStackEntry<'t>,
        _module_port_list_list: &ParseTreeStackEntry<'t>,
        _module_port_list_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module_port_list_opt =
            pop_item!(self, module_port_list_opt, ModulePortListOpt, context);
        let module_port_list_list =
            pop_and_reverse_item!(self, module_port_list_list, ModulePortListList, context);
        let module_port_item = pop_item!(self, module_port_item, ModulePortItem, context);
        let module_port_list_built = ModulePortListBuilder::default()
            .module_port_item(Box::new(module_port_item))
            .module_port_list_list(module_port_list_list)
            .module_port_list_opt(module_port_list_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .module_port_list(&module_port_list_built)?;
        self.push(ASTType::ModulePortList(module_port_list_built), context);
        Ok(())
    }

    /// Semantic action for production 111:
    ///
    /// ModulePortListList /* Vec<T>::Push */: Comma ModulePortItem ModulePortListList;
    ///
    #[parol_runtime::function_name::named]
    fn module_port_list_list_0(
        &mut self,
        _comma: &ParseTreeStackEntry<'t>,
        _module_port_item: &ParseTreeStackEntry<'t>,
        _module_port_list_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut module_port_list_list =
            pop_item!(self, module_port_list_list, ModulePortListList, context);
        let module_port_item = pop_item!(self, module_port_item, ModulePortItem, context);
        let comma = pop_item!(self, comma, Comma, context);
        let module_port_list_list_0_built = ModulePortListListBuilder::default()
            .module_port_item(Box::new(module_port_item))
            .comma(Box::new(comma))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        module_port_list_list.push(module_port_list_list_0_built);
        self.push(ASTType::ModulePortListList(module_port_list_list), context);
        Ok(())
    }

    /// Semantic action for production 112:
    ///
    /// ModulePortListList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn module_port_list_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module_port_list_list_1_built = Vec::new();
        self.push(
            ASTType::ModulePortListList(module_port_list_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 113:
    ///
    /// ModulePortListOpt /* Option<T>::Some */: Comma;
    ///
    #[parol_runtime::function_name::named]
    fn module_port_list_opt_0(
        &mut self,
        _comma: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = pop_item!(self, comma, Comma, context);
        let module_port_list_opt_0_built = ModulePortListOptBuilder::default()
            .comma(Box::new(comma))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::ModulePortListOpt(Some(Box::new(module_port_list_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 114:
    ///
    /// ModulePortListOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn module_port_list_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ModulePortListOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 115:
    ///
    /// ModulePortItem: Identifier Colon Direction Type;
    ///
    #[parol_runtime::function_name::named]
    fn module_port_item(
        &mut self,
        _identifier: &ParseTreeStackEntry<'t>,
        _colon: &ParseTreeStackEntry<'t>,
        _direction: &ParseTreeStackEntry<'t>,
        _type: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#type = pop_item!(self, r#type, Type, context);
        let direction = pop_item!(self, direction, Direction, context);
        let colon = pop_item!(self, colon, Colon, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let module_port_item_built = ModulePortItemBuilder::default()
            .identifier(Box::new(identifier))
            .colon(Box::new(colon))
            .direction(Box::new(direction))
            .r#type(Box::new(r#type))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .module_port_item(&module_port_item_built)?;
        self.push(ASTType::ModulePortItem(module_port_item_built), context);
        Ok(())
    }

    /// Semantic action for production 116:
    ///
    /// Direction: Input;
    ///
    #[parol_runtime::function_name::named]
    fn direction_0(
        &mut self,
        _input: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let input = pop_item!(self, input, Input, context);
        let direction_0_built = Direction0Builder::default()
            .input(Box::new(input))
            .build()
            .into_diagnostic()?;
        let direction_0_built = Direction::Direction0(direction_0_built);
        // Calling user action here
        self.user_grammar.direction(&direction_0_built)?;
        self.push(ASTType::Direction(direction_0_built), context);
        Ok(())
    }

    /// Semantic action for production 117:
    ///
    /// Direction: Output;
    ///
    #[parol_runtime::function_name::named]
    fn direction_1(
        &mut self,
        _output: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let output = pop_item!(self, output, Output, context);
        let direction_1_built = Direction1Builder::default()
            .output(Box::new(output))
            .build()
            .into_diagnostic()?;
        let direction_1_built = Direction::Direction1(direction_1_built);
        // Calling user action here
        self.user_grammar.direction(&direction_1_built)?;
        self.push(ASTType::Direction(direction_1_built), context);
        Ok(())
    }

    /// Semantic action for production 118:
    ///
    /// Direction: Inout;
    ///
    #[parol_runtime::function_name::named]
    fn direction_2(
        &mut self,
        _inout: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inout = pop_item!(self, inout, Inout, context);
        let direction_2_built = Direction2Builder::default()
            .inout(Box::new(inout))
            .build()
            .into_diagnostic()?;
        let direction_2_built = Direction::Direction2(direction_2_built);
        // Calling user action here
        self.user_grammar.direction(&direction_2_built)?;
        self.push(ASTType::Direction(direction_2_built), context);
        Ok(())
    }

    /// Semantic action for production 119:
    ///
    /// ModuleItem: VariableDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn module_item_0(
        &mut self,
        _variable_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let variable_declaration =
            pop_item!(self, variable_declaration, VariableDeclaration, context);
        let module_item_0_built = ModuleItem0Builder::default()
            .variable_declaration(Box::new(variable_declaration))
            .build()
            .into_diagnostic()?;
        let module_item_0_built = ModuleItem::ModuleItem0(module_item_0_built);
        // Calling user action here
        self.user_grammar.module_item(&module_item_0_built)?;
        self.push(ASTType::ModuleItem(module_item_0_built), context);
        Ok(())
    }

    /// Semantic action for production 120:
    ///
    /// ModuleItem: ParameterDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn module_item_1(
        &mut self,
        _parameter_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let parameter_declaration =
            pop_item!(self, parameter_declaration, ParameterDeclaration, context);
        let module_item_1_built = ModuleItem1Builder::default()
            .parameter_declaration(Box::new(parameter_declaration))
            .build()
            .into_diagnostic()?;
        let module_item_1_built = ModuleItem::ModuleItem1(module_item_1_built);
        // Calling user action here
        self.user_grammar.module_item(&module_item_1_built)?;
        self.push(ASTType::ModuleItem(module_item_1_built), context);
        Ok(())
    }

    /// Semantic action for production 121:
    ///
    /// ModuleItem: LocalparamDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn module_item_2(
        &mut self,
        _localparam_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let localparam_declaration =
            pop_item!(self, localparam_declaration, LocalparamDeclaration, context);
        let module_item_2_built = ModuleItem2Builder::default()
            .localparam_declaration(Box::new(localparam_declaration))
            .build()
            .into_diagnostic()?;
        let module_item_2_built = ModuleItem::ModuleItem2(module_item_2_built);
        // Calling user action here
        self.user_grammar.module_item(&module_item_2_built)?;
        self.push(ASTType::ModuleItem(module_item_2_built), context);
        Ok(())
    }

    /// Semantic action for production 122:
    ///
    /// ModuleItem: AlwaysFFDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn module_item_3(
        &mut self,
        _always_f_f_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let always_f_f_declaration =
            pop_item!(self, always_f_f_declaration, AlwaysFFDeclaration, context);
        let module_item_3_built = ModuleItem3Builder::default()
            .always_f_f_declaration(Box::new(always_f_f_declaration))
            .build()
            .into_diagnostic()?;
        let module_item_3_built = ModuleItem::ModuleItem3(module_item_3_built);
        // Calling user action here
        self.user_grammar.module_item(&module_item_3_built)?;
        self.push(ASTType::ModuleItem(module_item_3_built), context);
        Ok(())
    }

    /// Semantic action for production 123:
    ///
    /// ModuleItem: AlwaysCombDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn module_item_4(
        &mut self,
        _always_comb_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let always_comb_declaration = pop_item!(
            self,
            always_comb_declaration,
            AlwaysCombDeclaration,
            context
        );
        let module_item_4_built = ModuleItem4Builder::default()
            .always_comb_declaration(Box::new(always_comb_declaration))
            .build()
            .into_diagnostic()?;
        let module_item_4_built = ModuleItem::ModuleItem4(module_item_4_built);
        // Calling user action here
        self.user_grammar.module_item(&module_item_4_built)?;
        self.push(ASTType::ModuleItem(module_item_4_built), context);
        Ok(())
    }

    /// Semantic action for production 124:
    ///
    /// InterfaceDeclaration: Interface Identifier InterfaceDeclarationOpt /* Option */ LBrace InterfaceDeclarationList /* Vec */ RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn interface_declaration(
        &mut self,
        _interface: &ParseTreeStackEntry<'t>,
        _identifier: &ParseTreeStackEntry<'t>,
        _interface_declaration_opt: &ParseTreeStackEntry<'t>,
        _l_brace: &ParseTreeStackEntry<'t>,
        _interface_declaration_list: &ParseTreeStackEntry<'t>,
        _r_brace: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let interface_declaration_list = pop_and_reverse_item!(
            self,
            interface_declaration_list,
            InterfaceDeclarationList,
            context
        );
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let interface_declaration_opt = pop_item!(
            self,
            interface_declaration_opt,
            InterfaceDeclarationOpt,
            context
        );
        let identifier = pop_item!(self, identifier, Identifier, context);
        let interface = pop_item!(self, interface, Interface, context);
        let interface_declaration_built = InterfaceDeclarationBuilder::default()
            .interface(Box::new(interface))
            .identifier(Box::new(identifier))
            .interface_declaration_opt(interface_declaration_opt)
            .l_brace(Box::new(l_brace))
            .interface_declaration_list(interface_declaration_list)
            .r_brace(Box::new(r_brace))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .interface_declaration(&interface_declaration_built)?;
        self.push(
            ASTType::InterfaceDeclaration(interface_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 125:
    ///
    /// InterfaceDeclarationList /* Vec<T>::Push */: InterfaceItem InterfaceDeclarationList;
    ///
    #[parol_runtime::function_name::named]
    fn interface_declaration_list_0(
        &mut self,
        _interface_item: &ParseTreeStackEntry<'t>,
        _interface_declaration_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut interface_declaration_list = pop_item!(
            self,
            interface_declaration_list,
            InterfaceDeclarationList,
            context
        );
        let interface_item = pop_item!(self, interface_item, InterfaceItem, context);
        let interface_declaration_list_0_built = InterfaceDeclarationListBuilder::default()
            .interface_item(Box::new(interface_item))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        interface_declaration_list.push(interface_declaration_list_0_built);
        self.push(
            ASTType::InterfaceDeclarationList(interface_declaration_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 126:
    ///
    /// InterfaceDeclarationList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn interface_declaration_list_1(
        &mut self,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let interface_declaration_list_1_built = Vec::new();
        self.push(
            ASTType::InterfaceDeclarationList(interface_declaration_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 127:
    ///
    /// InterfaceDeclarationOpt /* Option<T>::Some */: WithParameter;
    ///
    #[parol_runtime::function_name::named]
    fn interface_declaration_opt_0(
        &mut self,
        _with_parameter: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let with_parameter = pop_item!(self, with_parameter, WithParameter, context);
        let interface_declaration_opt_0_built = InterfaceDeclarationOptBuilder::default()
            .with_parameter(Box::new(with_parameter))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::InterfaceDeclarationOpt(Some(Box::new(interface_declaration_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 128:
    ///
    /// InterfaceDeclarationOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn interface_declaration_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::InterfaceDeclarationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 129:
    ///
    /// InterfaceItem: VariableDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn interface_item_0(
        &mut self,
        _variable_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let variable_declaration =
            pop_item!(self, variable_declaration, VariableDeclaration, context);
        let interface_item_0_built = InterfaceItem0Builder::default()
            .variable_declaration(Box::new(variable_declaration))
            .build()
            .into_diagnostic()?;
        let interface_item_0_built = InterfaceItem::InterfaceItem0(interface_item_0_built);
        // Calling user action here
        self.user_grammar.interface_item(&interface_item_0_built)?;
        self.push(ASTType::InterfaceItem(interface_item_0_built), context);
        Ok(())
    }

    /// Semantic action for production 130:
    ///
    /// InterfaceItem: ParameterDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn interface_item_1(
        &mut self,
        _parameter_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let parameter_declaration =
            pop_item!(self, parameter_declaration, ParameterDeclaration, context);
        let interface_item_1_built = InterfaceItem1Builder::default()
            .parameter_declaration(Box::new(parameter_declaration))
            .build()
            .into_diagnostic()?;
        let interface_item_1_built = InterfaceItem::InterfaceItem1(interface_item_1_built);
        // Calling user action here
        self.user_grammar.interface_item(&interface_item_1_built)?;
        self.push(ASTType::InterfaceItem(interface_item_1_built), context);
        Ok(())
    }

    /// Semantic action for production 131:
    ///
    /// InterfaceItem: LocalparamDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn interface_item_2(
        &mut self,
        _localparam_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let localparam_declaration =
            pop_item!(self, localparam_declaration, LocalparamDeclaration, context);
        let interface_item_2_built = InterfaceItem2Builder::default()
            .localparam_declaration(Box::new(localparam_declaration))
            .build()
            .into_diagnostic()?;
        let interface_item_2_built = InterfaceItem::InterfaceItem2(interface_item_2_built);
        // Calling user action here
        self.user_grammar.interface_item(&interface_item_2_built)?;
        self.push(ASTType::InterfaceItem(interface_item_2_built), context);
        Ok(())
    }

    /// Semantic action for production 132:
    ///
    /// InterfaceItem: ModportDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn interface_item_3(
        &mut self,
        _modport_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let modport_declaration = pop_item!(self, modport_declaration, ModportDeclaration, context);
        let interface_item_3_built = InterfaceItem3Builder::default()
            .modport_declaration(Box::new(modport_declaration))
            .build()
            .into_diagnostic()?;
        let interface_item_3_built = InterfaceItem::InterfaceItem3(interface_item_3_built);
        // Calling user action here
        self.user_grammar.interface_item(&interface_item_3_built)?;
        self.push(ASTType::InterfaceItem(interface_item_3_built), context);
        Ok(())
    }

    /// Semantic action for production 133:
    ///
    /// VariableDeclaration: Identifier Colon Type SemiColon;
    ///
    #[parol_runtime::function_name::named]
    fn variable_declaration(
        &mut self,
        _identifier: &ParseTreeStackEntry<'t>,
        _colon: &ParseTreeStackEntry<'t>,
        _type: &ParseTreeStackEntry<'t>,
        _semi_colon: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semi_colon = pop_item!(self, semi_colon, SemiColon, context);
        let r#type = pop_item!(self, r#type, Type, context);
        let colon = pop_item!(self, colon, Colon, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let variable_declaration_built = VariableDeclarationBuilder::default()
            .identifier(Box::new(identifier))
            .colon(Box::new(colon))
            .r#type(Box::new(r#type))
            .semi_colon(Box::new(semi_colon))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .variable_declaration(&variable_declaration_built)?;
        self.push(
            ASTType::VariableDeclaration(variable_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 134:
    ///
    /// ParameterDeclaration: Parameter Identifier Colon Type Assignment Expression SemiColon;
    ///
    #[parol_runtime::function_name::named]
    fn parameter_declaration(
        &mut self,
        _parameter: &ParseTreeStackEntry<'t>,
        _identifier: &ParseTreeStackEntry<'t>,
        _colon: &ParseTreeStackEntry<'t>,
        _type: &ParseTreeStackEntry<'t>,
        _assignment: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _semi_colon: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semi_colon = pop_item!(self, semi_colon, SemiColon, context);
        let expression = pop_item!(self, expression, Expression, context);
        let assignment = pop_item!(self, assignment, Assignment, context);
        let r#type = pop_item!(self, r#type, Type, context);
        let colon = pop_item!(self, colon, Colon, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let parameter = pop_item!(self, parameter, Parameter, context);
        let parameter_declaration_built = ParameterDeclarationBuilder::default()
            .parameter(Box::new(parameter))
            .identifier(Box::new(identifier))
            .colon(Box::new(colon))
            .r#type(Box::new(r#type))
            .assignment(Box::new(assignment))
            .expression(Box::new(expression))
            .semi_colon(Box::new(semi_colon))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .parameter_declaration(&parameter_declaration_built)?;
        self.push(
            ASTType::ParameterDeclaration(parameter_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 135:
    ///
    /// LocalparamDeclaration: Localparam Identifier Colon Type Assignment Expression SemiColon;
    ///
    #[parol_runtime::function_name::named]
    fn localparam_declaration(
        &mut self,
        _localparam: &ParseTreeStackEntry<'t>,
        _identifier: &ParseTreeStackEntry<'t>,
        _colon: &ParseTreeStackEntry<'t>,
        _type: &ParseTreeStackEntry<'t>,
        _assignment: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _semi_colon: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semi_colon = pop_item!(self, semi_colon, SemiColon, context);
        let expression = pop_item!(self, expression, Expression, context);
        let assignment = pop_item!(self, assignment, Assignment, context);
        let r#type = pop_item!(self, r#type, Type, context);
        let colon = pop_item!(self, colon, Colon, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let localparam = pop_item!(self, localparam, Localparam, context);
        let localparam_declaration_built = LocalparamDeclarationBuilder::default()
            .localparam(Box::new(localparam))
            .identifier(Box::new(identifier))
            .colon(Box::new(colon))
            .r#type(Box::new(r#type))
            .assignment(Box::new(assignment))
            .expression(Box::new(expression))
            .semi_colon(Box::new(semi_colon))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .localparam_declaration(&localparam_declaration_built)?;
        self.push(
            ASTType::LocalparamDeclaration(localparam_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 136:
    ///
    /// AlwaysFFDeclaration: AlwaysFF LParen AlwaysFFConditions RParen LBrace AlwaysFFDeclarationList /* Vec */ RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn always_f_f_declaration(
        &mut self,
        _always_f_f: &ParseTreeStackEntry<'t>,
        _l_paren: &ParseTreeStackEntry<'t>,
        _always_f_f_conditions: &ParseTreeStackEntry<'t>,
        _r_paren: &ParseTreeStackEntry<'t>,
        _l_brace: &ParseTreeStackEntry<'t>,
        _always_f_f_declaration_list: &ParseTreeStackEntry<'t>,
        _r_brace: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let always_f_f_declaration_list = pop_and_reverse_item!(
            self,
            always_f_f_declaration_list,
            AlwaysFFDeclarationList,
            context
        );
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let r_paren = pop_item!(self, r_paren, RParen, context);
        let always_f_f_conditions =
            pop_item!(self, always_f_f_conditions, AlwaysFFConditions, context);
        let l_paren = pop_item!(self, l_paren, LParen, context);
        let always_f_f = pop_item!(self, always_f_f, AlwaysFF, context);
        let always_f_f_declaration_built = AlwaysFFDeclarationBuilder::default()
            .always_f_f(Box::new(always_f_f))
            .l_paren(Box::new(l_paren))
            .always_f_f_conditions(Box::new(always_f_f_conditions))
            .r_paren(Box::new(r_paren))
            .l_brace(Box::new(l_brace))
            .always_f_f_declaration_list(always_f_f_declaration_list)
            .r_brace(Box::new(r_brace))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .always_f_f_declaration(&always_f_f_declaration_built)?;
        self.push(
            ASTType::AlwaysFFDeclaration(always_f_f_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 137:
    ///
    /// AlwaysFFDeclarationList /* Vec<T>::Push */: Statement AlwaysFFDeclarationList;
    ///
    #[parol_runtime::function_name::named]
    fn always_f_f_declaration_list_0(
        &mut self,
        _statement: &ParseTreeStackEntry<'t>,
        _always_f_f_declaration_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut always_f_f_declaration_list = pop_item!(
            self,
            always_f_f_declaration_list,
            AlwaysFFDeclarationList,
            context
        );
        let statement = pop_item!(self, statement, Statement, context);
        let always_f_f_declaration_list_0_built = AlwaysFFDeclarationListBuilder::default()
            .statement(Box::new(statement))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        always_f_f_declaration_list.push(always_f_f_declaration_list_0_built);
        self.push(
            ASTType::AlwaysFFDeclarationList(always_f_f_declaration_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 138:
    ///
    /// AlwaysFFDeclarationList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn always_f_f_declaration_list_1(
        &mut self,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let always_f_f_declaration_list_1_built = Vec::new();
        self.push(
            ASTType::AlwaysFFDeclarationList(always_f_f_declaration_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 139:
    ///
    /// AlwaysFFConditions: AlwaysFFCondition AlwaysFFConditionsList /* Vec */ AlwaysFFConditionsOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn always_f_f_conditions(
        &mut self,
        _always_f_f_condition: &ParseTreeStackEntry<'t>,
        _always_f_f_conditions_list: &ParseTreeStackEntry<'t>,
        _always_f_f_conditions_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let always_f_f_conditions_opt = pop_item!(
            self,
            always_f_f_conditions_opt,
            AlwaysFFConditionsOpt,
            context
        );
        let always_f_f_conditions_list = pop_and_reverse_item!(
            self,
            always_f_f_conditions_list,
            AlwaysFFConditionsList,
            context
        );
        let always_f_f_condition =
            pop_item!(self, always_f_f_condition, AlwaysFFCondition, context);
        let always_f_f_conditions_built = AlwaysFFConditionsBuilder::default()
            .always_f_f_condition(Box::new(always_f_f_condition))
            .always_f_f_conditions_list(always_f_f_conditions_list)
            .always_f_f_conditions_opt(always_f_f_conditions_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .always_f_f_conditions(&always_f_f_conditions_built)?;
        self.push(
            ASTType::AlwaysFFConditions(always_f_f_conditions_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 140:
    ///
    /// AlwaysFFConditionsList /* Vec<T>::Push */: Comma AlwaysFFCondition AlwaysFFConditionsList;
    ///
    #[parol_runtime::function_name::named]
    fn always_f_f_conditions_list_0(
        &mut self,
        _comma: &ParseTreeStackEntry<'t>,
        _always_f_f_condition: &ParseTreeStackEntry<'t>,
        _always_f_f_conditions_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut always_f_f_conditions_list = pop_item!(
            self,
            always_f_f_conditions_list,
            AlwaysFFConditionsList,
            context
        );
        let always_f_f_condition =
            pop_item!(self, always_f_f_condition, AlwaysFFCondition, context);
        let comma = pop_item!(self, comma, Comma, context);
        let always_f_f_conditions_list_0_built = AlwaysFFConditionsListBuilder::default()
            .always_f_f_condition(Box::new(always_f_f_condition))
            .comma(Box::new(comma))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        always_f_f_conditions_list.push(always_f_f_conditions_list_0_built);
        self.push(
            ASTType::AlwaysFFConditionsList(always_f_f_conditions_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 141:
    ///
    /// AlwaysFFConditionsList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn always_f_f_conditions_list_1(
        &mut self,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let always_f_f_conditions_list_1_built = Vec::new();
        self.push(
            ASTType::AlwaysFFConditionsList(always_f_f_conditions_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 142:
    ///
    /// AlwaysFFConditionsOpt /* Option<T>::Some */: Comma;
    ///
    #[parol_runtime::function_name::named]
    fn always_f_f_conditions_opt_0(
        &mut self,
        _comma: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = pop_item!(self, comma, Comma, context);
        let always_f_f_conditions_opt_0_built = AlwaysFFConditionsOptBuilder::default()
            .comma(Box::new(comma))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::AlwaysFFConditionsOpt(Some(Box::new(always_f_f_conditions_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 143:
    ///
    /// AlwaysFFConditionsOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn always_f_f_conditions_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::AlwaysFFConditionsOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 144:
    ///
    /// AlwaysFFCondition: AlwaysFFConditionGroup Identifier;
    ///
    #[parol_runtime::function_name::named]
    fn always_f_f_condition(
        &mut self,
        _always_f_f_condition_group: &ParseTreeStackEntry<'t>,
        _identifier: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let identifier = pop_item!(self, identifier, Identifier, context);
        let always_f_f_condition_group = pop_item!(
            self,
            always_f_f_condition_group,
            AlwaysFFConditionGroup,
            context
        );
        let always_f_f_condition_built = AlwaysFFConditionBuilder::default()
            .always_f_f_condition_group(Box::new(always_f_f_condition_group))
            .identifier(Box::new(identifier))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .always_f_f_condition(&always_f_f_condition_built)?;
        self.push(
            ASTType::AlwaysFFCondition(always_f_f_condition_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 145:
    ///
    /// AlwaysFFConditionGroup: Posedge;
    ///
    #[parol_runtime::function_name::named]
    fn always_f_f_condition_group_0(
        &mut self,
        _posedge: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let posedge = pop_item!(self, posedge, Posedge, context);
        let always_f_f_condition_group_0_built = AlwaysFFConditionGroup0Builder::default()
            .posedge(Box::new(posedge))
            .build()
            .into_diagnostic()?;
        let always_f_f_condition_group_0_built =
            AlwaysFFConditionGroup::AlwaysFFConditionGroup0(always_f_f_condition_group_0_built);
        self.push(
            ASTType::AlwaysFFConditionGroup(always_f_f_condition_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 146:
    ///
    /// AlwaysFFConditionGroup: Negedge;
    ///
    #[parol_runtime::function_name::named]
    fn always_f_f_condition_group_1(
        &mut self,
        _negedge: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let negedge = pop_item!(self, negedge, Negedge, context);
        let always_f_f_condition_group_1_built = AlwaysFFConditionGroup1Builder::default()
            .negedge(Box::new(negedge))
            .build()
            .into_diagnostic()?;
        let always_f_f_condition_group_1_built =
            AlwaysFFConditionGroup::AlwaysFFConditionGroup1(always_f_f_condition_group_1_built);
        self.push(
            ASTType::AlwaysFFConditionGroup(always_f_f_condition_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 147:
    ///
    /// AlwaysCombDeclaration: AlwaysComb LBrace AlwaysCombDeclarationList /* Vec */ RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn always_comb_declaration(
        &mut self,
        _always_comb: &ParseTreeStackEntry<'t>,
        _l_brace: &ParseTreeStackEntry<'t>,
        _always_comb_declaration_list: &ParseTreeStackEntry<'t>,
        _r_brace: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let always_comb_declaration_list = pop_and_reverse_item!(
            self,
            always_comb_declaration_list,
            AlwaysCombDeclarationList,
            context
        );
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let always_comb = pop_item!(self, always_comb, AlwaysComb, context);
        let always_comb_declaration_built = AlwaysCombDeclarationBuilder::default()
            .always_comb(Box::new(always_comb))
            .l_brace(Box::new(l_brace))
            .always_comb_declaration_list(always_comb_declaration_list)
            .r_brace(Box::new(r_brace))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .always_comb_declaration(&always_comb_declaration_built)?;
        self.push(
            ASTType::AlwaysCombDeclaration(always_comb_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 148:
    ///
    /// AlwaysCombDeclarationList /* Vec<T>::Push */: Statement AlwaysCombDeclarationList;
    ///
    #[parol_runtime::function_name::named]
    fn always_comb_declaration_list_0(
        &mut self,
        _statement: &ParseTreeStackEntry<'t>,
        _always_comb_declaration_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut always_comb_declaration_list = pop_item!(
            self,
            always_comb_declaration_list,
            AlwaysCombDeclarationList,
            context
        );
        let statement = pop_item!(self, statement, Statement, context);
        let always_comb_declaration_list_0_built = AlwaysCombDeclarationListBuilder::default()
            .statement(Box::new(statement))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        always_comb_declaration_list.push(always_comb_declaration_list_0_built);
        self.push(
            ASTType::AlwaysCombDeclarationList(always_comb_declaration_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 149:
    ///
    /// AlwaysCombDeclarationList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn always_comb_declaration_list_1(
        &mut self,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let always_comb_declaration_list_1_built = Vec::new();
        self.push(
            ASTType::AlwaysCombDeclarationList(always_comb_declaration_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 150:
    ///
    /// ModportDeclaration: Modport Identifier LBrace ModportList RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn modport_declaration(
        &mut self,
        _modport: &ParseTreeStackEntry<'t>,
        _identifier: &ParseTreeStackEntry<'t>,
        _l_brace: &ParseTreeStackEntry<'t>,
        _modport_list: &ParseTreeStackEntry<'t>,
        _r_brace: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let modport_list = pop_item!(self, modport_list, ModportList, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let modport = pop_item!(self, modport, Modport, context);
        let modport_declaration_built = ModportDeclarationBuilder::default()
            .modport(Box::new(modport))
            .identifier(Box::new(identifier))
            .l_brace(Box::new(l_brace))
            .modport_list(Box::new(modport_list))
            .r_brace(Box::new(r_brace))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .modport_declaration(&modport_declaration_built)?;
        self.push(
            ASTType::ModportDeclaration(modport_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 151:
    ///
    /// ModportList: ModportItem ModportListList /* Vec */ ModportListOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn modport_list(
        &mut self,
        _modport_item: &ParseTreeStackEntry<'t>,
        _modport_list_list: &ParseTreeStackEntry<'t>,
        _modport_list_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let modport_list_opt = pop_item!(self, modport_list_opt, ModportListOpt, context);
        let modport_list_list =
            pop_and_reverse_item!(self, modport_list_list, ModportListList, context);
        let modport_item = pop_item!(self, modport_item, ModportItem, context);
        let modport_list_built = ModportListBuilder::default()
            .modport_item(Box::new(modport_item))
            .modport_list_list(modport_list_list)
            .modport_list_opt(modport_list_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.modport_list(&modport_list_built)?;
        self.push(ASTType::ModportList(modport_list_built), context);
        Ok(())
    }

    /// Semantic action for production 152:
    ///
    /// ModportListList /* Vec<T>::Push */: Comma ModportItem ModportListList;
    ///
    #[parol_runtime::function_name::named]
    fn modport_list_list_0(
        &mut self,
        _comma: &ParseTreeStackEntry<'t>,
        _modport_item: &ParseTreeStackEntry<'t>,
        _modport_list_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut modport_list_list = pop_item!(self, modport_list_list, ModportListList, context);
        let modport_item = pop_item!(self, modport_item, ModportItem, context);
        let comma = pop_item!(self, comma, Comma, context);
        let modport_list_list_0_built = ModportListListBuilder::default()
            .modport_item(Box::new(modport_item))
            .comma(Box::new(comma))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        modport_list_list.push(modport_list_list_0_built);
        self.push(ASTType::ModportListList(modport_list_list), context);
        Ok(())
    }

    /// Semantic action for production 153:
    ///
    /// ModportListList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn modport_list_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let modport_list_list_1_built = Vec::new();
        self.push(ASTType::ModportListList(modport_list_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 154:
    ///
    /// ModportListOpt /* Option<T>::Some */: Comma;
    ///
    #[parol_runtime::function_name::named]
    fn modport_list_opt_0(
        &mut self,
        _comma: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = pop_item!(self, comma, Comma, context);
        let modport_list_opt_0_built = ModportListOptBuilder::default()
            .comma(Box::new(comma))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::ModportListOpt(Some(Box::new(modport_list_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 155:
    ///
    /// ModportListOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn modport_list_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ModportListOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 156:
    ///
    /// ModportItem: Identifier Colon Direction;
    ///
    #[parol_runtime::function_name::named]
    fn modport_item(
        &mut self,
        _identifier: &ParseTreeStackEntry<'t>,
        _colon: &ParseTreeStackEntry<'t>,
        _direction: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let direction = pop_item!(self, direction, Direction, context);
        let colon = pop_item!(self, colon, Colon, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let modport_item_built = ModportItemBuilder::default()
            .identifier(Box::new(identifier))
            .colon(Box::new(colon))
            .direction(Box::new(direction))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.modport_item(&modport_item_built)?;
        self.push(ASTType::ModportItem(modport_item_built), context);
        Ok(())
    }
}

impl<'t> UserActionsTrait<'t> for VerylGrammarAuto<'t, '_> {
    ///
    /// This function is implemented automatically for the user's item VerylGrammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeStackEntry<'t>],
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        match prod_num {
            0 => self.based_binary(&children[0], parse_tree),
            1 => self.based_octal(&children[0], parse_tree),
            2 => self.based_decimal(&children[0], parse_tree),
            3 => self.based_hex(&children[0], parse_tree),
            4 => self.base_less(&children[0], parse_tree),
            5 => self.plus(&children[0], parse_tree),
            6 => self.minus(&children[0], parse_tree),
            7 => self.mul(&children[0], parse_tree),
            8 => self.div(&children[0], parse_tree),
            9 => self.colon(&children[0], parse_tree),
            10 => self.semi_colon(&children[0], parse_tree),
            11 => self.comma(&children[0], parse_tree),
            12 => self.l_paren(&children[0], parse_tree),
            13 => self.r_paren(&children[0], parse_tree),
            14 => self.l_bracket(&children[0], parse_tree),
            15 => self.r_bracket(&children[0], parse_tree),
            16 => self.l_brace(&children[0], parse_tree),
            17 => self.r_brace(&children[0], parse_tree),
            18 => self.assignment(&children[0], parse_tree),
            19 => self.sharp(&children[0], parse_tree),
            20 => self.logic(&children[0], parse_tree),
            21 => self.bit(&children[0], parse_tree),
            22 => self.always_f_f(&children[0], parse_tree),
            23 => self.always_comb(&children[0], parse_tree),
            24 => self.posedge(&children[0], parse_tree),
            25 => self.negedge(&children[0], parse_tree),
            26 => self.r#if(&children[0], parse_tree),
            27 => self.r#else(&children[0], parse_tree),
            28 => self.parameter(&children[0], parse_tree),
            29 => self.localparam(&children[0], parse_tree),
            30 => self.module(&children[0], parse_tree),
            31 => self.interface(&children[0], parse_tree),
            32 => self.input(&children[0], parse_tree),
            33 => self.output(&children[0], parse_tree),
            34 => self.inout(&children[0], parse_tree),
            35 => self.modport(&children[0], parse_tree),
            36 => self.identifier(&children[0], parse_tree),
            37 => self.veryl(&children[0], parse_tree),
            38 => self.veryl_list_0(&children[0], &children[1], parse_tree),
            39 => self.veryl_list_1(parse_tree),
            40 => self.description_0(&children[0], parse_tree),
            41 => self.description_1(&children[0], parse_tree),
            42 => self.number(&children[0], parse_tree),
            43 => self.integral_number_0(&children[0], parse_tree),
            44 => self.integral_number_1(&children[0], parse_tree),
            45 => self.integral_number_2(&children[0], parse_tree),
            46 => self.integral_number_3(&children[0], parse_tree),
            47 => self.integral_number_4(&children[0], parse_tree),
            48 => self.binary_number(&children[0], &children[1], parse_tree),
            49 => self.octal_number(&children[0], &children[1], parse_tree),
            50 => self.decimal_number(&children[0], &children[1], parse_tree),
            51 => self.hex_number(&children[0], &children[1], parse_tree),
            52 => self.base_less_number(&children[0], parse_tree),
            53 => self.operator_precedence1_0(&children[0], parse_tree),
            54 => self.operator_precedence1_1(&children[0], parse_tree),
            55 => self.operator_precedence2_0(&children[0], parse_tree),
            56 => self.operator_precedence2_1(&children[0], parse_tree),
            57 => self.expression(&children[0], parse_tree),
            58 => self.expression0(&children[0], &children[1], parse_tree),
            59 => self.expression0_list_0(&children[0], &children[1], &children[2], parse_tree),
            60 => self.expression0_list_1(parse_tree),
            61 => self.expression1(&children[0], &children[1], parse_tree),
            62 => self.expression1_list_0(&children[0], &children[1], &children[2], parse_tree),
            63 => self.expression1_list_1(parse_tree),
            64 => self.expression2(&children[0], parse_tree),
            65 => self.factor_0(&children[0], parse_tree),
            66 => self.factor_1(&children[0], &children[1], parse_tree),
            67 => self.factor_2(&children[0], &children[1], &children[2], parse_tree),
            68 => self.factor_opt_0(&children[0], parse_tree),
            69 => self.factor_opt_1(parse_tree),
            70 => self.statement_0(&children[0], parse_tree),
            71 => self.statement_1(&children[0], parse_tree),
            72 => self.assignment_statement(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            73 => self.if_statement(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
                parse_tree,
            ),
            74 => self.if_statement_list_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
                parse_tree,
            ),
            75 => self.if_statement_list_1(parse_tree),
            76 => self.if_statement_opt_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            77 => self.if_statement_opt_1(parse_tree),
            78 => self.range(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            79 => self.range_opt_0(&children[0], &children[1], parse_tree),
            80 => self.range_opt_1(parse_tree),
            81 => self.width(&children[0], &children[1], &children[2], parse_tree),
            82 => self.builtin_type_0(&children[0], parse_tree),
            83 => self.builtin_type_1(&children[0], parse_tree),
            84 => self.r#type(&children[0], &children[1], parse_tree),
            85 => self.type_group_0(&children[0], parse_tree),
            86 => self.type_group_1(&children[0], parse_tree),
            87 => self.type_list_0(&children[0], &children[1], parse_tree),
            88 => self.type_list_1(parse_tree),
            89 => self.with_parameter(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            90 => self.with_parameter_opt_0(&children[0], parse_tree),
            91 => self.with_parameter_opt_1(parse_tree),
            92 => self.with_parameter_list(&children[0], &children[1], &children[2], parse_tree),
            93 => self.with_parameter_list_list_0(
                &children[0],
                &children[1],
                &children[2],
                parse_tree,
            ),
            94 => self.with_parameter_list_list_1(parse_tree),
            95 => self.with_parameter_list_opt_0(&children[0], parse_tree),
            96 => self.with_parameter_list_opt_1(parse_tree),
            97 => self.with_parameter_item(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                parse_tree,
            ),
            98 => self.with_parameter_item_group_0(&children[0], parse_tree),
            99 => self.with_parameter_item_group_1(&children[0], parse_tree),
            100 => self.module_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
                parse_tree,
            ),
            101 => self.module_declaration_list_0(&children[0], &children[1], parse_tree),
            102 => self.module_declaration_list_1(parse_tree),
            103 => self.module_declaration_opt0_0(&children[0], parse_tree),
            104 => self.module_declaration_opt0_1(parse_tree),
            105 => self.module_declaration_opt_0(&children[0], parse_tree),
            106 => self.module_declaration_opt_1(parse_tree),
            107 => self.module_port(&children[0], &children[1], &children[2], parse_tree),
            108 => self.module_port_opt_0(&children[0], parse_tree),
            109 => self.module_port_opt_1(parse_tree),
            110 => self.module_port_list(&children[0], &children[1], &children[2], parse_tree),
            111 => {
                self.module_port_list_list_0(&children[0], &children[1], &children[2], parse_tree)
            }
            112 => self.module_port_list_list_1(parse_tree),
            113 => self.module_port_list_opt_0(&children[0], parse_tree),
            114 => self.module_port_list_opt_1(parse_tree),
            115 => self.module_port_item(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            116 => self.direction_0(&children[0], parse_tree),
            117 => self.direction_1(&children[0], parse_tree),
            118 => self.direction_2(&children[0], parse_tree),
            119 => self.module_item_0(&children[0], parse_tree),
            120 => self.module_item_1(&children[0], parse_tree),
            121 => self.module_item_2(&children[0], parse_tree),
            122 => self.module_item_3(&children[0], parse_tree),
            123 => self.module_item_4(&children[0], parse_tree),
            124 => self.interface_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                parse_tree,
            ),
            125 => self.interface_declaration_list_0(&children[0], &children[1], parse_tree),
            126 => self.interface_declaration_list_1(parse_tree),
            127 => self.interface_declaration_opt_0(&children[0], parse_tree),
            128 => self.interface_declaration_opt_1(parse_tree),
            129 => self.interface_item_0(&children[0], parse_tree),
            130 => self.interface_item_1(&children[0], parse_tree),
            131 => self.interface_item_2(&children[0], parse_tree),
            132 => self.interface_item_3(&children[0], parse_tree),
            133 => self.variable_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            134 => self.parameter_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
                parse_tree,
            ),
            135 => self.localparam_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
                parse_tree,
            ),
            136 => self.always_f_f_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
                parse_tree,
            ),
            137 => self.always_f_f_declaration_list_0(&children[0], &children[1], parse_tree),
            138 => self.always_f_f_declaration_list_1(parse_tree),
            139 => self.always_f_f_conditions(&children[0], &children[1], &children[2], parse_tree),
            140 => self.always_f_f_conditions_list_0(
                &children[0],
                &children[1],
                &children[2],
                parse_tree,
            ),
            141 => self.always_f_f_conditions_list_1(parse_tree),
            142 => self.always_f_f_conditions_opt_0(&children[0], parse_tree),
            143 => self.always_f_f_conditions_opt_1(parse_tree),
            144 => self.always_f_f_condition(&children[0], &children[1], parse_tree),
            145 => self.always_f_f_condition_group_0(&children[0], parse_tree),
            146 => self.always_f_f_condition_group_1(&children[0], parse_tree),
            147 => self.always_comb_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            148 => self.always_comb_declaration_list_0(&children[0], &children[1], parse_tree),
            149 => self.always_comb_declaration_list_1(parse_tree),
            150 => self.modport_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                parse_tree,
            ),
            151 => self.modport_list(&children[0], &children[1], &children[2], parse_tree),
            152 => self.modport_list_list_0(&children[0], &children[1], &children[2], parse_tree),
            153 => self.modport_list_list_1(parse_tree),
            154 => self.modport_list_opt_0(&children[0], parse_tree),
            155 => self.modport_list_opt_1(parse_tree),
            156 => self.modport_item(&children[0], &children[1], &children[2], parse_tree),
            _ => Err(miette!("Unhandled production number: {}", prod_num)),
        }
    }
}
