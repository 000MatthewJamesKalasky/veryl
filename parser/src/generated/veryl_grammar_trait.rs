// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

use parol_runtime::derive_builder::Builder;
use parol_runtime::id_tree::Tree;
#[allow(unused_imports)]
use parol_runtime::parol_macros::{pop_and_reverse_item, pop_item};

use parol_runtime::log::trace;
#[allow(unused_imports)]
use parol_runtime::miette::{bail, miette, IntoDiagnostic, Result};
use parol_runtime::parser::{ParseTreeStackEntry, ParseTreeType, UserActionsTrait};

use std::marker::PhantomData;

/// Semantic actions trait generated for the user grammar
/// All functions have default implementations.
pub trait VerylGrammarTrait {
    /// Semantic action for non-terminal 'LineComment'
    fn line_comment(&mut self, _arg: &LineComment) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BlockComment'
    fn block_comment(&mut self, _arg: &BlockComment) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Comments'
    fn comments(&mut self, _arg: &Comments) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Comment'
    fn comment(&mut self, _arg: &Comment) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StartToken'
    fn start_token(&mut self, _arg: &StartToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Start'
    fn start(&mut self, _arg: &Start) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BasedBinaryToken'
    fn based_binary_token(&mut self, _arg: &BasedBinaryToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BasedOctalToken'
    fn based_octal_token(&mut self, _arg: &BasedOctalToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BasedDecimalToken'
    fn based_decimal_token(&mut self, _arg: &BasedDecimalToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BasedHexToken'
    fn based_hex_token(&mut self, _arg: &BasedHexToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BaseLessToken'
    fn base_less_token(&mut self, _arg: &BaseLessToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BasedBinary'
    fn based_binary(&mut self, _arg: &BasedBinary) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BasedOctal'
    fn based_octal(&mut self, _arg: &BasedOctal) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BasedDecimal'
    fn based_decimal(&mut self, _arg: &BasedDecimal) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BasedHex'
    fn based_hex(&mut self, _arg: &BasedHex) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BaseLess'
    fn base_less(&mut self, _arg: &BaseLess) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PlusToken'
    fn plus_token(&mut self, _arg: &PlusToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MinusToken'
    fn minus_token(&mut self, _arg: &MinusToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StarToken'
    fn star_token(&mut self, _arg: &StarToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'SlashToken'
    fn slash_token(&mut self, _arg: &SlashToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ColonToken'
    fn colon_token(&mut self, _arg: &ColonToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'SemicolonToken'
    fn semicolon_token(&mut self, _arg: &SemicolonToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'CommaToken'
    fn comma_token(&mut self, _arg: &CommaToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LParenToken'
    fn l_paren_token(&mut self, _arg: &LParenToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RParenToken'
    fn r_paren_token(&mut self, _arg: &RParenToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LBracketToken'
    fn l_bracket_token(&mut self, _arg: &LBracketToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RBracketToken'
    fn r_bracket_token(&mut self, _arg: &RBracketToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LBraceToken'
    fn l_brace_token(&mut self, _arg: &LBraceToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RBraceToken'
    fn r_brace_token(&mut self, _arg: &RBraceToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EquToken'
    fn equ_token(&mut self, _arg: &EquToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'HashToken'
    fn hash_token(&mut self, _arg: &HashToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Plus'
    fn plus(&mut self, _arg: &Plus) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Minus'
    fn minus(&mut self, _arg: &Minus) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Star'
    fn star(&mut self, _arg: &Star) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Slash'
    fn slash(&mut self, _arg: &Slash) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Colon'
    fn colon(&mut self, _arg: &Colon) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Semicolon'
    fn semicolon(&mut self, _arg: &Semicolon) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Comma'
    fn comma(&mut self, _arg: &Comma) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LParen'
    fn l_paren(&mut self, _arg: &LParen) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RParen'
    fn r_paren(&mut self, _arg: &RParen) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LBracket'
    fn l_bracket(&mut self, _arg: &LBracket) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RBracket'
    fn r_bracket(&mut self, _arg: &RBracket) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LBrace'
    fn l_brace(&mut self, _arg: &LBrace) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RBrace'
    fn r_brace(&mut self, _arg: &RBrace) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Equ'
    fn equ(&mut self, _arg: &Equ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Hash'
    fn hash(&mut self, _arg: &Hash) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LogicToken'
    fn logic_token(&mut self, _arg: &LogicToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BitToken'
    fn bit_token(&mut self, _arg: &BitToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AlwaysFfToken'
    fn always_ff_token(&mut self, _arg: &AlwaysFfToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AlwaysCombToken'
    fn always_comb_token(&mut self, _arg: &AlwaysCombToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PosedgeToken'
    fn posedge_token(&mut self, _arg: &PosedgeToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'NegedgeToken'
    fn negedge_token(&mut self, _arg: &NegedgeToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IfToken'
    fn if_token(&mut self, _arg: &IfToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ElseToken'
    fn else_token(&mut self, _arg: &ElseToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ParameterToken'
    fn parameter_token(&mut self, _arg: &ParameterToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LocalparamToken'
    fn localparam_token(&mut self, _arg: &LocalparamToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModuleToken'
    fn module_token(&mut self, _arg: &ModuleToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InterfaceToken'
    fn interface_token(&mut self, _arg: &InterfaceToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InputToken'
    fn input_token(&mut self, _arg: &InputToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'OutputToken'
    fn output_token(&mut self, _arg: &OutputToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InoutToken'
    fn inout_token(&mut self, _arg: &InoutToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModportToken'
    fn modport_token(&mut self, _arg: &ModportToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'U32Token'
    fn u32_token(&mut self, _arg: &U32Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'U64Token'
    fn u64_token(&mut self, _arg: &U64Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'I32Token'
    fn i32_token(&mut self, _arg: &I32Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'I64Token'
    fn i64_token(&mut self, _arg: &I64Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'F32Token'
    fn f32_token(&mut self, _arg: &F32Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'F64Token'
    fn f64_token(&mut self, _arg: &F64Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Logic'
    fn logic(&mut self, _arg: &Logic) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Bit'
    fn bit(&mut self, _arg: &Bit) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AlwaysFf'
    fn always_ff(&mut self, _arg: &AlwaysFf) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AlwaysComb'
    fn always_comb(&mut self, _arg: &AlwaysComb) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Posedge'
    fn posedge(&mut self, _arg: &Posedge) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Negedge'
    fn negedge(&mut self, _arg: &Negedge) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'If'
    fn r#if(&mut self, _arg: &If) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Else'
    fn r#else(&mut self, _arg: &Else) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Parameter'
    fn parameter(&mut self, _arg: &Parameter) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Localparam'
    fn localparam(&mut self, _arg: &Localparam) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Module'
    fn module(&mut self, _arg: &Module) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Interface'
    fn interface(&mut self, _arg: &Interface) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Input'
    fn input(&mut self, _arg: &Input) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Output'
    fn output(&mut self, _arg: &Output) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Inout'
    fn inout(&mut self, _arg: &Inout) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Modport'
    fn modport(&mut self, _arg: &Modport) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'U32'
    fn u32(&mut self, _arg: &U32) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'U64'
    fn u64(&mut self, _arg: &U64) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'I32'
    fn i32(&mut self, _arg: &I32) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'I64'
    fn i64(&mut self, _arg: &I64) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'F32'
    fn f32(&mut self, _arg: &F32) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'F64'
    fn f64(&mut self, _arg: &F64) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IdentifierToken'
    fn identifier_token(&mut self, _arg: &IdentifierToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Identifier'
    fn identifier(&mut self, _arg: &Identifier) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Veryl'
    fn veryl(&mut self, _arg: &Veryl) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Description'
    fn description(&mut self, _arg: &Description) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Number'
    fn number(&mut self, _arg: &Number) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IntegralNumber'
    fn integral_number(&mut self, _arg: &IntegralNumber) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'OperatorPrecedence1'
    fn operator_precedence1(&mut self, _arg: &OperatorPrecedence1) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'OperatorPrecedence2'
    fn operator_precedence2(&mut self, _arg: &OperatorPrecedence2) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression'
    fn expression(&mut self, _arg: &Expression) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression0'
    fn expression0(&mut self, _arg: &Expression0) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression1'
    fn expression1(&mut self, _arg: &Expression1) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression2'
    fn expression2(&mut self, _arg: &Expression2) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Factor'
    fn factor(&mut self, _arg: &Factor) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Statement'
    fn statement(&mut self, _arg: &Statement) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AssignmentStatement'
    fn assignment_statement(&mut self, _arg: &AssignmentStatement) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IfStatement'
    fn if_statement(&mut self, _arg: &IfStatement) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Range'
    fn range(&mut self, _arg: &Range) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Width'
    fn width(&mut self, _arg: &Width) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BuiltinType'
    fn builtin_type(&mut self, _arg: &BuiltinType) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Type'
    fn r#type(&mut self, _arg: &Type) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WithParameter'
    fn with_parameter(&mut self, _arg: &WithParameter) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WithParameterList'
    fn with_parameter_list(&mut self, _arg: &WithParameterList) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WithParameterItem'
    fn with_parameter_item(&mut self, _arg: &WithParameterItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModuleDeclaration'
    fn module_declaration(&mut self, _arg: &ModuleDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModulePort'
    fn module_port(&mut self, _arg: &ModulePort) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModulePortList'
    fn module_port_list(&mut self, _arg: &ModulePortList) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModulePortItem'
    fn module_port_item(&mut self, _arg: &ModulePortItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Direction'
    fn direction(&mut self, _arg: &Direction) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModuleItem'
    fn module_item(&mut self, _arg: &ModuleItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InterfaceDeclaration'
    fn interface_declaration(&mut self, _arg: &InterfaceDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InterfaceItem'
    fn interface_item(&mut self, _arg: &InterfaceItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'VariableDeclaration'
    fn variable_declaration(&mut self, _arg: &VariableDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ParameterDeclaration'
    fn parameter_declaration(&mut self, _arg: &ParameterDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LocalparamDeclaration'
    fn localparam_declaration(&mut self, _arg: &LocalparamDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AlwaysFfDeclaration'
    fn always_ff_declaration(&mut self, _arg: &AlwaysFfDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AlwaysFfConditions'
    fn always_ff_conditions(&mut self, _arg: &AlwaysFfConditions) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AlwaysFfCondition'
    fn always_ff_condition(&mut self, _arg: &AlwaysFfCondition) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AlwaysCombDeclaration'
    fn always_comb_declaration(&mut self, _arg: &AlwaysCombDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModportDeclaration'
    fn modport_declaration(&mut self, _arg: &ModportDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModportList'
    fn modport_list(&mut self, _arg: &ModportList) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModportItem'
    fn modport_item(&mut self, _arg: &ModportItem) -> Result<()> {
        Ok(())
    }
}

// -------------------------------------------------------------------------------------------------
//
// Output Types of productions deduced from the structure of the transformed grammar
//

///
/// Type derived for production 4
///
/// CommentsListGroup: LineComment;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct CommentsListGroup0 {
    pub line_comment: Box<LineComment>,
}

///
/// Type derived for production 5
///
/// CommentsListGroup: BlockComment;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct CommentsListGroup1 {
    pub block_comment: Box<BlockComment>,
}

///
/// Type derived for production 9
///
/// CommentOptGroup: LineComment;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct CommentOptGroup0 {
    pub line_comment: Box<LineComment>,
}

///
/// Type derived for production 10
///
/// CommentOptGroup: BlockComment;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct CommentOptGroup1 {
    pub block_comment: Box<BlockComment>,
}

///
/// Type derived for production 103
///
/// Description: ModuleDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Description0 {
    pub module_declaration: Box<ModuleDeclaration>,
}

///
/// Type derived for production 104
///
/// Description: InterfaceDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Description1 {
    pub interface_declaration: Box<InterfaceDeclaration>,
}

///
/// Type derived for production 106
///
/// IntegralNumber: BasedBinary;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct IntegralNumber0 {
    pub based_binary: Box<BasedBinary>,
}

///
/// Type derived for production 107
///
/// IntegralNumber: BasedOctal;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct IntegralNumber1 {
    pub based_octal: Box<BasedOctal>,
}

///
/// Type derived for production 108
///
/// IntegralNumber: BasedDecimal;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct IntegralNumber2 {
    pub based_decimal: Box<BasedDecimal>,
}

///
/// Type derived for production 109
///
/// IntegralNumber: BasedHex;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct IntegralNumber3 {
    pub based_hex: Box<BasedHex>,
}

///
/// Type derived for production 110
///
/// IntegralNumber: BaseLess;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct IntegralNumber4 {
    pub base_less: Box<BaseLess>,
}

///
/// Type derived for production 111
///
/// OperatorPrecedence1: Plus;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct OperatorPrecedence3 {
    pub plus: Box<Plus>,
}

///
/// Type derived for production 112
///
/// OperatorPrecedence1: Minus;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct OperatorPrecedence4 {
    pub minus: Box<Minus>,
}

///
/// Type derived for production 113
///
/// OperatorPrecedence2: Star;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct OperatorPrecedence5 {
    pub star: Box<Star>,
}

///
/// Type derived for production 114
///
/// OperatorPrecedence2: Slash;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct OperatorPrecedence6 {
    pub slash: Box<Slash>,
}

///
/// Type derived for production 123
///
/// Factor: Number;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Factor0 {
    pub number: Box<Number>,
}

///
/// Type derived for production 124
///
/// Factor: Identifier FactorList /* Vec */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Factor1 {
    pub identifier: Box<Identifier>,
    pub factor_list: Vec<FactorList>,
}

///
/// Type derived for production 127
///
/// Factor: LParen Expression RParen;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Factor2 {
    pub l_paren: Box<LParen>,
    pub expression: Box<Expression>,
    pub r_paren: Box<RParen>,
}

///
/// Type derived for production 128
///
/// Statement: AssignmentStatement;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Statement0 {
    pub assignment_statement: Box<AssignmentStatement>,
}

///
/// Type derived for production 129
///
/// Statement: IfStatement;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Statement1 {
    pub if_statement: Box<IfStatement>,
}

///
/// Type derived for production 140
///
/// BuiltinType: Logic;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BuiltinType0 {
    pub logic: Box<Logic>,
}

///
/// Type derived for production 141
///
/// BuiltinType: Bit;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BuiltinType1 {
    pub bit: Box<Bit>,
}

///
/// Type derived for production 142
///
/// BuiltinType: U32;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BuiltinType2 {
    pub u32: Box<U32>,
}

///
/// Type derived for production 143
///
/// BuiltinType: U64;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BuiltinType3 {
    pub u64: Box<U64>,
}

///
/// Type derived for production 144
///
/// BuiltinType: I32;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BuiltinType4 {
    pub i32: Box<I32>,
}

///
/// Type derived for production 145
///
/// BuiltinType: I64;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BuiltinType5 {
    pub i64: Box<I64>,
}

///
/// Type derived for production 146
///
/// BuiltinType: F32;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BuiltinType6 {
    pub f32: Box<F32>,
}

///
/// Type derived for production 147
///
/// BuiltinType: F64;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BuiltinType7 {
    pub f64: Box<F64>,
}

///
/// Type derived for production 149
///
/// TypeGroup: BuiltinType;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct TypeGroup0 {
    pub builtin_type: Box<BuiltinType>,
}

///
/// Type derived for production 150
///
/// TypeGroup: Identifier;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct TypeGroup1 {
    pub identifier: Box<Identifier>,
}

///
/// Type derived for production 162
///
/// WithParameterItemGroup: Parameter;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct WithParameterItemGroup0 {
    pub parameter: Box<Parameter>,
}

///
/// Type derived for production 163
///
/// WithParameterItemGroup: Localparam;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct WithParameterItemGroup1 {
    pub localparam: Box<Localparam>,
}

///
/// Type derived for production 180
///
/// Direction: Input;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Direction0 {
    pub input: Box<Input>,
}

///
/// Type derived for production 181
///
/// Direction: Output;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Direction1 {
    pub output: Box<Output>,
}

///
/// Type derived for production 182
///
/// Direction: Inout;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Direction2 {
    pub inout: Box<Inout>,
}

///
/// Type derived for production 183
///
/// ModuleItem: VariableDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModuleItem0 {
    pub variable_declaration: Box<VariableDeclaration>,
}

///
/// Type derived for production 184
///
/// ModuleItem: ParameterDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModuleItem1 {
    pub parameter_declaration: Box<ParameterDeclaration>,
}

///
/// Type derived for production 185
///
/// ModuleItem: LocalparamDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModuleItem2 {
    pub localparam_declaration: Box<LocalparamDeclaration>,
}

///
/// Type derived for production 186
///
/// ModuleItem: AlwaysFfDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModuleItem3 {
    pub always_ff_declaration: Box<AlwaysFfDeclaration>,
}

///
/// Type derived for production 187
///
/// ModuleItem: AlwaysCombDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModuleItem4 {
    pub always_comb_declaration: Box<AlwaysCombDeclaration>,
}

///
/// Type derived for production 193
///
/// InterfaceItem: VariableDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct InterfaceItem0 {
    pub variable_declaration: Box<VariableDeclaration>,
}

///
/// Type derived for production 194
///
/// InterfaceItem: ParameterDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct InterfaceItem1 {
    pub parameter_declaration: Box<ParameterDeclaration>,
}

///
/// Type derived for production 195
///
/// InterfaceItem: LocalparamDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct InterfaceItem2 {
    pub localparam_declaration: Box<LocalparamDeclaration>,
}

///
/// Type derived for production 196
///
/// InterfaceItem: ModportDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct InterfaceItem3 {
    pub modport_declaration: Box<ModportDeclaration>,
}

///
/// Type derived for production 209
///
/// AlwaysFfConditionGroup: Posedge;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AlwaysFfConditionGroup0 {
    pub posedge: Box<Posedge>,
}

///
/// Type derived for production 210
///
/// AlwaysFfConditionGroup: Negedge;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AlwaysFfConditionGroup1 {
    pub negedge: Box<Negedge>,
}

// -------------------------------------------------------------------------------------------------
//
// Types of non-terminals deduced from the structure of the transformed grammar
//

///
/// Type derived for non-terminal AlwaysComb
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AlwaysComb {
    pub always_comb_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal AlwaysCombDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AlwaysCombDeclaration {
    pub always_comb: Box<AlwaysComb>,
    pub l_brace: Box<LBrace>,
    pub always_comb_declaration_list: Vec<AlwaysCombDeclarationList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal AlwaysCombDeclarationList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AlwaysCombDeclarationList {
    pub statement: Box<Statement>,
}

///
/// Type derived for non-terminal AlwaysCombToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AlwaysCombToken {
    pub always_underscore_comb: crate::veryl_token::OwnedToken, /* always_comb */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal AlwaysFf
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AlwaysFf {
    pub always_ff_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal AlwaysFfCondition
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AlwaysFfCondition {
    pub always_ff_condition_group: Box<AlwaysFfConditionGroup>,
    pub identifier: Box<Identifier>,
}

///
/// Type derived for non-terminal AlwaysFfConditionGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum AlwaysFfConditionGroup {
    AlwaysFfConditionGroup0(AlwaysFfConditionGroup0),
    AlwaysFfConditionGroup1(AlwaysFfConditionGroup1),
}

///
/// Type derived for non-terminal AlwaysFfConditions
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AlwaysFfConditions {
    pub always_ff_condition: Box<AlwaysFfCondition>,
    pub always_ff_conditions_list: Vec<AlwaysFfConditionsList>,
    pub always_ff_conditions_opt: Option<Box<AlwaysFfConditionsOpt>>,
}

///
/// Type derived for non-terminal AlwaysFfConditionsList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AlwaysFfConditionsList {
    pub comma: Box<Comma>,
    pub always_ff_condition: Box<AlwaysFfCondition>,
}

///
/// Type derived for non-terminal AlwaysFfConditionsOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AlwaysFfConditionsOpt {
    pub comma: Box<Comma>,
}

///
/// Type derived for non-terminal AlwaysFfDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AlwaysFfDeclaration {
    pub always_ff: Box<AlwaysFf>,
    pub l_paren: Box<LParen>,
    pub always_ff_conditions: Box<AlwaysFfConditions>,
    pub r_paren: Box<RParen>,
    pub l_brace: Box<LBrace>,
    pub always_ff_declaration_list: Vec<AlwaysFfDeclarationList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal AlwaysFfDeclarationList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AlwaysFfDeclarationList {
    pub statement: Box<Statement>,
}

///
/// Type derived for non-terminal AlwaysFfToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AlwaysFfToken {
    pub always_underscore_ff: crate::veryl_token::OwnedToken, /* always_ff */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal AssignmentStatement
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AssignmentStatement {
    pub identifier: Box<Identifier>,
    pub equ: Box<Equ>,
    pub expression: Box<Expression>,
    pub semicolon: Box<Semicolon>,
}

///
/// Type derived for non-terminal BaseLess
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BaseLess {
    pub base_less_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal BaseLessToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BaseLessToken {
    pub l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star:
        crate::veryl_token::OwnedToken, /* [0-9]+(?:_[0-9]+)* */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal BasedBinary
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BasedBinary {
    pub based_binary_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal BasedBinaryToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BasedBinaryToken {
    pub l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_tick_b_l_bracket0_minus1xz_x_z_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus1xz_x_z_r_bracket_plus_r_paren_star:
        crate::veryl_token::OwnedToken, /* [0-9]+(?:_[0-9]+)*'b[0-1xzXZ]+(?:_[0-1xzXZ]+)* */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal BasedDecimal
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BasedDecimal {
    pub based_decimal_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal BasedDecimalToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BasedDecimalToken {
    pub l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_tick_d_l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star:
        crate::veryl_token::OwnedToken, /* [0-9]+(?:_[0-9]+)*'d[0-9]+(?:_[0-9]+)* */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal BasedHex
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BasedHex {
    pub based_hex_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal BasedHexToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BasedHexToken {
    pub l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_tick_h_l_bracket0_minus9a_minus_f_a_minus_fxz_x_z_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9a_minus_f_a_minus_fxz_x_z_r_bracket_plus_r_paren_star:
        crate::veryl_token::OwnedToken, /* [0-9]+(?:_[0-9]+)*'h[0-9a-fA-FxzXZ]+(?:_[0-9a-fA-FxzXZ]+)* */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal BasedOctal
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BasedOctal {
    pub based_octal_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal BasedOctalToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BasedOctalToken {
    pub l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_tick_o_l_bracket0_minus7xz_x_z_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus7xz_x_z_r_bracket_plus_r_paren_star:
        crate::veryl_token::OwnedToken, /* [0-9]+(?:_[0-9]+)*'o[0-7xzXZ]+(?:_[0-7xzXZ]+)* */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Bit
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Bit {
    pub bit_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal BitToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BitToken {
    pub bit: crate::veryl_token::OwnedToken, /* bit */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal BlockComment
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BlockComment {
    pub block_comment: crate::veryl_token::OwnedToken, /* (?ms)/\u{2a}.*?\u{2a}/ */
}

///
/// Type derived for non-terminal BuiltinType
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum BuiltinType {
    BuiltinType0(BuiltinType0),
    BuiltinType1(BuiltinType1),
    BuiltinType2(BuiltinType2),
    BuiltinType3(BuiltinType3),
    BuiltinType4(BuiltinType4),
    BuiltinType5(BuiltinType5),
    BuiltinType6(BuiltinType6),
    BuiltinType7(BuiltinType7),
}

///
/// Type derived for non-terminal Colon
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Colon {
    pub colon_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal ColonToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ColonToken {
    pub colon: crate::veryl_token::OwnedToken, /* : */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Comma
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Comma {
    pub comma_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal CommaToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct CommaToken {
    pub comma: crate::veryl_token::OwnedToken, /* , */
    pub comment: Box<Comment>,
}

///
/// Type derived for non-terminal Comment
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Comment {
    pub comment_opt: Option<Box<CommentOpt>>,
}

///
/// Type derived for non-terminal CommentOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct CommentOpt {
    pub comment_opt_group: Box<CommentOptGroup>,
}

///
/// Type derived for non-terminal CommentOptGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum CommentOptGroup {
    CommentOptGroup0(CommentOptGroup0),
    CommentOptGroup1(CommentOptGroup1),
}

///
/// Type derived for non-terminal Comments
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Comments {
    pub comments_list: Vec<CommentsList>,
}

///
/// Type derived for non-terminal CommentsList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct CommentsList {
    pub comments_list_group: Box<CommentsListGroup>,
}

///
/// Type derived for non-terminal CommentsListGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum CommentsListGroup {
    CommentsListGroup0(CommentsListGroup0),
    CommentsListGroup1(CommentsListGroup1),
}

///
/// Type derived for non-terminal Description
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Description {
    Description0(Description0),
    Description1(Description1),
}

///
/// Type derived for non-terminal Direction
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Direction {
    Direction0(Direction0),
    Direction1(Direction1),
    Direction2(Direction2),
}

///
/// Type derived for non-terminal Else
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Else {
    pub else_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal ElseToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ElseToken {
    pub r#else: crate::veryl_token::OwnedToken, /* else */
    pub comment: Box<Comment>,
}

///
/// Type derived for non-terminal Equ
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Equ {
    pub equ_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal EquToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct EquToken {
    pub equ: crate::veryl_token::OwnedToken, /* = */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Expression
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Expression {
    pub expression0: Box<Expression0>,
}

///
/// Type derived for non-terminal Expression0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Expression0 {
    pub expression1: Box<Expression1>,
    pub expression0_list: Vec<Expression0List>,
}

///
/// Type derived for non-terminal Expression0List
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Expression0List {
    pub operator_precedence1: Box<OperatorPrecedence1>,
    pub expression1: Box<Expression1>,
}

///
/// Type derived for non-terminal Expression1
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Expression1 {
    pub expression2: Box<Expression2>,
    pub expression1_list: Vec<Expression1List>,
}

///
/// Type derived for non-terminal Expression1List
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Expression1List {
    pub operator_precedence2: Box<OperatorPrecedence2>,
    pub expression2: Box<Expression2>,
}

///
/// Type derived for non-terminal Expression2
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Expression2 {
    pub factor: Box<Factor>,
}

///
/// Type derived for non-terminal F32
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct F32 {
    pub f32_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal F32Token
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct F32Token {
    pub f32: crate::veryl_token::OwnedToken, /* f32 */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal F64
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct F64 {
    pub f64_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal F64Token
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct F64Token {
    pub f64: crate::veryl_token::OwnedToken, /* f64 */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Factor
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Factor {
    Factor0(Factor0),
    Factor1(Factor1),
    Factor2(Factor2),
}

///
/// Type derived for non-terminal FactorList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct FactorList {
    pub range: Box<Range>,
}

///
/// Type derived for non-terminal Hash
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Hash {
    pub hash_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal HashToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct HashToken {
    pub hash: crate::veryl_token::OwnedToken, /* # */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal I32
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct I32 {
    pub i32_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal I32Token
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct I32Token {
    pub i32: crate::veryl_token::OwnedToken, /* i32 */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal I64
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct I64 {
    pub i64_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal I64Token
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct I64Token {
    pub i64: crate::veryl_token::OwnedToken, /* i64 */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Identifier
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Identifier {
    pub identifier_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal IdentifierToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct IdentifierToken {
    pub l_bracket_a_minus_z_a_minus_z_underscore_r_bracket_l_bracket0_minus9a_minus_z_a_minus_z_underscore_r_bracket_star:
        crate::veryl_token::OwnedToken, /* [a-zA-Z_][0-9a-zA-Z_]* */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal If
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct If {
    pub if_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal IfStatement
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct IfStatement {
    pub r#if: Box<If>,
    pub expression: Box<Expression>,
    pub l_brace: Box<LBrace>,
    pub statement: Box<Statement>,
    pub r_brace: Box<RBrace>,
    pub if_statement_list: Vec<IfStatementList>,
    pub if_statement_opt: Option<Box<IfStatementOpt>>,
}

///
/// Type derived for non-terminal IfStatementList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct IfStatementList {
    pub r#else: Box<Else>,
    pub r#if: Box<If>,
    pub expression: Box<Expression>,
    pub l_brace: Box<LBrace>,
    pub statement: Box<Statement>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal IfStatementOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct IfStatementOpt {
    pub r#else: Box<Else>,
    pub l_brace: Box<LBrace>,
    pub statement: Box<Statement>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal IfToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct IfToken {
    pub r#if: crate::veryl_token::OwnedToken, /* if */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Inout
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Inout {
    pub inout_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal InoutToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct InoutToken {
    pub inout: crate::veryl_token::OwnedToken, /* inout */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Input
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Input {
    pub input_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal InputToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct InputToken {
    pub input: crate::veryl_token::OwnedToken, /* input */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal IntegralNumber
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum IntegralNumber {
    IntegralNumber0(IntegralNumber0),
    IntegralNumber1(IntegralNumber1),
    IntegralNumber2(IntegralNumber2),
    IntegralNumber3(IntegralNumber3),
    IntegralNumber4(IntegralNumber4),
}

///
/// Type derived for non-terminal Interface
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Interface {
    pub interface_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal InterfaceDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct InterfaceDeclaration {
    pub interface: Box<Interface>,
    pub identifier: Box<Identifier>,
    pub interface_declaration_opt: Option<Box<InterfaceDeclarationOpt>>,
    pub l_brace: Box<LBrace>,
    pub interface_declaration_list: Vec<InterfaceDeclarationList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal InterfaceDeclarationList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct InterfaceDeclarationList {
    pub interface_item: Box<InterfaceItem>,
}

///
/// Type derived for non-terminal InterfaceDeclarationOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct InterfaceDeclarationOpt {
    pub with_parameter: Box<WithParameter>,
}

///
/// Type derived for non-terminal InterfaceItem
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum InterfaceItem {
    InterfaceItem0(InterfaceItem0),
    InterfaceItem1(InterfaceItem1),
    InterfaceItem2(InterfaceItem2),
    InterfaceItem3(InterfaceItem3),
}

///
/// Type derived for non-terminal InterfaceToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct InterfaceToken {
    pub interface: crate::veryl_token::OwnedToken, /* interface */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal LBrace
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LBrace {
    pub l_brace_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal LBraceToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LBraceToken {
    pub l_brace: crate::veryl_token::OwnedToken, /* { */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal LBracket
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LBracket {
    pub l_bracket_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal LBracketToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LBracketToken {
    pub l_bracket: crate::veryl_token::OwnedToken, /* [ */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal LParen
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LParen {
    pub l_paren_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal LParenToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LParenToken {
    pub l_paren: crate::veryl_token::OwnedToken, /* ( */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal LineComment
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LineComment {
    pub line_comment: crate::veryl_token::OwnedToken, /* //.*(:?\r\n|\r|\n|$) */
}

///
/// Type derived for non-terminal Localparam
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Localparam {
    pub localparam_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal LocalparamDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LocalparamDeclaration {
    pub localparam: Box<Localparam>,
    pub identifier: Box<Identifier>,
    pub colon: Box<Colon>,
    pub r#type: Box<Type>,
    pub equ: Box<Equ>,
    pub expression: Box<Expression>,
    pub semicolon: Box<Semicolon>,
}

///
/// Type derived for non-terminal LocalparamToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LocalparamToken {
    pub localparam: crate::veryl_token::OwnedToken, /* localparam */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Logic
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Logic {
    pub logic_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal LogicToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LogicToken {
    pub logic: crate::veryl_token::OwnedToken, /* logic */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Minus
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Minus {
    pub minus_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal MinusToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct MinusToken {
    pub minus: crate::veryl_token::OwnedToken, /* - */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Modport
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Modport {
    pub modport_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal ModportDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModportDeclaration {
    pub modport: Box<Modport>,
    pub identifier: Box<Identifier>,
    pub l_brace: Box<LBrace>,
    pub modport_list: Box<ModportList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal ModportItem
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModportItem {
    pub identifier: Box<Identifier>,
    pub colon: Box<Colon>,
    pub direction: Box<Direction>,
}

///
/// Type derived for non-terminal ModportList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModportList {
    pub modport_item: Box<ModportItem>,
    pub modport_list_list: Vec<ModportListList>,
    pub modport_list_opt: Option<Box<ModportListOpt>>,
}

///
/// Type derived for non-terminal ModportListList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModportListList {
    pub comma: Box<Comma>,
    pub modport_item: Box<ModportItem>,
}

///
/// Type derived for non-terminal ModportListOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModportListOpt {
    pub comma: Box<Comma>,
}

///
/// Type derived for non-terminal ModportToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModportToken {
    pub modport: crate::veryl_token::OwnedToken, /* modport */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Module
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Module {
    pub module_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal ModuleDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModuleDeclaration {
    pub module: Box<Module>,
    pub identifier: Box<Identifier>,
    pub module_declaration_opt: Option<Box<ModuleDeclarationOpt>>,
    pub module_declaration_opt0: Option<Box<ModuleDeclarationOpt0>>,
    pub l_brace: Box<LBrace>,
    pub module_declaration_list: Vec<ModuleDeclarationList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal ModuleDeclarationList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModuleDeclarationList {
    pub module_item: Box<ModuleItem>,
}

///
/// Type derived for non-terminal ModuleDeclarationOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModuleDeclarationOpt {
    pub with_parameter: Box<WithParameter>,
}

///
/// Type derived for non-terminal ModuleDeclarationOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModuleDeclarationOpt0 {
    pub module_port: Box<ModulePort>,
}

///
/// Type derived for non-terminal ModuleItem
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ModuleItem {
    ModuleItem0(ModuleItem0),
    ModuleItem1(ModuleItem1),
    ModuleItem2(ModuleItem2),
    ModuleItem3(ModuleItem3),
    ModuleItem4(ModuleItem4),
}

///
/// Type derived for non-terminal ModulePort
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModulePort {
    pub l_paren: Box<LParen>,
    pub module_port_opt: Option<Box<ModulePortOpt>>,
    pub r_paren: Box<RParen>,
}

///
/// Type derived for non-terminal ModulePortItem
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModulePortItem {
    pub identifier: Box<Identifier>,
    pub colon: Box<Colon>,
    pub direction: Box<Direction>,
    pub r#type: Box<Type>,
}

///
/// Type derived for non-terminal ModulePortList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModulePortList {
    pub module_port_item: Box<ModulePortItem>,
    pub module_port_list_list: Vec<ModulePortListList>,
    pub module_port_list_opt: Option<Box<ModulePortListOpt>>,
}

///
/// Type derived for non-terminal ModulePortListList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModulePortListList {
    pub comma: Box<Comma>,
    pub module_port_item: Box<ModulePortItem>,
}

///
/// Type derived for non-terminal ModulePortListOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModulePortListOpt {
    pub comma: Box<Comma>,
}

///
/// Type derived for non-terminal ModulePortOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModulePortOpt {
    pub module_port_list: Box<ModulePortList>,
}

///
/// Type derived for non-terminal ModuleToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModuleToken {
    pub module: crate::veryl_token::OwnedToken, /* module */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Negedge
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Negedge {
    pub negedge_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal NegedgeToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct NegedgeToken {
    pub negedge: crate::veryl_token::OwnedToken, /* negedge */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Number
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Number {
    pub integral_number: Box<IntegralNumber>,
}

///
/// Type derived for non-terminal OperatorPrecedence1
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum OperatorPrecedence1 {
    OperatorPrecedence10(OperatorPrecedence3),
    OperatorPrecedence11(OperatorPrecedence4),
}

///
/// Type derived for non-terminal OperatorPrecedence2
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum OperatorPrecedence2 {
    OperatorPrecedence20(OperatorPrecedence5),
    OperatorPrecedence21(OperatorPrecedence6),
}

///
/// Type derived for non-terminal Output
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Output {
    pub output_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal OutputToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct OutputToken {
    pub output: crate::veryl_token::OwnedToken, /* output */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Parameter
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Parameter {
    pub parameter_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal ParameterDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ParameterDeclaration {
    pub parameter: Box<Parameter>,
    pub identifier: Box<Identifier>,
    pub colon: Box<Colon>,
    pub r#type: Box<Type>,
    pub equ: Box<Equ>,
    pub expression: Box<Expression>,
    pub semicolon: Box<Semicolon>,
}

///
/// Type derived for non-terminal ParameterToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ParameterToken {
    pub parameter: crate::veryl_token::OwnedToken, /* parameter */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Plus
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Plus {
    pub plus_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal PlusToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct PlusToken {
    pub plus: crate::veryl_token::OwnedToken, /* + */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Posedge
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Posedge {
    pub posedge_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal PosedgeToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct PosedgeToken {
    pub posedge: crate::veryl_token::OwnedToken, /* posedge */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal RBrace
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct RBrace {
    pub r_brace_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal RBraceToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct RBraceToken {
    pub r_brace: crate::veryl_token::OwnedToken, /* } */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal RBracket
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct RBracket {
    pub r_bracket_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal RBracketToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct RBracketToken {
    pub r_bracket: crate::veryl_token::OwnedToken, /* ] */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal RParen
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct RParen {
    pub r_paren_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal RParenToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct RParenToken {
    pub r_paren: crate::veryl_token::OwnedToken, /* ) */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Range
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Range {
    pub l_bracket: Box<LBracket>,
    pub expression: Box<Expression>,
    pub range_opt: Option<Box<RangeOpt>>,
    pub r_bracket: Box<RBracket>,
}

///
/// Type derived for non-terminal RangeOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct RangeOpt {
    pub colon: Box<Colon>,
    pub expression: Box<Expression>,
}

///
/// Type derived for non-terminal Semicolon
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Semicolon {
    pub semicolon_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal SemicolonToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct SemicolonToken {
    pub semicolon: crate::veryl_token::OwnedToken, /* ; */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Slash
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Slash {
    pub slash_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal SlashToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct SlashToken {
    pub slash: crate::veryl_token::OwnedToken, /* / */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Star
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Star {
    pub star_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal StarToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct StarToken {
    pub star: crate::veryl_token::OwnedToken, /* * */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Start
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Start {
    pub start_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal StartToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct StartToken {
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Statement
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Statement {
    Statement0(Statement0),
    Statement1(Statement1),
}

///
/// Type derived for non-terminal Type
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Type {
    pub type_group: Box<TypeGroup>,
    pub type_list: Vec<TypeList>,
}

///
/// Type derived for non-terminal TypeGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum TypeGroup {
    TypeGroup0(TypeGroup0),
    TypeGroup1(TypeGroup1),
}

///
/// Type derived for non-terminal TypeList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct TypeList {
    pub width: Box<Width>,
}

///
/// Type derived for non-terminal U32
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct U32 {
    pub u32_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal U32Token
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct U32Token {
    pub u32: crate::veryl_token::OwnedToken, /* u32 */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal U64
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct U64 {
    pub u64_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal U64Token
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct U64Token {
    pub u64: crate::veryl_token::OwnedToken, /* u64 */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal VariableDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct VariableDeclaration {
    pub identifier: Box<Identifier>,
    pub colon: Box<Colon>,
    pub r#type: Box<Type>,
    pub semicolon: Box<Semicolon>,
}

///
/// Type derived for non-terminal Veryl
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Veryl {
    pub start: Box<Start>,
    pub veryl_list: Vec<VerylList>,
}

///
/// Type derived for non-terminal VerylList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct VerylList {
    pub description: Box<Description>,
}

///
/// Type derived for non-terminal Width
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Width {
    pub l_bracket: Box<LBracket>,
    pub expression: Box<Expression>,
    pub r_bracket: Box<RBracket>,
}

///
/// Type derived for non-terminal WithParameter
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct WithParameter {
    pub hash: Box<Hash>,
    pub l_paren: Box<LParen>,
    pub with_parameter_opt: Option<Box<WithParameterOpt>>,
    pub r_paren: Box<RParen>,
}

///
/// Type derived for non-terminal WithParameterItem
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct WithParameterItem {
    pub with_parameter_item_group: Box<WithParameterItemGroup>,
    pub identifier: Box<Identifier>,
    pub colon: Box<Colon>,
    pub r#type: Box<Type>,
    pub equ: Box<Equ>,
    pub expression: Box<Expression>,
}

///
/// Type derived for non-terminal WithParameterItemGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum WithParameterItemGroup {
    WithParameterItemGroup0(WithParameterItemGroup0),
    WithParameterItemGroup1(WithParameterItemGroup1),
}

///
/// Type derived for non-terminal WithParameterList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct WithParameterList {
    pub with_parameter_item: Box<WithParameterItem>,
    pub with_parameter_list_list: Vec<WithParameterListList>,
    pub with_parameter_list_opt: Option<Box<WithParameterListOpt>>,
}

///
/// Type derived for non-terminal WithParameterListList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct WithParameterListList {
    pub comma: Box<Comma>,
    pub with_parameter_item: Box<WithParameterItem>,
}

///
/// Type derived for non-terminal WithParameterListOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct WithParameterListOpt {
    pub comma: Box<Comma>,
}

///
/// Type derived for non-terminal WithParameterOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct WithParameterOpt {
    pub with_parameter_list: Box<WithParameterList>,
}

// -------------------------------------------------------------------------------------------------

///
/// Deduced ASTType of expanded grammar
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ASTType {
    AlwaysComb(AlwaysComb),
    AlwaysCombDeclaration(AlwaysCombDeclaration),
    AlwaysCombDeclarationList(Vec<AlwaysCombDeclarationList>),
    AlwaysCombToken(AlwaysCombToken),
    AlwaysFf(AlwaysFf),
    AlwaysFfCondition(AlwaysFfCondition),
    AlwaysFfConditionGroup(AlwaysFfConditionGroup),
    AlwaysFfConditions(AlwaysFfConditions),
    AlwaysFfConditionsList(Vec<AlwaysFfConditionsList>),
    AlwaysFfConditionsOpt(Option<Box<AlwaysFfConditionsOpt>>),
    AlwaysFfDeclaration(AlwaysFfDeclaration),
    AlwaysFfDeclarationList(Vec<AlwaysFfDeclarationList>),
    AlwaysFfToken(AlwaysFfToken),
    AssignmentStatement(AssignmentStatement),
    BaseLess(BaseLess),
    BaseLessToken(BaseLessToken),
    BasedBinary(BasedBinary),
    BasedBinaryToken(BasedBinaryToken),
    BasedDecimal(BasedDecimal),
    BasedDecimalToken(BasedDecimalToken),
    BasedHex(BasedHex),
    BasedHexToken(BasedHexToken),
    BasedOctal(BasedOctal),
    BasedOctalToken(BasedOctalToken),
    Bit(Bit),
    BitToken(BitToken),
    BlockComment(BlockComment),
    BuiltinType(BuiltinType),
    Colon(Colon),
    ColonToken(ColonToken),
    Comma(Comma),
    CommaToken(CommaToken),
    Comment(Comment),
    CommentOpt(Option<Box<CommentOpt>>),
    CommentOptGroup(CommentOptGroup),
    Comments(Comments),
    CommentsList(Vec<CommentsList>),
    CommentsListGroup(CommentsListGroup),
    Description(Description),
    Direction(Direction),
    Else(Else),
    ElseToken(ElseToken),
    Equ(Equ),
    EquToken(EquToken),
    Expression(Expression),
    Expression0(Expression0),
    Expression0List(Vec<Expression0List>),
    Expression1(Expression1),
    Expression1List(Vec<Expression1List>),
    Expression2(Expression2),
    F32(F32),
    F32Token(F32Token),
    F64(F64),
    F64Token(F64Token),
    Factor(Factor),
    FactorList(Vec<FactorList>),
    Hash(Hash),
    HashToken(HashToken),
    I32(I32),
    I32Token(I32Token),
    I64(I64),
    I64Token(I64Token),
    Identifier(Identifier),
    IdentifierToken(IdentifierToken),
    If(If),
    IfStatement(IfStatement),
    IfStatementList(Vec<IfStatementList>),
    IfStatementOpt(Option<Box<IfStatementOpt>>),
    IfToken(IfToken),
    Inout(Inout),
    InoutToken(InoutToken),
    Input(Input),
    InputToken(InputToken),
    IntegralNumber(IntegralNumber),
    Interface(Interface),
    InterfaceDeclaration(InterfaceDeclaration),
    InterfaceDeclarationList(Vec<InterfaceDeclarationList>),
    InterfaceDeclarationOpt(Option<Box<InterfaceDeclarationOpt>>),
    InterfaceItem(InterfaceItem),
    InterfaceToken(InterfaceToken),
    LBrace(LBrace),
    LBraceToken(LBraceToken),
    LBracket(LBracket),
    LBracketToken(LBracketToken),
    LParen(LParen),
    LParenToken(LParenToken),
    LineComment(LineComment),
    Localparam(Localparam),
    LocalparamDeclaration(LocalparamDeclaration),
    LocalparamToken(LocalparamToken),
    Logic(Logic),
    LogicToken(LogicToken),
    Minus(Minus),
    MinusToken(MinusToken),
    Modport(Modport),
    ModportDeclaration(ModportDeclaration),
    ModportItem(ModportItem),
    ModportList(ModportList),
    ModportListList(Vec<ModportListList>),
    ModportListOpt(Option<Box<ModportListOpt>>),
    ModportToken(ModportToken),
    Module(Module),
    ModuleDeclaration(ModuleDeclaration),
    ModuleDeclarationList(Vec<ModuleDeclarationList>),
    ModuleDeclarationOpt(Option<Box<ModuleDeclarationOpt>>),
    ModuleDeclarationOpt0(Option<Box<ModuleDeclarationOpt0>>),
    ModuleItem(ModuleItem),
    ModulePort(ModulePort),
    ModulePortItem(ModulePortItem),
    ModulePortList(ModulePortList),
    ModulePortListList(Vec<ModulePortListList>),
    ModulePortListOpt(Option<Box<ModulePortListOpt>>),
    ModulePortOpt(Option<Box<ModulePortOpt>>),
    ModuleToken(ModuleToken),
    Negedge(Negedge),
    NegedgeToken(NegedgeToken),
    Number(Number),
    OperatorPrecedence1(OperatorPrecedence1),
    OperatorPrecedence2(OperatorPrecedence2),
    Output(Output),
    OutputToken(OutputToken),
    Parameter(Parameter),
    ParameterDeclaration(ParameterDeclaration),
    ParameterToken(ParameterToken),
    Plus(Plus),
    PlusToken(PlusToken),
    Posedge(Posedge),
    PosedgeToken(PosedgeToken),
    RBrace(RBrace),
    RBraceToken(RBraceToken),
    RBracket(RBracket),
    RBracketToken(RBracketToken),
    RParen(RParen),
    RParenToken(RParenToken),
    Range(Range),
    RangeOpt(Option<Box<RangeOpt>>),
    Semicolon(Semicolon),
    SemicolonToken(SemicolonToken),
    Slash(Slash),
    SlashToken(SlashToken),
    Star(Star),
    StarToken(StarToken),
    Start(Start),
    StartToken(StartToken),
    Statement(Statement),
    Type(Type),
    TypeGroup(TypeGroup),
    TypeList(Vec<TypeList>),
    U32(U32),
    U32Token(U32Token),
    U64(U64),
    U64Token(U64Token),
    VariableDeclaration(VariableDeclaration),
    Veryl(Veryl),
    VerylList(Vec<VerylList>),
    Width(Width),
    WithParameter(WithParameter),
    WithParameterItem(WithParameterItem),
    WithParameterItemGroup(WithParameterItemGroup),
    WithParameterList(WithParameterList),
    WithParameterListList(Vec<WithParameterListList>),
    WithParameterListOpt(Option<Box<WithParameterListOpt>>),
    WithParameterOpt(Option<Box<WithParameterOpt>>),
}

/// Auto-implemented adapter grammar
///
/// The lifetime parameter `'t` refers to the lifetime of the scanned text.
/// The lifetime parameter `'u` refers to the lifetime of user grammar object.
///
#[allow(dead_code)]
pub struct VerylGrammarAuto<'t, 'u>
where
    't: 'u,
{
    // Mutable reference of the actual user grammar to be able to call the semantic actions on it
    user_grammar: &'u mut dyn VerylGrammarTrait,
    // Stack to construct the AST on it
    item_stack: Vec<ASTType>,
    // Just to hold the lifetime generated by parol
    phantom: PhantomData<&'t str>,
}

///
/// The `VerylGrammarAuto` impl is automatically generated for the
/// given grammar.
///
impl<'t, 'u> VerylGrammarAuto<'t, 'u> {
    pub fn new(user_grammar: &'u mut dyn VerylGrammarTrait) -> Self {
        Self {
            user_grammar,
            item_stack: Vec::new(),
            phantom: PhantomData::default(),
        }
    }

    #[allow(dead_code)]
    fn push(&mut self, item: ASTType, context: &str) {
        trace!("push    {}: {:?}", context, item);
        self.item_stack.push(item)
    }

    #[allow(dead_code)]
    fn pop(&mut self, context: &str) -> Option<ASTType> {
        if !self.item_stack.is_empty() {
            let item = self.item_stack.pop();
            if let Some(ref item) = item {
                trace!("pop     {}: {:?}", context, item);
            }
            item
        } else {
            None
        }
    }

    #[allow(dead_code)]
    // Use this function for debugging purposes:
    // trace!("{}", self.trace_item_stack(context));
    fn trace_item_stack(&self, context: &str) -> std::string::String {
        format!(
            "Item stack at {}:\n{}",
            context,
            self.item_stack
                .iter()
                .rev()
                .map(|s| format!("  {:?}", s))
                .collect::<Vec<std::string::String>>()
                .join("\n")
        )
    }

    /// Semantic action for production 0:
    ///
    /// LineComment: "//.*(:?\r\n|\r|\n|$)" : OwnedToken;
    ///
    #[parol_runtime::function_name::named]
    fn line_comment(
        &mut self,
        line_comment: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let line_comment = line_comment
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let line_comment_built = LineCommentBuilder::default()
            .line_comment(line_comment)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.line_comment(&line_comment_built)?;
        self.push(ASTType::LineComment(line_comment_built), context);
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// BlockComment: "(?ms)/\u{2a}.*?\u{2a}/" : OwnedToken;
    ///
    #[parol_runtime::function_name::named]
    fn block_comment(
        &mut self,
        block_comment: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let block_comment = block_comment
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let block_comment_built = BlockCommentBuilder::default()
            .block_comment(block_comment)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.block_comment(&block_comment_built)?;
        self.push(ASTType::BlockComment(block_comment_built), context);
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// Comments: CommentsList /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn comments(
        &mut self,
        _comments_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments_list = pop_and_reverse_item!(self, comments_list, CommentsList, context);
        let comments_built = CommentsBuilder::default()
            .comments_list(comments_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.comments(&comments_built)?;
        self.push(ASTType::Comments(comments_built), context);
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// CommentsList /* Vec<T>::Push */: CommentsListGroup CommentsList;
    ///
    #[parol_runtime::function_name::named]
    fn comments_list_0(
        &mut self,
        _comments_list_group: &ParseTreeStackEntry<'t>,
        _comments_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut comments_list = pop_item!(self, comments_list, CommentsList, context);
        let comments_list_group = pop_item!(self, comments_list_group, CommentsListGroup, context);
        let comments_list_0_built = CommentsListBuilder::default()
            .comments_list_group(Box::new(comments_list_group))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        comments_list.push(comments_list_0_built);
        self.push(ASTType::CommentsList(comments_list), context);
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// CommentsListGroup: LineComment;
    ///
    #[parol_runtime::function_name::named]
    fn comments_list_group_0(
        &mut self,
        _line_comment: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let line_comment = pop_item!(self, line_comment, LineComment, context);
        let comments_list_group_0_built = CommentsListGroup0Builder::default()
            .line_comment(Box::new(line_comment))
            .build()
            .into_diagnostic()?;
        let comments_list_group_0_built =
            CommentsListGroup::CommentsListGroup0(comments_list_group_0_built);
        self.push(
            ASTType::CommentsListGroup(comments_list_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// CommentsListGroup: BlockComment;
    ///
    #[parol_runtime::function_name::named]
    fn comments_list_group_1(
        &mut self,
        _block_comment: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let block_comment = pop_item!(self, block_comment, BlockComment, context);
        let comments_list_group_1_built = CommentsListGroup1Builder::default()
            .block_comment(Box::new(block_comment))
            .build()
            .into_diagnostic()?;
        let comments_list_group_1_built =
            CommentsListGroup::CommentsListGroup1(comments_list_group_1_built);
        self.push(
            ASTType::CommentsListGroup(comments_list_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 6:
    ///
    /// CommentsList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn comments_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments_list_1_built = Vec::new();
        self.push(ASTType::CommentsList(comments_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 7:
    ///
    /// Comment: CommentOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn comment(
        &mut self,
        _comment_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comment_opt = pop_item!(self, comment_opt, CommentOpt, context);
        let comment_built = CommentBuilder::default()
            .comment_opt(comment_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.comment(&comment_built)?;
        self.push(ASTType::Comment(comment_built), context);
        Ok(())
    }

    /// Semantic action for production 8:
    ///
    /// CommentOpt /* Option<T>::Some */: CommentOptGroup;
    ///
    #[parol_runtime::function_name::named]
    fn comment_opt_0(
        &mut self,
        _comment_opt_group: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comment_opt_group = pop_item!(self, comment_opt_group, CommentOptGroup, context);
        let comment_opt_0_built = CommentOptBuilder::default()
            .comment_opt_group(Box::new(comment_opt_group))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::CommentOpt(Some(Box::new(comment_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 9:
    ///
    /// CommentOptGroup: LineComment;
    ///
    #[parol_runtime::function_name::named]
    fn comment_opt_group_0(
        &mut self,
        _line_comment: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let line_comment = pop_item!(self, line_comment, LineComment, context);
        let comment_opt_group_0_built = CommentOptGroup0Builder::default()
            .line_comment(Box::new(line_comment))
            .build()
            .into_diagnostic()?;
        let comment_opt_group_0_built =
            CommentOptGroup::CommentOptGroup0(comment_opt_group_0_built);
        self.push(ASTType::CommentOptGroup(comment_opt_group_0_built), context);
        Ok(())
    }

    /// Semantic action for production 10:
    ///
    /// CommentOptGroup: BlockComment;
    ///
    #[parol_runtime::function_name::named]
    fn comment_opt_group_1(
        &mut self,
        _block_comment: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let block_comment = pop_item!(self, block_comment, BlockComment, context);
        let comment_opt_group_1_built = CommentOptGroup1Builder::default()
            .block_comment(Box::new(block_comment))
            .build()
            .into_diagnostic()?;
        let comment_opt_group_1_built =
            CommentOptGroup::CommentOptGroup1(comment_opt_group_1_built);
        self.push(ASTType::CommentOptGroup(comment_opt_group_1_built), context);
        Ok(())
    }

    /// Semantic action for production 11:
    ///
    /// CommentOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn comment_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::CommentOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 12:
    ///
    /// StartToken: Comments;
    ///
    #[parol_runtime::function_name::named]
    fn start_token(
        &mut self,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let start_token_built = StartTokenBuilder::default()
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.start_token(&start_token_built)?;
        self.push(ASTType::StartToken(start_token_built), context);
        Ok(())
    }

    /// Semantic action for production 13:
    ///
    /// Start: StartToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn start(
        &mut self,
        _start_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let start_token = pop_item!(self, start_token, StartToken, context);
        let start_built = StartBuilder::default()
            .start_token((&start_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.start(&start_built)?;
        self.push(ASTType::Start(start_built), context);
        Ok(())
    }

    /// Semantic action for production 14:
    ///
    /// BasedBinaryToken: /[0-9]+(?:_[0-9]+)*'b[0-1xzXZ]+(?:_[0-1xzXZ]+)*/ : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn based_binary_token(
        &mut self,
        l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_tick_b_l_bracket0_minus1xz_x_z_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus1xz_x_z_r_bracket_plus_r_paren_star: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_tick_b_l_bracket0_minus1xz_x_z_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus1xz_x_z_r_bracket_plus_r_paren_star = l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_tick_b_l_bracket0_minus1xz_x_z_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus1xz_x_z_r_bracket_plus_r_paren_star.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let based_binary_token_built = BasedBinaryTokenBuilder::default()
            .l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_tick_b_l_bracket0_minus1xz_x_z_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus1xz_x_z_r_bracket_plus_r_paren_star(l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_tick_b_l_bracket0_minus1xz_x_z_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus1xz_x_z_r_bracket_plus_r_paren_star)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .based_binary_token(&based_binary_token_built)?;
        self.push(ASTType::BasedBinaryToken(based_binary_token_built), context);
        Ok(())
    }

    /// Semantic action for production 15:
    ///
    /// BasedOctalToken: /[0-9]+(?:_[0-9]+)*'o[0-7xzXZ]+(?:_[0-7xzXZ]+)*/ : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn based_octal_token(
        &mut self,
        l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_tick_o_l_bracket0_minus7xz_x_z_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus7xz_x_z_r_bracket_plus_r_paren_star: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_tick_o_l_bracket0_minus7xz_x_z_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus7xz_x_z_r_bracket_plus_r_paren_star = l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_tick_o_l_bracket0_minus7xz_x_z_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus7xz_x_z_r_bracket_plus_r_paren_star.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let based_octal_token_built = BasedOctalTokenBuilder::default()
            .l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_tick_o_l_bracket0_minus7xz_x_z_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus7xz_x_z_r_bracket_plus_r_paren_star(l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_tick_o_l_bracket0_minus7xz_x_z_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus7xz_x_z_r_bracket_plus_r_paren_star)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .based_octal_token(&based_octal_token_built)?;
        self.push(ASTType::BasedOctalToken(based_octal_token_built), context);
        Ok(())
    }

    /// Semantic action for production 16:
    ///
    /// BasedDecimalToken: /[0-9]+(?:_[0-9]+)*'d[0-9]+(?:_[0-9]+)*/ : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn based_decimal_token(
        &mut self,
        l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_tick_d_l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_tick_d_l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star = l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_tick_d_l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let based_decimal_token_built = BasedDecimalTokenBuilder::default()
            .l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_tick_d_l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star(l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_tick_d_l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .based_decimal_token(&based_decimal_token_built)?;
        self.push(
            ASTType::BasedDecimalToken(based_decimal_token_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 17:
    ///
    /// BasedHexToken: /[0-9]+(?:_[0-9]+)*'h[0-9a-fA-FxzXZ]+(?:_[0-9a-fA-FxzXZ]+)*/ : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn based_hex_token(
        &mut self,
        l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_tick_h_l_bracket0_minus9a_minus_f_a_minus_fxz_x_z_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9a_minus_f_a_minus_fxz_x_z_r_bracket_plus_r_paren_star: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_tick_h_l_bracket0_minus9a_minus_f_a_minus_fxz_x_z_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9a_minus_f_a_minus_fxz_x_z_r_bracket_plus_r_paren_star = l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_tick_h_l_bracket0_minus9a_minus_f_a_minus_fxz_x_z_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9a_minus_f_a_minus_fxz_x_z_r_bracket_plus_r_paren_star.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let based_hex_token_built = BasedHexTokenBuilder::default()
            .l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_tick_h_l_bracket0_minus9a_minus_f_a_minus_fxz_x_z_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9a_minus_f_a_minus_fxz_x_z_r_bracket_plus_r_paren_star(l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_tick_h_l_bracket0_minus9a_minus_f_a_minus_fxz_x_z_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9a_minus_f_a_minus_fxz_x_z_r_bracket_plus_r_paren_star)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.based_hex_token(&based_hex_token_built)?;
        self.push(ASTType::BasedHexToken(based_hex_token_built), context);
        Ok(())
    }

    /// Semantic action for production 18:
    ///
    /// BaseLessToken: /[0-9]+(?:_[0-9]+)*/ : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn base_less_token(
        &mut self,
        l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star = l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let base_less_token_built = BaseLessTokenBuilder::default()
            .l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star(l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.base_less_token(&base_less_token_built)?;
        self.push(ASTType::BaseLessToken(base_less_token_built), context);
        Ok(())
    }

    /// Semantic action for production 19:
    ///
    /// BasedBinary: BasedBinaryToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn based_binary(
        &mut self,
        _based_binary_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let based_binary_token = pop_item!(self, based_binary_token, BasedBinaryToken, context);
        let based_binary_built = BasedBinaryBuilder::default()
            .based_binary_token((&based_binary_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.based_binary(&based_binary_built)?;
        self.push(ASTType::BasedBinary(based_binary_built), context);
        Ok(())
    }

    /// Semantic action for production 20:
    ///
    /// BasedOctal: BasedOctalToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn based_octal(
        &mut self,
        _based_octal_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let based_octal_token = pop_item!(self, based_octal_token, BasedOctalToken, context);
        let based_octal_built = BasedOctalBuilder::default()
            .based_octal_token((&based_octal_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.based_octal(&based_octal_built)?;
        self.push(ASTType::BasedOctal(based_octal_built), context);
        Ok(())
    }

    /// Semantic action for production 21:
    ///
    /// BasedDecimal: BasedDecimalToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn based_decimal(
        &mut self,
        _based_decimal_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let based_decimal_token = pop_item!(self, based_decimal_token, BasedDecimalToken, context);
        let based_decimal_built = BasedDecimalBuilder::default()
            .based_decimal_token((&based_decimal_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.based_decimal(&based_decimal_built)?;
        self.push(ASTType::BasedDecimal(based_decimal_built), context);
        Ok(())
    }

    /// Semantic action for production 22:
    ///
    /// BasedHex: BasedHexToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn based_hex(
        &mut self,
        _based_hex_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let based_hex_token = pop_item!(self, based_hex_token, BasedHexToken, context);
        let based_hex_built = BasedHexBuilder::default()
            .based_hex_token((&based_hex_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.based_hex(&based_hex_built)?;
        self.push(ASTType::BasedHex(based_hex_built), context);
        Ok(())
    }

    /// Semantic action for production 23:
    ///
    /// BaseLess: BaseLessToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn base_less(
        &mut self,
        _base_less_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let base_less_token = pop_item!(self, base_less_token, BaseLessToken, context);
        let base_less_built = BaseLessBuilder::default()
            .base_less_token((&base_less_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.base_less(&base_less_built)?;
        self.push(ASTType::BaseLess(base_less_built), context);
        Ok(())
    }

    /// Semantic action for production 24:
    ///
    /// PlusToken: '+' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn plus_token(
        &mut self,
        plus: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let plus = plus.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let plus_token_built = PlusTokenBuilder::default()
            .plus(plus)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.plus_token(&plus_token_built)?;
        self.push(ASTType::PlusToken(plus_token_built), context);
        Ok(())
    }

    /// Semantic action for production 25:
    ///
    /// MinusToken: '-' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn minus_token(
        &mut self,
        minus: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let minus = minus.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let minus_token_built = MinusTokenBuilder::default()
            .minus(minus)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.minus_token(&minus_token_built)?;
        self.push(ASTType::MinusToken(minus_token_built), context);
        Ok(())
    }

    /// Semantic action for production 26:
    ///
    /// StarToken: '*' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn star_token(
        &mut self,
        star: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let star = star.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let star_token_built = StarTokenBuilder::default()
            .star(star)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.star_token(&star_token_built)?;
        self.push(ASTType::StarToken(star_token_built), context);
        Ok(())
    }

    /// Semantic action for production 27:
    ///
    /// SlashToken: '/' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn slash_token(
        &mut self,
        slash: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let slash = slash.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let slash_token_built = SlashTokenBuilder::default()
            .slash(slash)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.slash_token(&slash_token_built)?;
        self.push(ASTType::SlashToken(slash_token_built), context);
        Ok(())
    }

    /// Semantic action for production 28:
    ///
    /// ColonToken: ':' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn colon_token(
        &mut self,
        colon: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let colon = colon.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let colon_token_built = ColonTokenBuilder::default()
            .colon(colon)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.colon_token(&colon_token_built)?;
        self.push(ASTType::ColonToken(colon_token_built), context);
        Ok(())
    }

    /// Semantic action for production 29:
    ///
    /// SemicolonToken: ';' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn semicolon_token(
        &mut self,
        semicolon: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon = semicolon.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let semicolon_token_built = SemicolonTokenBuilder::default()
            .semicolon(semicolon)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.semicolon_token(&semicolon_token_built)?;
        self.push(ASTType::SemicolonToken(semicolon_token_built), context);
        Ok(())
    }

    /// Semantic action for production 30:
    ///
    /// CommaToken: ',' : OwnedToken Comment;
    ///
    #[parol_runtime::function_name::named]
    fn comma_token(
        &mut self,
        comma: &ParseTreeStackEntry<'t>,
        _comment: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = comma.token(parse_tree)?.try_into().into_diagnostic()?;
        let comment = pop_item!(self, comment, Comment, context);
        let comma_token_built = CommaTokenBuilder::default()
            .comma(comma)
            .comment(Box::new(comment))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.comma_token(&comma_token_built)?;
        self.push(ASTType::CommaToken(comma_token_built), context);
        Ok(())
    }

    /// Semantic action for production 31:
    ///
    /// LParenToken: '(' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn l_paren_token(
        &mut self,
        l_paren: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_paren = l_paren.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let l_paren_token_built = LParenTokenBuilder::default()
            .l_paren(l_paren)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.l_paren_token(&l_paren_token_built)?;
        self.push(ASTType::LParenToken(l_paren_token_built), context);
        Ok(())
    }

    /// Semantic action for production 32:
    ///
    /// RParenToken: ')' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn r_paren_token(
        &mut self,
        r_paren: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren = r_paren.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let r_paren_token_built = RParenTokenBuilder::default()
            .r_paren(r_paren)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.r_paren_token(&r_paren_token_built)?;
        self.push(ASTType::RParenToken(r_paren_token_built), context);
        Ok(())
    }

    /// Semantic action for production 33:
    ///
    /// LBracketToken: '[' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn l_bracket_token(
        &mut self,
        l_bracket: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_bracket = l_bracket.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let l_bracket_token_built = LBracketTokenBuilder::default()
            .l_bracket(l_bracket)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.l_bracket_token(&l_bracket_token_built)?;
        self.push(ASTType::LBracketToken(l_bracket_token_built), context);
        Ok(())
    }

    /// Semantic action for production 34:
    ///
    /// RBracketToken: ']' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn r_bracket_token(
        &mut self,
        r_bracket: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_bracket = r_bracket.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let r_bracket_token_built = RBracketTokenBuilder::default()
            .r_bracket(r_bracket)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.r_bracket_token(&r_bracket_token_built)?;
        self.push(ASTType::RBracketToken(r_bracket_token_built), context);
        Ok(())
    }

    /// Semantic action for production 35:
    ///
    /// LBraceToken: '{' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn l_brace_token(
        &mut self,
        l_brace: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_brace = l_brace.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let l_brace_token_built = LBraceTokenBuilder::default()
            .l_brace(l_brace)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.l_brace_token(&l_brace_token_built)?;
        self.push(ASTType::LBraceToken(l_brace_token_built), context);
        Ok(())
    }

    /// Semantic action for production 36:
    ///
    /// RBraceToken: '}' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn r_brace_token(
        &mut self,
        r_brace: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = r_brace.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let r_brace_token_built = RBraceTokenBuilder::default()
            .r_brace(r_brace)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.r_brace_token(&r_brace_token_built)?;
        self.push(ASTType::RBraceToken(r_brace_token_built), context);
        Ok(())
    }

    /// Semantic action for production 37:
    ///
    /// EquToken: '=' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn equ_token(
        &mut self,
        equ: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let equ = equ.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let equ_token_built = EquTokenBuilder::default()
            .equ(equ)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.equ_token(&equ_token_built)?;
        self.push(ASTType::EquToken(equ_token_built), context);
        Ok(())
    }

    /// Semantic action for production 38:
    ///
    /// HashToken: '#' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn hash_token(
        &mut self,
        hash: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let hash = hash.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let hash_token_built = HashTokenBuilder::default()
            .hash(hash)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.hash_token(&hash_token_built)?;
        self.push(ASTType::HashToken(hash_token_built), context);
        Ok(())
    }

    /// Semantic action for production 39:
    ///
    /// Plus: PlusToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn plus(
        &mut self,
        _plus_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let plus_token = pop_item!(self, plus_token, PlusToken, context);
        let plus_built = PlusBuilder::default()
            .plus_token((&plus_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.plus(&plus_built)?;
        self.push(ASTType::Plus(plus_built), context);
        Ok(())
    }

    /// Semantic action for production 40:
    ///
    /// Minus: MinusToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn minus(
        &mut self,
        _minus_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let minus_token = pop_item!(self, minus_token, MinusToken, context);
        let minus_built = MinusBuilder::default()
            .minus_token((&minus_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.minus(&minus_built)?;
        self.push(ASTType::Minus(minus_built), context);
        Ok(())
    }

    /// Semantic action for production 41:
    ///
    /// Star: StarToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn star(
        &mut self,
        _star_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let star_token = pop_item!(self, star_token, StarToken, context);
        let star_built = StarBuilder::default()
            .star_token((&star_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.star(&star_built)?;
        self.push(ASTType::Star(star_built), context);
        Ok(())
    }

    /// Semantic action for production 42:
    ///
    /// Slash: SlashToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn slash(
        &mut self,
        _slash_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let slash_token = pop_item!(self, slash_token, SlashToken, context);
        let slash_built = SlashBuilder::default()
            .slash_token((&slash_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.slash(&slash_built)?;
        self.push(ASTType::Slash(slash_built), context);
        Ok(())
    }

    /// Semantic action for production 43:
    ///
    /// Colon: ColonToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn colon(
        &mut self,
        _colon_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let colon_token = pop_item!(self, colon_token, ColonToken, context);
        let colon_built = ColonBuilder::default()
            .colon_token((&colon_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.colon(&colon_built)?;
        self.push(ASTType::Colon(colon_built), context);
        Ok(())
    }

    /// Semantic action for production 44:
    ///
    /// Semicolon: SemicolonToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn semicolon(
        &mut self,
        _semicolon_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon_token = pop_item!(self, semicolon_token, SemicolonToken, context);
        let semicolon_built = SemicolonBuilder::default()
            .semicolon_token((&semicolon_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.semicolon(&semicolon_built)?;
        self.push(ASTType::Semicolon(semicolon_built), context);
        Ok(())
    }

    /// Semantic action for production 45:
    ///
    /// Comma: CommaToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn comma(
        &mut self,
        _comma_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma_token = pop_item!(self, comma_token, CommaToken, context);
        let comma_built = CommaBuilder::default()
            .comma_token((&comma_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.comma(&comma_built)?;
        self.push(ASTType::Comma(comma_built), context);
        Ok(())
    }

    /// Semantic action for production 46:
    ///
    /// LParen: LParenToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn l_paren(
        &mut self,
        _l_paren_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_paren_token = pop_item!(self, l_paren_token, LParenToken, context);
        let l_paren_built = LParenBuilder::default()
            .l_paren_token((&l_paren_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.l_paren(&l_paren_built)?;
        self.push(ASTType::LParen(l_paren_built), context);
        Ok(())
    }

    /// Semantic action for production 47:
    ///
    /// RParen: RParenToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn r_paren(
        &mut self,
        _r_paren_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren_token = pop_item!(self, r_paren_token, RParenToken, context);
        let r_paren_built = RParenBuilder::default()
            .r_paren_token((&r_paren_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.r_paren(&r_paren_built)?;
        self.push(ASTType::RParen(r_paren_built), context);
        Ok(())
    }

    /// Semantic action for production 48:
    ///
    /// LBracket: LBracketToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn l_bracket(
        &mut self,
        _l_bracket_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_bracket_token = pop_item!(self, l_bracket_token, LBracketToken, context);
        let l_bracket_built = LBracketBuilder::default()
            .l_bracket_token((&l_bracket_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.l_bracket(&l_bracket_built)?;
        self.push(ASTType::LBracket(l_bracket_built), context);
        Ok(())
    }

    /// Semantic action for production 49:
    ///
    /// RBracket: RBracketToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn r_bracket(
        &mut self,
        _r_bracket_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_bracket_token = pop_item!(self, r_bracket_token, RBracketToken, context);
        let r_bracket_built = RBracketBuilder::default()
            .r_bracket_token((&r_bracket_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.r_bracket(&r_bracket_built)?;
        self.push(ASTType::RBracket(r_bracket_built), context);
        Ok(())
    }

    /// Semantic action for production 50:
    ///
    /// LBrace: LBraceToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn l_brace(
        &mut self,
        _l_brace_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_brace_token = pop_item!(self, l_brace_token, LBraceToken, context);
        let l_brace_built = LBraceBuilder::default()
            .l_brace_token((&l_brace_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.l_brace(&l_brace_built)?;
        self.push(ASTType::LBrace(l_brace_built), context);
        Ok(())
    }

    /// Semantic action for production 51:
    ///
    /// RBrace: RBraceToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn r_brace(
        &mut self,
        _r_brace_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace_token = pop_item!(self, r_brace_token, RBraceToken, context);
        let r_brace_built = RBraceBuilder::default()
            .r_brace_token((&r_brace_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.r_brace(&r_brace_built)?;
        self.push(ASTType::RBrace(r_brace_built), context);
        Ok(())
    }

    /// Semantic action for production 52:
    ///
    /// Equ: EquToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn equ(
        &mut self,
        _equ_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let equ_token = pop_item!(self, equ_token, EquToken, context);
        let equ_built = EquBuilder::default()
            .equ_token((&equ_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.equ(&equ_built)?;
        self.push(ASTType::Equ(equ_built), context);
        Ok(())
    }

    /// Semantic action for production 53:
    ///
    /// Hash: HashToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn hash(
        &mut self,
        _hash_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let hash_token = pop_item!(self, hash_token, HashToken, context);
        let hash_built = HashBuilder::default()
            .hash_token((&hash_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.hash(&hash_built)?;
        self.push(ASTType::Hash(hash_built), context);
        Ok(())
    }

    /// Semantic action for production 54:
    ///
    /// LogicToken: 'logic' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn logic_token(
        &mut self,
        logic: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logic = logic.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let logic_token_built = LogicTokenBuilder::default()
            .logic(logic)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.logic_token(&logic_token_built)?;
        self.push(ASTType::LogicToken(logic_token_built), context);
        Ok(())
    }

    /// Semantic action for production 55:
    ///
    /// BitToken: 'bit' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn bit_token(
        &mut self,
        bit: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bit = bit.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let bit_token_built = BitTokenBuilder::default()
            .bit(bit)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.bit_token(&bit_token_built)?;
        self.push(ASTType::BitToken(bit_token_built), context);
        Ok(())
    }

    /// Semantic action for production 56:
    ///
    /// AlwaysFfToken: 'always_ff' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_token(
        &mut self,
        always_underscore_ff: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let always_underscore_ff = always_underscore_ff
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let always_ff_token_built = AlwaysFfTokenBuilder::default()
            .always_underscore_ff(always_underscore_ff)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.always_ff_token(&always_ff_token_built)?;
        self.push(ASTType::AlwaysFfToken(always_ff_token_built), context);
        Ok(())
    }

    /// Semantic action for production 57:
    ///
    /// AlwaysCombToken: 'always_comb' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn always_comb_token(
        &mut self,
        always_underscore_comb: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let always_underscore_comb = always_underscore_comb
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let always_comb_token_built = AlwaysCombTokenBuilder::default()
            .always_underscore_comb(always_underscore_comb)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .always_comb_token(&always_comb_token_built)?;
        self.push(ASTType::AlwaysCombToken(always_comb_token_built), context);
        Ok(())
    }

    /// Semantic action for production 58:
    ///
    /// PosedgeToken: 'posedge' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn posedge_token(
        &mut self,
        posedge: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let posedge = posedge.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let posedge_token_built = PosedgeTokenBuilder::default()
            .posedge(posedge)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.posedge_token(&posedge_token_built)?;
        self.push(ASTType::PosedgeToken(posedge_token_built), context);
        Ok(())
    }

    /// Semantic action for production 59:
    ///
    /// NegedgeToken: 'negedge' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn negedge_token(
        &mut self,
        negedge: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let negedge = negedge.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let negedge_token_built = NegedgeTokenBuilder::default()
            .negedge(negedge)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.negedge_token(&negedge_token_built)?;
        self.push(ASTType::NegedgeToken(negedge_token_built), context);
        Ok(())
    }

    /// Semantic action for production 60:
    ///
    /// IfToken: 'if' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn if_token(
        &mut self,
        r#if: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#if = r#if.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let if_token_built = IfTokenBuilder::default()
            .r#if(r#if)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.if_token(&if_token_built)?;
        self.push(ASTType::IfToken(if_token_built), context);
        Ok(())
    }

    /// Semantic action for production 61:
    ///
    /// ElseToken: 'else' : OwnedToken Comment;
    ///
    #[parol_runtime::function_name::named]
    fn else_token(
        &mut self,
        r#else: &ParseTreeStackEntry<'t>,
        _comment: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#else = r#else.token(parse_tree)?.try_into().into_diagnostic()?;
        let comment = pop_item!(self, comment, Comment, context);
        let else_token_built = ElseTokenBuilder::default()
            .r#else(r#else)
            .comment(Box::new(comment))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.else_token(&else_token_built)?;
        self.push(ASTType::ElseToken(else_token_built), context);
        Ok(())
    }

    /// Semantic action for production 62:
    ///
    /// ParameterToken: 'parameter' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn parameter_token(
        &mut self,
        parameter: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let parameter = parameter.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let parameter_token_built = ParameterTokenBuilder::default()
            .parameter(parameter)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.parameter_token(&parameter_token_built)?;
        self.push(ASTType::ParameterToken(parameter_token_built), context);
        Ok(())
    }

    /// Semantic action for production 63:
    ///
    /// LocalparamToken: 'localparam' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn localparam_token(
        &mut self,
        localparam: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let localparam = localparam.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let localparam_token_built = LocalparamTokenBuilder::default()
            .localparam(localparam)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .localparam_token(&localparam_token_built)?;
        self.push(ASTType::LocalparamToken(localparam_token_built), context);
        Ok(())
    }

    /// Semantic action for production 64:
    ///
    /// ModuleToken: 'module' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn module_token(
        &mut self,
        module: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module = module.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let module_token_built = ModuleTokenBuilder::default()
            .module(module)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.module_token(&module_token_built)?;
        self.push(ASTType::ModuleToken(module_token_built), context);
        Ok(())
    }

    /// Semantic action for production 65:
    ///
    /// InterfaceToken: 'interface' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn interface_token(
        &mut self,
        interface: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let interface = interface.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let interface_token_built = InterfaceTokenBuilder::default()
            .interface(interface)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.interface_token(&interface_token_built)?;
        self.push(ASTType::InterfaceToken(interface_token_built), context);
        Ok(())
    }

    /// Semantic action for production 66:
    ///
    /// InputToken: 'input' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn input_token(
        &mut self,
        input: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let input = input.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let input_token_built = InputTokenBuilder::default()
            .input(input)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.input_token(&input_token_built)?;
        self.push(ASTType::InputToken(input_token_built), context);
        Ok(())
    }

    /// Semantic action for production 67:
    ///
    /// OutputToken: 'output' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn output_token(
        &mut self,
        output: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let output = output.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let output_token_built = OutputTokenBuilder::default()
            .output(output)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.output_token(&output_token_built)?;
        self.push(ASTType::OutputToken(output_token_built), context);
        Ok(())
    }

    /// Semantic action for production 68:
    ///
    /// InoutToken: 'inout' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn inout_token(
        &mut self,
        inout: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inout = inout.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let inout_token_built = InoutTokenBuilder::default()
            .inout(inout)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.inout_token(&inout_token_built)?;
        self.push(ASTType::InoutToken(inout_token_built), context);
        Ok(())
    }

    /// Semantic action for production 69:
    ///
    /// ModportToken: 'modport' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn modport_token(
        &mut self,
        modport: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let modport = modport.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let modport_token_built = ModportTokenBuilder::default()
            .modport(modport)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.modport_token(&modport_token_built)?;
        self.push(ASTType::ModportToken(modport_token_built), context);
        Ok(())
    }

    /// Semantic action for production 70:
    ///
    /// U32Token: 'u32' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn u32_token(
        &mut self,
        u32: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let u32 = u32.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let u32_token_built = U32TokenBuilder::default()
            .u32(u32)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.u32_token(&u32_token_built)?;
        self.push(ASTType::U32Token(u32_token_built), context);
        Ok(())
    }

    /// Semantic action for production 71:
    ///
    /// U64Token: 'u64' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn u64_token(
        &mut self,
        u64: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let u64 = u64.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let u64_token_built = U64TokenBuilder::default()
            .u64(u64)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.u64_token(&u64_token_built)?;
        self.push(ASTType::U64Token(u64_token_built), context);
        Ok(())
    }

    /// Semantic action for production 72:
    ///
    /// I32Token: 'i32' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn i32_token(
        &mut self,
        i32: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let i32 = i32.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let i32_token_built = I32TokenBuilder::default()
            .i32(i32)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.i32_token(&i32_token_built)?;
        self.push(ASTType::I32Token(i32_token_built), context);
        Ok(())
    }

    /// Semantic action for production 73:
    ///
    /// I64Token: 'i64' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn i64_token(
        &mut self,
        i64: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let i64 = i64.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let i64_token_built = I64TokenBuilder::default()
            .i64(i64)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.i64_token(&i64_token_built)?;
        self.push(ASTType::I64Token(i64_token_built), context);
        Ok(())
    }

    /// Semantic action for production 74:
    ///
    /// F32Token: 'f32' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn f32_token(
        &mut self,
        f32: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let f32 = f32.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let f32_token_built = F32TokenBuilder::default()
            .f32(f32)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.f32_token(&f32_token_built)?;
        self.push(ASTType::F32Token(f32_token_built), context);
        Ok(())
    }

    /// Semantic action for production 75:
    ///
    /// F64Token: 'f64' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn f64_token(
        &mut self,
        f64: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let f64 = f64.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let f64_token_built = F64TokenBuilder::default()
            .f64(f64)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.f64_token(&f64_token_built)?;
        self.push(ASTType::F64Token(f64_token_built), context);
        Ok(())
    }

    /// Semantic action for production 76:
    ///
    /// Logic: LogicToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn logic(
        &mut self,
        _logic_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logic_token = pop_item!(self, logic_token, LogicToken, context);
        let logic_built = LogicBuilder::default()
            .logic_token((&logic_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.logic(&logic_built)?;
        self.push(ASTType::Logic(logic_built), context);
        Ok(())
    }

    /// Semantic action for production 77:
    ///
    /// Bit: BitToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn bit(
        &mut self,
        _bit_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bit_token = pop_item!(self, bit_token, BitToken, context);
        let bit_built = BitBuilder::default()
            .bit_token((&bit_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.bit(&bit_built)?;
        self.push(ASTType::Bit(bit_built), context);
        Ok(())
    }

    /// Semantic action for production 78:
    ///
    /// AlwaysFf: AlwaysFfToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff(
        &mut self,
        _always_ff_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let always_ff_token = pop_item!(self, always_ff_token, AlwaysFfToken, context);
        let always_ff_built = AlwaysFfBuilder::default()
            .always_ff_token((&always_ff_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.always_ff(&always_ff_built)?;
        self.push(ASTType::AlwaysFf(always_ff_built), context);
        Ok(())
    }

    /// Semantic action for production 79:
    ///
    /// AlwaysComb: AlwaysCombToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn always_comb(
        &mut self,
        _always_comb_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let always_comb_token = pop_item!(self, always_comb_token, AlwaysCombToken, context);
        let always_comb_built = AlwaysCombBuilder::default()
            .always_comb_token((&always_comb_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.always_comb(&always_comb_built)?;
        self.push(ASTType::AlwaysComb(always_comb_built), context);
        Ok(())
    }

    /// Semantic action for production 80:
    ///
    /// Posedge: PosedgeToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn posedge(
        &mut self,
        _posedge_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let posedge_token = pop_item!(self, posedge_token, PosedgeToken, context);
        let posedge_built = PosedgeBuilder::default()
            .posedge_token((&posedge_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.posedge(&posedge_built)?;
        self.push(ASTType::Posedge(posedge_built), context);
        Ok(())
    }

    /// Semantic action for production 81:
    ///
    /// Negedge: NegedgeToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn negedge(
        &mut self,
        _negedge_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let negedge_token = pop_item!(self, negedge_token, NegedgeToken, context);
        let negedge_built = NegedgeBuilder::default()
            .negedge_token((&negedge_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.negedge(&negedge_built)?;
        self.push(ASTType::Negedge(negedge_built), context);
        Ok(())
    }

    /// Semantic action for production 82:
    ///
    /// If: IfToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn r#if(
        &mut self,
        _if_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_token = pop_item!(self, if_token, IfToken, context);
        let r#if_built = IfBuilder::default()
            .if_token((&if_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.r#if(&r#if_built)?;
        self.push(ASTType::If(r#if_built), context);
        Ok(())
    }

    /// Semantic action for production 83:
    ///
    /// Else: ElseToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn r#else(
        &mut self,
        _else_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let else_token = pop_item!(self, else_token, ElseToken, context);
        let r#else_built = ElseBuilder::default()
            .else_token((&else_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.r#else(&r#else_built)?;
        self.push(ASTType::Else(r#else_built), context);
        Ok(())
    }

    /// Semantic action for production 84:
    ///
    /// Parameter: ParameterToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn parameter(
        &mut self,
        _parameter_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let parameter_token = pop_item!(self, parameter_token, ParameterToken, context);
        let parameter_built = ParameterBuilder::default()
            .parameter_token((&parameter_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.parameter(&parameter_built)?;
        self.push(ASTType::Parameter(parameter_built), context);
        Ok(())
    }

    /// Semantic action for production 85:
    ///
    /// Localparam: LocalparamToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn localparam(
        &mut self,
        _localparam_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let localparam_token = pop_item!(self, localparam_token, LocalparamToken, context);
        let localparam_built = LocalparamBuilder::default()
            .localparam_token((&localparam_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.localparam(&localparam_built)?;
        self.push(ASTType::Localparam(localparam_built), context);
        Ok(())
    }

    /// Semantic action for production 86:
    ///
    /// Module: ModuleToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn module(
        &mut self,
        _module_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module_token = pop_item!(self, module_token, ModuleToken, context);
        let module_built = ModuleBuilder::default()
            .module_token((&module_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.module(&module_built)?;
        self.push(ASTType::Module(module_built), context);
        Ok(())
    }

    /// Semantic action for production 87:
    ///
    /// Interface: InterfaceToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn interface(
        &mut self,
        _interface_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let interface_token = pop_item!(self, interface_token, InterfaceToken, context);
        let interface_built = InterfaceBuilder::default()
            .interface_token((&interface_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.interface(&interface_built)?;
        self.push(ASTType::Interface(interface_built), context);
        Ok(())
    }

    /// Semantic action for production 88:
    ///
    /// Input: InputToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn input(
        &mut self,
        _input_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let input_token = pop_item!(self, input_token, InputToken, context);
        let input_built = InputBuilder::default()
            .input_token((&input_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.input(&input_built)?;
        self.push(ASTType::Input(input_built), context);
        Ok(())
    }

    /// Semantic action for production 89:
    ///
    /// Output: OutputToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn output(
        &mut self,
        _output_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let output_token = pop_item!(self, output_token, OutputToken, context);
        let output_built = OutputBuilder::default()
            .output_token((&output_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.output(&output_built)?;
        self.push(ASTType::Output(output_built), context);
        Ok(())
    }

    /// Semantic action for production 90:
    ///
    /// Inout: InoutToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn inout(
        &mut self,
        _inout_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inout_token = pop_item!(self, inout_token, InoutToken, context);
        let inout_built = InoutBuilder::default()
            .inout_token((&inout_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.inout(&inout_built)?;
        self.push(ASTType::Inout(inout_built), context);
        Ok(())
    }

    /// Semantic action for production 91:
    ///
    /// Modport: ModportToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn modport(
        &mut self,
        _modport_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let modport_token = pop_item!(self, modport_token, ModportToken, context);
        let modport_built = ModportBuilder::default()
            .modport_token((&modport_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.modport(&modport_built)?;
        self.push(ASTType::Modport(modport_built), context);
        Ok(())
    }

    /// Semantic action for production 92:
    ///
    /// U32: U32Token : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn u32(
        &mut self,
        _u32_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let u32_token = pop_item!(self, u32_token, U32Token, context);
        let u32_built = U32Builder::default()
            .u32_token((&u32_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.u32(&u32_built)?;
        self.push(ASTType::U32(u32_built), context);
        Ok(())
    }

    /// Semantic action for production 93:
    ///
    /// U64: U64Token : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn u64(
        &mut self,
        _u64_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let u64_token = pop_item!(self, u64_token, U64Token, context);
        let u64_built = U64Builder::default()
            .u64_token((&u64_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.u64(&u64_built)?;
        self.push(ASTType::U64(u64_built), context);
        Ok(())
    }

    /// Semantic action for production 94:
    ///
    /// I32: I32Token : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn i32(
        &mut self,
        _i32_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let i32_token = pop_item!(self, i32_token, I32Token, context);
        let i32_built = I32Builder::default()
            .i32_token((&i32_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.i32(&i32_built)?;
        self.push(ASTType::I32(i32_built), context);
        Ok(())
    }

    /// Semantic action for production 95:
    ///
    /// I64: I64Token : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn i64(
        &mut self,
        _i64_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let i64_token = pop_item!(self, i64_token, I64Token, context);
        let i64_built = I64Builder::default()
            .i64_token((&i64_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.i64(&i64_built)?;
        self.push(ASTType::I64(i64_built), context);
        Ok(())
    }

    /// Semantic action for production 96:
    ///
    /// F32: F32Token : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn f32(
        &mut self,
        _f32_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let f32_token = pop_item!(self, f32_token, F32Token, context);
        let f32_built = F32Builder::default()
            .f32_token((&f32_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.f32(&f32_built)?;
        self.push(ASTType::F32(f32_built), context);
        Ok(())
    }

    /// Semantic action for production 97:
    ///
    /// F64: F64Token : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn f64(
        &mut self,
        _f64_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let f64_token = pop_item!(self, f64_token, F64Token, context);
        let f64_built = F64Builder::default()
            .f64_token((&f64_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.f64(&f64_built)?;
        self.push(ASTType::F64(f64_built), context);
        Ok(())
    }

    /// Semantic action for production 98:
    ///
    /// IdentifierToken: /[a-zA-Z_][0-9a-zA-Z_]*/ : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn identifier_token(
        &mut self,
        l_bracket_a_minus_z_a_minus_z_underscore_r_bracket_l_bracket0_minus9a_minus_z_a_minus_z_underscore_r_bracket_star: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_bracket_a_minus_z_a_minus_z_underscore_r_bracket_l_bracket0_minus9a_minus_z_a_minus_z_underscore_r_bracket_star = l_bracket_a_minus_z_a_minus_z_underscore_r_bracket_l_bracket0_minus9a_minus_z_a_minus_z_underscore_r_bracket_star.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let identifier_token_built = IdentifierTokenBuilder::default()
            .l_bracket_a_minus_z_a_minus_z_underscore_r_bracket_l_bracket0_minus9a_minus_z_a_minus_z_underscore_r_bracket_star(l_bracket_a_minus_z_a_minus_z_underscore_r_bracket_l_bracket0_minus9a_minus_z_a_minus_z_underscore_r_bracket_star)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .identifier_token(&identifier_token_built)?;
        self.push(ASTType::IdentifierToken(identifier_token_built), context);
        Ok(())
    }

    /// Semantic action for production 99:
    ///
    /// Identifier: IdentifierToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn identifier(
        &mut self,
        _identifier_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let identifier_token = pop_item!(self, identifier_token, IdentifierToken, context);
        let identifier_built = IdentifierBuilder::default()
            .identifier_token((&identifier_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.identifier(&identifier_built)?;
        self.push(ASTType::Identifier(identifier_built), context);
        Ok(())
    }

    /// Semantic action for production 100:
    ///
    /// Veryl: Start VerylList /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn veryl(
        &mut self,
        _start: &ParseTreeStackEntry<'t>,
        _veryl_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let veryl_list = pop_and_reverse_item!(self, veryl_list, VerylList, context);
        let start = pop_item!(self, start, Start, context);
        let veryl_built = VerylBuilder::default()
            .start(Box::new(start))
            .veryl_list(veryl_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.veryl(&veryl_built)?;
        self.push(ASTType::Veryl(veryl_built), context);
        Ok(())
    }

    /// Semantic action for production 101:
    ///
    /// VerylList /* Vec<T>::Push */: Description VerylList;
    ///
    #[parol_runtime::function_name::named]
    fn veryl_list_0(
        &mut self,
        _description: &ParseTreeStackEntry<'t>,
        _veryl_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut veryl_list = pop_item!(self, veryl_list, VerylList, context);
        let description = pop_item!(self, description, Description, context);
        let veryl_list_0_built = VerylListBuilder::default()
            .description(Box::new(description))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        veryl_list.push(veryl_list_0_built);
        self.push(ASTType::VerylList(veryl_list), context);
        Ok(())
    }

    /// Semantic action for production 102:
    ///
    /// VerylList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn veryl_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let veryl_list_1_built = Vec::new();
        self.push(ASTType::VerylList(veryl_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 103:
    ///
    /// Description: ModuleDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn description_0(
        &mut self,
        _module_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module_declaration = pop_item!(self, module_declaration, ModuleDeclaration, context);
        let description_0_built = Description0Builder::default()
            .module_declaration(Box::new(module_declaration))
            .build()
            .into_diagnostic()?;
        let description_0_built = Description::Description0(description_0_built);
        // Calling user action here
        self.user_grammar.description(&description_0_built)?;
        self.push(ASTType::Description(description_0_built), context);
        Ok(())
    }

    /// Semantic action for production 104:
    ///
    /// Description: InterfaceDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn description_1(
        &mut self,
        _interface_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let interface_declaration =
            pop_item!(self, interface_declaration, InterfaceDeclaration, context);
        let description_1_built = Description1Builder::default()
            .interface_declaration(Box::new(interface_declaration))
            .build()
            .into_diagnostic()?;
        let description_1_built = Description::Description1(description_1_built);
        // Calling user action here
        self.user_grammar.description(&description_1_built)?;
        self.push(ASTType::Description(description_1_built), context);
        Ok(())
    }

    /// Semantic action for production 105:
    ///
    /// Number: IntegralNumber;
    ///
    #[parol_runtime::function_name::named]
    fn number(
        &mut self,
        _integral_number: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let integral_number = pop_item!(self, integral_number, IntegralNumber, context);
        let number_built = NumberBuilder::default()
            .integral_number(Box::new(integral_number))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.number(&number_built)?;
        self.push(ASTType::Number(number_built), context);
        Ok(())
    }

    /// Semantic action for production 106:
    ///
    /// IntegralNumber: BasedBinary;
    ///
    #[parol_runtime::function_name::named]
    fn integral_number_0(
        &mut self,
        _based_binary: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let based_binary = pop_item!(self, based_binary, BasedBinary, context);
        let integral_number_0_built = IntegralNumber0Builder::default()
            .based_binary(Box::new(based_binary))
            .build()
            .into_diagnostic()?;
        let integral_number_0_built = IntegralNumber::IntegralNumber0(integral_number_0_built);
        // Calling user action here
        self.user_grammar
            .integral_number(&integral_number_0_built)?;
        self.push(ASTType::IntegralNumber(integral_number_0_built), context);
        Ok(())
    }

    /// Semantic action for production 107:
    ///
    /// IntegralNumber: BasedOctal;
    ///
    #[parol_runtime::function_name::named]
    fn integral_number_1(
        &mut self,
        _based_octal: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let based_octal = pop_item!(self, based_octal, BasedOctal, context);
        let integral_number_1_built = IntegralNumber1Builder::default()
            .based_octal(Box::new(based_octal))
            .build()
            .into_diagnostic()?;
        let integral_number_1_built = IntegralNumber::IntegralNumber1(integral_number_1_built);
        // Calling user action here
        self.user_grammar
            .integral_number(&integral_number_1_built)?;
        self.push(ASTType::IntegralNumber(integral_number_1_built), context);
        Ok(())
    }

    /// Semantic action for production 108:
    ///
    /// IntegralNumber: BasedDecimal;
    ///
    #[parol_runtime::function_name::named]
    fn integral_number_2(
        &mut self,
        _based_decimal: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let based_decimal = pop_item!(self, based_decimal, BasedDecimal, context);
        let integral_number_2_built = IntegralNumber2Builder::default()
            .based_decimal(Box::new(based_decimal))
            .build()
            .into_diagnostic()?;
        let integral_number_2_built = IntegralNumber::IntegralNumber2(integral_number_2_built);
        // Calling user action here
        self.user_grammar
            .integral_number(&integral_number_2_built)?;
        self.push(ASTType::IntegralNumber(integral_number_2_built), context);
        Ok(())
    }

    /// Semantic action for production 109:
    ///
    /// IntegralNumber: BasedHex;
    ///
    #[parol_runtime::function_name::named]
    fn integral_number_3(
        &mut self,
        _based_hex: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let based_hex = pop_item!(self, based_hex, BasedHex, context);
        let integral_number_3_built = IntegralNumber3Builder::default()
            .based_hex(Box::new(based_hex))
            .build()
            .into_diagnostic()?;
        let integral_number_3_built = IntegralNumber::IntegralNumber3(integral_number_3_built);
        // Calling user action here
        self.user_grammar
            .integral_number(&integral_number_3_built)?;
        self.push(ASTType::IntegralNumber(integral_number_3_built), context);
        Ok(())
    }

    /// Semantic action for production 110:
    ///
    /// IntegralNumber: BaseLess;
    ///
    #[parol_runtime::function_name::named]
    fn integral_number_4(
        &mut self,
        _base_less: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let base_less = pop_item!(self, base_less, BaseLess, context);
        let integral_number_4_built = IntegralNumber4Builder::default()
            .base_less(Box::new(base_less))
            .build()
            .into_diagnostic()?;
        let integral_number_4_built = IntegralNumber::IntegralNumber4(integral_number_4_built);
        // Calling user action here
        self.user_grammar
            .integral_number(&integral_number_4_built)?;
        self.push(ASTType::IntegralNumber(integral_number_4_built), context);
        Ok(())
    }

    /// Semantic action for production 111:
    ///
    /// OperatorPrecedence1: Plus;
    ///
    #[parol_runtime::function_name::named]
    fn operator_precedence1_0(
        &mut self,
        _plus: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let plus = pop_item!(self, plus, Plus, context);
        let operator_precedence1_0_built = OperatorPrecedence3Builder::default()
            .plus(Box::new(plus))
            .build()
            .into_diagnostic()?;
        let operator_precedence1_0_built =
            OperatorPrecedence1::OperatorPrecedence10(operator_precedence1_0_built);
        // Calling user action here
        self.user_grammar
            .operator_precedence1(&operator_precedence1_0_built)?;
        self.push(
            ASTType::OperatorPrecedence1(operator_precedence1_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 112:
    ///
    /// OperatorPrecedence1: Minus;
    ///
    #[parol_runtime::function_name::named]
    fn operator_precedence1_1(
        &mut self,
        _minus: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let minus = pop_item!(self, minus, Minus, context);
        let operator_precedence1_1_built = OperatorPrecedence4Builder::default()
            .minus(Box::new(minus))
            .build()
            .into_diagnostic()?;
        let operator_precedence1_1_built =
            OperatorPrecedence1::OperatorPrecedence11(operator_precedence1_1_built);
        // Calling user action here
        self.user_grammar
            .operator_precedence1(&operator_precedence1_1_built)?;
        self.push(
            ASTType::OperatorPrecedence1(operator_precedence1_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 113:
    ///
    /// OperatorPrecedence2: Star;
    ///
    #[parol_runtime::function_name::named]
    fn operator_precedence2_0(
        &mut self,
        _star: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let star = pop_item!(self, star, Star, context);
        let operator_precedence2_0_built = OperatorPrecedence5Builder::default()
            .star(Box::new(star))
            .build()
            .into_diagnostic()?;
        let operator_precedence2_0_built =
            OperatorPrecedence2::OperatorPrecedence20(operator_precedence2_0_built);
        // Calling user action here
        self.user_grammar
            .operator_precedence2(&operator_precedence2_0_built)?;
        self.push(
            ASTType::OperatorPrecedence2(operator_precedence2_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 114:
    ///
    /// OperatorPrecedence2: Slash;
    ///
    #[parol_runtime::function_name::named]
    fn operator_precedence2_1(
        &mut self,
        _slash: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let slash = pop_item!(self, slash, Slash, context);
        let operator_precedence2_1_built = OperatorPrecedence6Builder::default()
            .slash(Box::new(slash))
            .build()
            .into_diagnostic()?;
        let operator_precedence2_1_built =
            OperatorPrecedence2::OperatorPrecedence21(operator_precedence2_1_built);
        // Calling user action here
        self.user_grammar
            .operator_precedence2(&operator_precedence2_1_built)?;
        self.push(
            ASTType::OperatorPrecedence2(operator_precedence2_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 115:
    ///
    /// Expression: Expression0;
    ///
    #[parol_runtime::function_name::named]
    fn expression(
        &mut self,
        _expression0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression0 = pop_item!(self, expression0, Expression0, context);
        let expression_built = ExpressionBuilder::default()
            .expression0(Box::new(expression0))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.expression(&expression_built)?;
        self.push(ASTType::Expression(expression_built), context);
        Ok(())
    }

    /// Semantic action for production 116:
    ///
    /// Expression0: Expression1 Expression0List /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn expression0(
        &mut self,
        _expression1: &ParseTreeStackEntry<'t>,
        _expression0_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression0_list =
            pop_and_reverse_item!(self, expression0_list, Expression0List, context);
        let expression1 = pop_item!(self, expression1, Expression1, context);
        let expression0_built = Expression0Builder::default()
            .expression1(Box::new(expression1))
            .expression0_list(expression0_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.expression0(&expression0_built)?;
        self.push(ASTType::Expression0(expression0_built), context);
        Ok(())
    }

    /// Semantic action for production 117:
    ///
    /// Expression0List /* Vec<T>::Push */: OperatorPrecedence1 Expression1 Expression0List;
    ///
    #[parol_runtime::function_name::named]
    fn expression0_list_0(
        &mut self,
        _operator_precedence1: &ParseTreeStackEntry<'t>,
        _expression1: &ParseTreeStackEntry<'t>,
        _expression0_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression0_list = pop_item!(self, expression0_list, Expression0List, context);
        let expression1 = pop_item!(self, expression1, Expression1, context);
        let operator_precedence1 =
            pop_item!(self, operator_precedence1, OperatorPrecedence1, context);
        let expression0_list_0_built = Expression0ListBuilder::default()
            .expression1(Box::new(expression1))
            .operator_precedence1(Box::new(operator_precedence1))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        expression0_list.push(expression0_list_0_built);
        self.push(ASTType::Expression0List(expression0_list), context);
        Ok(())
    }

    /// Semantic action for production 118:
    ///
    /// Expression0List /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn expression0_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression0_list_1_built = Vec::new();
        self.push(ASTType::Expression0List(expression0_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 119:
    ///
    /// Expression1: Expression2 Expression1List /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn expression1(
        &mut self,
        _expression2: &ParseTreeStackEntry<'t>,
        _expression1_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression1_list =
            pop_and_reverse_item!(self, expression1_list, Expression1List, context);
        let expression2 = pop_item!(self, expression2, Expression2, context);
        let expression1_built = Expression1Builder::default()
            .expression2(Box::new(expression2))
            .expression1_list(expression1_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.expression1(&expression1_built)?;
        self.push(ASTType::Expression1(expression1_built), context);
        Ok(())
    }

    /// Semantic action for production 120:
    ///
    /// Expression1List /* Vec<T>::Push */: OperatorPrecedence2 Expression2 Expression1List;
    ///
    #[parol_runtime::function_name::named]
    fn expression1_list_0(
        &mut self,
        _operator_precedence2: &ParseTreeStackEntry<'t>,
        _expression2: &ParseTreeStackEntry<'t>,
        _expression1_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression1_list = pop_item!(self, expression1_list, Expression1List, context);
        let expression2 = pop_item!(self, expression2, Expression2, context);
        let operator_precedence2 =
            pop_item!(self, operator_precedence2, OperatorPrecedence2, context);
        let expression1_list_0_built = Expression1ListBuilder::default()
            .expression2(Box::new(expression2))
            .operator_precedence2(Box::new(operator_precedence2))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        expression1_list.push(expression1_list_0_built);
        self.push(ASTType::Expression1List(expression1_list), context);
        Ok(())
    }

    /// Semantic action for production 121:
    ///
    /// Expression1List /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn expression1_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression1_list_1_built = Vec::new();
        self.push(ASTType::Expression1List(expression1_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 122:
    ///
    /// Expression2: Factor;
    ///
    #[parol_runtime::function_name::named]
    fn expression2(
        &mut self,
        _factor: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let factor = pop_item!(self, factor, Factor, context);
        let expression2_built = Expression2Builder::default()
            .factor(Box::new(factor))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.expression2(&expression2_built)?;
        self.push(ASTType::Expression2(expression2_built), context);
        Ok(())
    }

    /// Semantic action for production 123:
    ///
    /// Factor: Number;
    ///
    #[parol_runtime::function_name::named]
    fn factor_0(
        &mut self,
        _number: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let number = pop_item!(self, number, Number, context);
        let factor_0_built = Factor0Builder::default()
            .number(Box::new(number))
            .build()
            .into_diagnostic()?;
        let factor_0_built = Factor::Factor0(factor_0_built);
        // Calling user action here
        self.user_grammar.factor(&factor_0_built)?;
        self.push(ASTType::Factor(factor_0_built), context);
        Ok(())
    }

    /// Semantic action for production 124:
    ///
    /// Factor: Identifier FactorList /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn factor_1(
        &mut self,
        _identifier: &ParseTreeStackEntry<'t>,
        _factor_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let factor_list = pop_and_reverse_item!(self, factor_list, FactorList, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let factor_1_built = Factor1Builder::default()
            .identifier(Box::new(identifier))
            .factor_list(factor_list)
            .build()
            .into_diagnostic()?;
        let factor_1_built = Factor::Factor1(factor_1_built);
        // Calling user action here
        self.user_grammar.factor(&factor_1_built)?;
        self.push(ASTType::Factor(factor_1_built), context);
        Ok(())
    }

    /// Semantic action for production 125:
    ///
    /// FactorList /* Vec<T>::Push */: Range FactorList;
    ///
    #[parol_runtime::function_name::named]
    fn factor_list_0(
        &mut self,
        _range: &ParseTreeStackEntry<'t>,
        _factor_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut factor_list = pop_item!(self, factor_list, FactorList, context);
        let range = pop_item!(self, range, Range, context);
        let factor_list_0_built = FactorListBuilder::default()
            .range(Box::new(range))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        factor_list.push(factor_list_0_built);
        self.push(ASTType::FactorList(factor_list), context);
        Ok(())
    }

    /// Semantic action for production 126:
    ///
    /// FactorList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn factor_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let factor_list_1_built = Vec::new();
        self.push(ASTType::FactorList(factor_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 127:
    ///
    /// Factor: LParen Expression RParen;
    ///
    #[parol_runtime::function_name::named]
    fn factor_2(
        &mut self,
        _l_paren: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _r_paren: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren = pop_item!(self, r_paren, RParen, context);
        let expression = pop_item!(self, expression, Expression, context);
        let l_paren = pop_item!(self, l_paren, LParen, context);
        let factor_2_built = Factor2Builder::default()
            .l_paren(Box::new(l_paren))
            .expression(Box::new(expression))
            .r_paren(Box::new(r_paren))
            .build()
            .into_diagnostic()?;
        let factor_2_built = Factor::Factor2(factor_2_built);
        // Calling user action here
        self.user_grammar.factor(&factor_2_built)?;
        self.push(ASTType::Factor(factor_2_built), context);
        Ok(())
    }

    /// Semantic action for production 128:
    ///
    /// Statement: AssignmentStatement;
    ///
    #[parol_runtime::function_name::named]
    fn statement_0(
        &mut self,
        _assignment_statement: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let assignment_statement =
            pop_item!(self, assignment_statement, AssignmentStatement, context);
        let statement_0_built = Statement0Builder::default()
            .assignment_statement(Box::new(assignment_statement))
            .build()
            .into_diagnostic()?;
        let statement_0_built = Statement::Statement0(statement_0_built);
        // Calling user action here
        self.user_grammar.statement(&statement_0_built)?;
        self.push(ASTType::Statement(statement_0_built), context);
        Ok(())
    }

    /// Semantic action for production 129:
    ///
    /// Statement: IfStatement;
    ///
    #[parol_runtime::function_name::named]
    fn statement_1(
        &mut self,
        _if_statement: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_statement = pop_item!(self, if_statement, IfStatement, context);
        let statement_1_built = Statement1Builder::default()
            .if_statement(Box::new(if_statement))
            .build()
            .into_diagnostic()?;
        let statement_1_built = Statement::Statement1(statement_1_built);
        // Calling user action here
        self.user_grammar.statement(&statement_1_built)?;
        self.push(ASTType::Statement(statement_1_built), context);
        Ok(())
    }

    /// Semantic action for production 130:
    ///
    /// AssignmentStatement: Identifier Equ Expression Semicolon;
    ///
    #[parol_runtime::function_name::named]
    fn assignment_statement(
        &mut self,
        _identifier: &ParseTreeStackEntry<'t>,
        _equ: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _semicolon: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon = pop_item!(self, semicolon, Semicolon, context);
        let expression = pop_item!(self, expression, Expression, context);
        let equ = pop_item!(self, equ, Equ, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let assignment_statement_built = AssignmentStatementBuilder::default()
            .identifier(Box::new(identifier))
            .equ(Box::new(equ))
            .expression(Box::new(expression))
            .semicolon(Box::new(semicolon))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .assignment_statement(&assignment_statement_built)?;
        self.push(
            ASTType::AssignmentStatement(assignment_statement_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 131:
    ///
    /// IfStatement: If Expression LBrace Statement RBrace IfStatementList /* Vec */ IfStatementOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn if_statement(
        &mut self,
        _if: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _l_brace: &ParseTreeStackEntry<'t>,
        _statement: &ParseTreeStackEntry<'t>,
        _r_brace: &ParseTreeStackEntry<'t>,
        _if_statement_list: &ParseTreeStackEntry<'t>,
        _if_statement_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_statement_opt = pop_item!(self, if_statement_opt, IfStatementOpt, context);
        let if_statement_list =
            pop_and_reverse_item!(self, if_statement_list, IfStatementList, context);
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let statement = pop_item!(self, statement, Statement, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let expression = pop_item!(self, expression, Expression, context);
        let r#if = pop_item!(self, r#if, If, context);
        let if_statement_built = IfStatementBuilder::default()
            .r#if(Box::new(r#if))
            .expression(Box::new(expression))
            .l_brace(Box::new(l_brace))
            .statement(Box::new(statement))
            .r_brace(Box::new(r_brace))
            .if_statement_list(if_statement_list)
            .if_statement_opt(if_statement_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.if_statement(&if_statement_built)?;
        self.push(ASTType::IfStatement(if_statement_built), context);
        Ok(())
    }

    /// Semantic action for production 132:
    ///
    /// IfStatementList /* Vec<T>::Push */: Else If Expression LBrace Statement RBrace IfStatementList;
    ///
    #[parol_runtime::function_name::named]
    fn if_statement_list_0(
        &mut self,
        _else: &ParseTreeStackEntry<'t>,
        _if: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _l_brace: &ParseTreeStackEntry<'t>,
        _statement: &ParseTreeStackEntry<'t>,
        _r_brace: &ParseTreeStackEntry<'t>,
        _if_statement_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut if_statement_list = pop_item!(self, if_statement_list, IfStatementList, context);
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let statement = pop_item!(self, statement, Statement, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let expression = pop_item!(self, expression, Expression, context);
        let r#if = pop_item!(self, r#if, If, context);
        let r#else = pop_item!(self, r#else, Else, context);
        let if_statement_list_0_built = IfStatementListBuilder::default()
            .r_brace(Box::new(r_brace))
            .statement(Box::new(statement))
            .l_brace(Box::new(l_brace))
            .expression(Box::new(expression))
            .r#if(Box::new(r#if))
            .r#else(Box::new(r#else))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        if_statement_list.push(if_statement_list_0_built);
        self.push(ASTType::IfStatementList(if_statement_list), context);
        Ok(())
    }

    /// Semantic action for production 133:
    ///
    /// IfStatementList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn if_statement_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_statement_list_1_built = Vec::new();
        self.push(ASTType::IfStatementList(if_statement_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 134:
    ///
    /// IfStatementOpt /* Option<T>::Some */: Else LBrace Statement RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn if_statement_opt_0(
        &mut self,
        _else: &ParseTreeStackEntry<'t>,
        _l_brace: &ParseTreeStackEntry<'t>,
        _statement: &ParseTreeStackEntry<'t>,
        _r_brace: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let statement = pop_item!(self, statement, Statement, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let r#else = pop_item!(self, r#else, Else, context);
        let if_statement_opt_0_built = IfStatementOptBuilder::default()
            .r#else(Box::new(r#else))
            .l_brace(Box::new(l_brace))
            .statement(Box::new(statement))
            .r_brace(Box::new(r_brace))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::IfStatementOpt(Some(Box::new(if_statement_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 135:
    ///
    /// IfStatementOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn if_statement_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::IfStatementOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 136:
    ///
    /// Range: LBracket Expression RangeOpt /* Option */ RBracket;
    ///
    #[parol_runtime::function_name::named]
    fn range(
        &mut self,
        _l_bracket: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _range_opt: &ParseTreeStackEntry<'t>,
        _r_bracket: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_bracket = pop_item!(self, r_bracket, RBracket, context);
        let range_opt = pop_item!(self, range_opt, RangeOpt, context);
        let expression = pop_item!(self, expression, Expression, context);
        let l_bracket = pop_item!(self, l_bracket, LBracket, context);
        let range_built = RangeBuilder::default()
            .l_bracket(Box::new(l_bracket))
            .expression(Box::new(expression))
            .range_opt(range_opt)
            .r_bracket(Box::new(r_bracket))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.range(&range_built)?;
        self.push(ASTType::Range(range_built), context);
        Ok(())
    }

    /// Semantic action for production 137:
    ///
    /// RangeOpt /* Option<T>::Some */: Colon Expression;
    ///
    #[parol_runtime::function_name::named]
    fn range_opt_0(
        &mut self,
        _colon: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = pop_item!(self, expression, Expression, context);
        let colon = pop_item!(self, colon, Colon, context);
        let range_opt_0_built = RangeOptBuilder::default()
            .colon(Box::new(colon))
            .expression(Box::new(expression))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::RangeOpt(Some(Box::new(range_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 138:
    ///
    /// RangeOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn range_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::RangeOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 139:
    ///
    /// Width: LBracket Expression RBracket;
    ///
    #[parol_runtime::function_name::named]
    fn width(
        &mut self,
        _l_bracket: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _r_bracket: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_bracket = pop_item!(self, r_bracket, RBracket, context);
        let expression = pop_item!(self, expression, Expression, context);
        let l_bracket = pop_item!(self, l_bracket, LBracket, context);
        let width_built = WidthBuilder::default()
            .l_bracket(Box::new(l_bracket))
            .expression(Box::new(expression))
            .r_bracket(Box::new(r_bracket))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.width(&width_built)?;
        self.push(ASTType::Width(width_built), context);
        Ok(())
    }

    /// Semantic action for production 140:
    ///
    /// BuiltinType: Logic;
    ///
    #[parol_runtime::function_name::named]
    fn builtin_type_0(
        &mut self,
        _logic: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logic = pop_item!(self, logic, Logic, context);
        let builtin_type_0_built = BuiltinType0Builder::default()
            .logic(Box::new(logic))
            .build()
            .into_diagnostic()?;
        let builtin_type_0_built = BuiltinType::BuiltinType0(builtin_type_0_built);
        // Calling user action here
        self.user_grammar.builtin_type(&builtin_type_0_built)?;
        self.push(ASTType::BuiltinType(builtin_type_0_built), context);
        Ok(())
    }

    /// Semantic action for production 141:
    ///
    /// BuiltinType: Bit;
    ///
    #[parol_runtime::function_name::named]
    fn builtin_type_1(
        &mut self,
        _bit: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bit = pop_item!(self, bit, Bit, context);
        let builtin_type_1_built = BuiltinType1Builder::default()
            .bit(Box::new(bit))
            .build()
            .into_diagnostic()?;
        let builtin_type_1_built = BuiltinType::BuiltinType1(builtin_type_1_built);
        // Calling user action here
        self.user_grammar.builtin_type(&builtin_type_1_built)?;
        self.push(ASTType::BuiltinType(builtin_type_1_built), context);
        Ok(())
    }

    /// Semantic action for production 142:
    ///
    /// BuiltinType: U32;
    ///
    #[parol_runtime::function_name::named]
    fn builtin_type_2(
        &mut self,
        _u32: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let u32 = pop_item!(self, u32, U32, context);
        let builtin_type_2_built = BuiltinType2Builder::default()
            .u32(Box::new(u32))
            .build()
            .into_diagnostic()?;
        let builtin_type_2_built = BuiltinType::BuiltinType2(builtin_type_2_built);
        // Calling user action here
        self.user_grammar.builtin_type(&builtin_type_2_built)?;
        self.push(ASTType::BuiltinType(builtin_type_2_built), context);
        Ok(())
    }

    /// Semantic action for production 143:
    ///
    /// BuiltinType: U64;
    ///
    #[parol_runtime::function_name::named]
    fn builtin_type_3(
        &mut self,
        _u64: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let u64 = pop_item!(self, u64, U64, context);
        let builtin_type_3_built = BuiltinType3Builder::default()
            .u64(Box::new(u64))
            .build()
            .into_diagnostic()?;
        let builtin_type_3_built = BuiltinType::BuiltinType3(builtin_type_3_built);
        // Calling user action here
        self.user_grammar.builtin_type(&builtin_type_3_built)?;
        self.push(ASTType::BuiltinType(builtin_type_3_built), context);
        Ok(())
    }

    /// Semantic action for production 144:
    ///
    /// BuiltinType: I32;
    ///
    #[parol_runtime::function_name::named]
    fn builtin_type_4(
        &mut self,
        _i32: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let i32 = pop_item!(self, i32, I32, context);
        let builtin_type_4_built = BuiltinType4Builder::default()
            .i32(Box::new(i32))
            .build()
            .into_diagnostic()?;
        let builtin_type_4_built = BuiltinType::BuiltinType4(builtin_type_4_built);
        // Calling user action here
        self.user_grammar.builtin_type(&builtin_type_4_built)?;
        self.push(ASTType::BuiltinType(builtin_type_4_built), context);
        Ok(())
    }

    /// Semantic action for production 145:
    ///
    /// BuiltinType: I64;
    ///
    #[parol_runtime::function_name::named]
    fn builtin_type_5(
        &mut self,
        _i64: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let i64 = pop_item!(self, i64, I64, context);
        let builtin_type_5_built = BuiltinType5Builder::default()
            .i64(Box::new(i64))
            .build()
            .into_diagnostic()?;
        let builtin_type_5_built = BuiltinType::BuiltinType5(builtin_type_5_built);
        // Calling user action here
        self.user_grammar.builtin_type(&builtin_type_5_built)?;
        self.push(ASTType::BuiltinType(builtin_type_5_built), context);
        Ok(())
    }

    /// Semantic action for production 146:
    ///
    /// BuiltinType: F32;
    ///
    #[parol_runtime::function_name::named]
    fn builtin_type_6(
        &mut self,
        _f32: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let f32 = pop_item!(self, f32, F32, context);
        let builtin_type_6_built = BuiltinType6Builder::default()
            .f32(Box::new(f32))
            .build()
            .into_diagnostic()?;
        let builtin_type_6_built = BuiltinType::BuiltinType6(builtin_type_6_built);
        // Calling user action here
        self.user_grammar.builtin_type(&builtin_type_6_built)?;
        self.push(ASTType::BuiltinType(builtin_type_6_built), context);
        Ok(())
    }

    /// Semantic action for production 147:
    ///
    /// BuiltinType: F64;
    ///
    #[parol_runtime::function_name::named]
    fn builtin_type_7(
        &mut self,
        _f64: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let f64 = pop_item!(self, f64, F64, context);
        let builtin_type_7_built = BuiltinType7Builder::default()
            .f64(Box::new(f64))
            .build()
            .into_diagnostic()?;
        let builtin_type_7_built = BuiltinType::BuiltinType7(builtin_type_7_built);
        // Calling user action here
        self.user_grammar.builtin_type(&builtin_type_7_built)?;
        self.push(ASTType::BuiltinType(builtin_type_7_built), context);
        Ok(())
    }

    /// Semantic action for production 148:
    ///
    /// Type: TypeGroup TypeList /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn r#type(
        &mut self,
        _type_group: &ParseTreeStackEntry<'t>,
        _type_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_list = pop_and_reverse_item!(self, type_list, TypeList, context);
        let type_group = pop_item!(self, type_group, TypeGroup, context);
        let r#type_built = TypeBuilder::default()
            .type_group(Box::new(type_group))
            .type_list(type_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.r#type(&r#type_built)?;
        self.push(ASTType::Type(r#type_built), context);
        Ok(())
    }

    /// Semantic action for production 149:
    ///
    /// TypeGroup: BuiltinType;
    ///
    #[parol_runtime::function_name::named]
    fn type_group_0(
        &mut self,
        _builtin_type: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let builtin_type = pop_item!(self, builtin_type, BuiltinType, context);
        let type_group_0_built = TypeGroup0Builder::default()
            .builtin_type(Box::new(builtin_type))
            .build()
            .into_diagnostic()?;
        let type_group_0_built = TypeGroup::TypeGroup0(type_group_0_built);
        self.push(ASTType::TypeGroup(type_group_0_built), context);
        Ok(())
    }

    /// Semantic action for production 150:
    ///
    /// TypeGroup: Identifier;
    ///
    #[parol_runtime::function_name::named]
    fn type_group_1(
        &mut self,
        _identifier: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let identifier = pop_item!(self, identifier, Identifier, context);
        let type_group_1_built = TypeGroup1Builder::default()
            .identifier(Box::new(identifier))
            .build()
            .into_diagnostic()?;
        let type_group_1_built = TypeGroup::TypeGroup1(type_group_1_built);
        self.push(ASTType::TypeGroup(type_group_1_built), context);
        Ok(())
    }

    /// Semantic action for production 151:
    ///
    /// TypeList /* Vec<T>::Push */: Width TypeList;
    ///
    #[parol_runtime::function_name::named]
    fn type_list_0(
        &mut self,
        _width: &ParseTreeStackEntry<'t>,
        _type_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut type_list = pop_item!(self, type_list, TypeList, context);
        let width = pop_item!(self, width, Width, context);
        let type_list_0_built = TypeListBuilder::default()
            .width(Box::new(width))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        type_list.push(type_list_0_built);
        self.push(ASTType::TypeList(type_list), context);
        Ok(())
    }

    /// Semantic action for production 152:
    ///
    /// TypeList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn type_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_list_1_built = Vec::new();
        self.push(ASTType::TypeList(type_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 153:
    ///
    /// WithParameter: Hash LParen WithParameterOpt /* Option */ RParen;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter(
        &mut self,
        _hash: &ParseTreeStackEntry<'t>,
        _l_paren: &ParseTreeStackEntry<'t>,
        _with_parameter_opt: &ParseTreeStackEntry<'t>,
        _r_paren: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren = pop_item!(self, r_paren, RParen, context);
        let with_parameter_opt = pop_item!(self, with_parameter_opt, WithParameterOpt, context);
        let l_paren = pop_item!(self, l_paren, LParen, context);
        let hash = pop_item!(self, hash, Hash, context);
        let with_parameter_built = WithParameterBuilder::default()
            .hash(Box::new(hash))
            .l_paren(Box::new(l_paren))
            .with_parameter_opt(with_parameter_opt)
            .r_paren(Box::new(r_paren))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.with_parameter(&with_parameter_built)?;
        self.push(ASTType::WithParameter(with_parameter_built), context);
        Ok(())
    }

    /// Semantic action for production 154:
    ///
    /// WithParameterOpt /* Option<T>::Some */: WithParameterList;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_opt_0(
        &mut self,
        _with_parameter_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let with_parameter_list = pop_item!(self, with_parameter_list, WithParameterList, context);
        let with_parameter_opt_0_built = WithParameterOptBuilder::default()
            .with_parameter_list(Box::new(with_parameter_list))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::WithParameterOpt(Some(Box::new(with_parameter_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 155:
    ///
    /// WithParameterOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::WithParameterOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 156:
    ///
    /// WithParameterList: WithParameterItem WithParameterListList /* Vec */ WithParameterListOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_list(
        &mut self,
        _with_parameter_item: &ParseTreeStackEntry<'t>,
        _with_parameter_list_list: &ParseTreeStackEntry<'t>,
        _with_parameter_list_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let with_parameter_list_opt =
            pop_item!(self, with_parameter_list_opt, WithParameterListOpt, context);
        let with_parameter_list_list = pop_and_reverse_item!(
            self,
            with_parameter_list_list,
            WithParameterListList,
            context
        );
        let with_parameter_item = pop_item!(self, with_parameter_item, WithParameterItem, context);
        let with_parameter_list_built = WithParameterListBuilder::default()
            .with_parameter_item(Box::new(with_parameter_item))
            .with_parameter_list_list(with_parameter_list_list)
            .with_parameter_list_opt(with_parameter_list_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .with_parameter_list(&with_parameter_list_built)?;
        self.push(
            ASTType::WithParameterList(with_parameter_list_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 157:
    ///
    /// WithParameterListList /* Vec<T>::Push */: Comma WithParameterItem WithParameterListList;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_list_list_0(
        &mut self,
        _comma: &ParseTreeStackEntry<'t>,
        _with_parameter_item: &ParseTreeStackEntry<'t>,
        _with_parameter_list_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut with_parameter_list_list = pop_item!(
            self,
            with_parameter_list_list,
            WithParameterListList,
            context
        );
        let with_parameter_item = pop_item!(self, with_parameter_item, WithParameterItem, context);
        let comma = pop_item!(self, comma, Comma, context);
        let with_parameter_list_list_0_built = WithParameterListListBuilder::default()
            .with_parameter_item(Box::new(with_parameter_item))
            .comma(Box::new(comma))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        with_parameter_list_list.push(with_parameter_list_list_0_built);
        self.push(
            ASTType::WithParameterListList(with_parameter_list_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 158:
    ///
    /// WithParameterListList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_list_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let with_parameter_list_list_1_built = Vec::new();
        self.push(
            ASTType::WithParameterListList(with_parameter_list_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 159:
    ///
    /// WithParameterListOpt /* Option<T>::Some */: Comma;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_list_opt_0(
        &mut self,
        _comma: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = pop_item!(self, comma, Comma, context);
        let with_parameter_list_opt_0_built = WithParameterListOptBuilder::default()
            .comma(Box::new(comma))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::WithParameterListOpt(Some(Box::new(with_parameter_list_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 160:
    ///
    /// WithParameterListOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_list_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::WithParameterListOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 161:
    ///
    /// WithParameterItem: WithParameterItemGroup Identifier Colon Type Equ Expression;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_item(
        &mut self,
        _with_parameter_item_group: &ParseTreeStackEntry<'t>,
        _identifier: &ParseTreeStackEntry<'t>,
        _colon: &ParseTreeStackEntry<'t>,
        _type: &ParseTreeStackEntry<'t>,
        _equ: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = pop_item!(self, expression, Expression, context);
        let equ = pop_item!(self, equ, Equ, context);
        let r#type = pop_item!(self, r#type, Type, context);
        let colon = pop_item!(self, colon, Colon, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let with_parameter_item_group = pop_item!(
            self,
            with_parameter_item_group,
            WithParameterItemGroup,
            context
        );
        let with_parameter_item_built = WithParameterItemBuilder::default()
            .with_parameter_item_group(Box::new(with_parameter_item_group))
            .identifier(Box::new(identifier))
            .colon(Box::new(colon))
            .r#type(Box::new(r#type))
            .equ(Box::new(equ))
            .expression(Box::new(expression))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .with_parameter_item(&with_parameter_item_built)?;
        self.push(
            ASTType::WithParameterItem(with_parameter_item_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 162:
    ///
    /// WithParameterItemGroup: Parameter;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_item_group_0(
        &mut self,
        _parameter: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let parameter = pop_item!(self, parameter, Parameter, context);
        let with_parameter_item_group_0_built = WithParameterItemGroup0Builder::default()
            .parameter(Box::new(parameter))
            .build()
            .into_diagnostic()?;
        let with_parameter_item_group_0_built =
            WithParameterItemGroup::WithParameterItemGroup0(with_parameter_item_group_0_built);
        self.push(
            ASTType::WithParameterItemGroup(with_parameter_item_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 163:
    ///
    /// WithParameterItemGroup: Localparam;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_item_group_1(
        &mut self,
        _localparam: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let localparam = pop_item!(self, localparam, Localparam, context);
        let with_parameter_item_group_1_built = WithParameterItemGroup1Builder::default()
            .localparam(Box::new(localparam))
            .build()
            .into_diagnostic()?;
        let with_parameter_item_group_1_built =
            WithParameterItemGroup::WithParameterItemGroup1(with_parameter_item_group_1_built);
        self.push(
            ASTType::WithParameterItemGroup(with_parameter_item_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 164:
    ///
    /// ModuleDeclaration: Module Identifier ModuleDeclarationOpt /* Option */ ModuleDeclarationOpt0 /* Option */ LBrace ModuleDeclarationList /* Vec */ RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn module_declaration(
        &mut self,
        _module: &ParseTreeStackEntry<'t>,
        _identifier: &ParseTreeStackEntry<'t>,
        _module_declaration_opt: &ParseTreeStackEntry<'t>,
        _module_declaration_opt0: &ParseTreeStackEntry<'t>,
        _l_brace: &ParseTreeStackEntry<'t>,
        _module_declaration_list: &ParseTreeStackEntry<'t>,
        _r_brace: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let module_declaration_list = pop_and_reverse_item!(
            self,
            module_declaration_list,
            ModuleDeclarationList,
            context
        );
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let module_declaration_opt0 = pop_item!(
            self,
            module_declaration_opt0,
            ModuleDeclarationOpt0,
            context
        );
        let module_declaration_opt =
            pop_item!(self, module_declaration_opt, ModuleDeclarationOpt, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let module = pop_item!(self, module, Module, context);
        let module_declaration_built = ModuleDeclarationBuilder::default()
            .module(Box::new(module))
            .identifier(Box::new(identifier))
            .module_declaration_opt(module_declaration_opt)
            .module_declaration_opt0(module_declaration_opt0)
            .l_brace(Box::new(l_brace))
            .module_declaration_list(module_declaration_list)
            .r_brace(Box::new(r_brace))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .module_declaration(&module_declaration_built)?;
        self.push(
            ASTType::ModuleDeclaration(module_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 165:
    ///
    /// ModuleDeclarationList /* Vec<T>::Push */: ModuleItem ModuleDeclarationList;
    ///
    #[parol_runtime::function_name::named]
    fn module_declaration_list_0(
        &mut self,
        _module_item: &ParseTreeStackEntry<'t>,
        _module_declaration_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut module_declaration_list = pop_item!(
            self,
            module_declaration_list,
            ModuleDeclarationList,
            context
        );
        let module_item = pop_item!(self, module_item, ModuleItem, context);
        let module_declaration_list_0_built = ModuleDeclarationListBuilder::default()
            .module_item(Box::new(module_item))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        module_declaration_list.push(module_declaration_list_0_built);
        self.push(
            ASTType::ModuleDeclarationList(module_declaration_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 166:
    ///
    /// ModuleDeclarationList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn module_declaration_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module_declaration_list_1_built = Vec::new();
        self.push(
            ASTType::ModuleDeclarationList(module_declaration_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 167:
    ///
    /// ModuleDeclarationOpt0 /* Option<T>::Some */: ModulePort;
    ///
    #[parol_runtime::function_name::named]
    fn module_declaration_opt0_0(
        &mut self,
        _module_port: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module_port = pop_item!(self, module_port, ModulePort, context);
        let module_declaration_opt0_0_built = ModuleDeclarationOpt0Builder::default()
            .module_port(Box::new(module_port))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::ModuleDeclarationOpt0(Some(Box::new(module_declaration_opt0_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 168:
    ///
    /// ModuleDeclarationOpt0 /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn module_declaration_opt0_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ModuleDeclarationOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 169:
    ///
    /// ModuleDeclarationOpt /* Option<T>::Some */: WithParameter;
    ///
    #[parol_runtime::function_name::named]
    fn module_declaration_opt_0(
        &mut self,
        _with_parameter: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let with_parameter = pop_item!(self, with_parameter, WithParameter, context);
        let module_declaration_opt_0_built = ModuleDeclarationOptBuilder::default()
            .with_parameter(Box::new(with_parameter))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::ModuleDeclarationOpt(Some(Box::new(module_declaration_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 170:
    ///
    /// ModuleDeclarationOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn module_declaration_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ModuleDeclarationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 171:
    ///
    /// ModulePort: LParen ModulePortOpt /* Option */ RParen;
    ///
    #[parol_runtime::function_name::named]
    fn module_port(
        &mut self,
        _l_paren: &ParseTreeStackEntry<'t>,
        _module_port_opt: &ParseTreeStackEntry<'t>,
        _r_paren: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren = pop_item!(self, r_paren, RParen, context);
        let module_port_opt = pop_item!(self, module_port_opt, ModulePortOpt, context);
        let l_paren = pop_item!(self, l_paren, LParen, context);
        let module_port_built = ModulePortBuilder::default()
            .l_paren(Box::new(l_paren))
            .module_port_opt(module_port_opt)
            .r_paren(Box::new(r_paren))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.module_port(&module_port_built)?;
        self.push(ASTType::ModulePort(module_port_built), context);
        Ok(())
    }

    /// Semantic action for production 172:
    ///
    /// ModulePortOpt /* Option<T>::Some */: ModulePortList;
    ///
    #[parol_runtime::function_name::named]
    fn module_port_opt_0(
        &mut self,
        _module_port_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module_port_list = pop_item!(self, module_port_list, ModulePortList, context);
        let module_port_opt_0_built = ModulePortOptBuilder::default()
            .module_port_list(Box::new(module_port_list))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::ModulePortOpt(Some(Box::new(module_port_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 173:
    ///
    /// ModulePortOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn module_port_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ModulePortOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 174:
    ///
    /// ModulePortList: ModulePortItem ModulePortListList /* Vec */ ModulePortListOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn module_port_list(
        &mut self,
        _module_port_item: &ParseTreeStackEntry<'t>,
        _module_port_list_list: &ParseTreeStackEntry<'t>,
        _module_port_list_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module_port_list_opt =
            pop_item!(self, module_port_list_opt, ModulePortListOpt, context);
        let module_port_list_list =
            pop_and_reverse_item!(self, module_port_list_list, ModulePortListList, context);
        let module_port_item = pop_item!(self, module_port_item, ModulePortItem, context);
        let module_port_list_built = ModulePortListBuilder::default()
            .module_port_item(Box::new(module_port_item))
            .module_port_list_list(module_port_list_list)
            .module_port_list_opt(module_port_list_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .module_port_list(&module_port_list_built)?;
        self.push(ASTType::ModulePortList(module_port_list_built), context);
        Ok(())
    }

    /// Semantic action for production 175:
    ///
    /// ModulePortListList /* Vec<T>::Push */: Comma ModulePortItem ModulePortListList;
    ///
    #[parol_runtime::function_name::named]
    fn module_port_list_list_0(
        &mut self,
        _comma: &ParseTreeStackEntry<'t>,
        _module_port_item: &ParseTreeStackEntry<'t>,
        _module_port_list_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut module_port_list_list =
            pop_item!(self, module_port_list_list, ModulePortListList, context);
        let module_port_item = pop_item!(self, module_port_item, ModulePortItem, context);
        let comma = pop_item!(self, comma, Comma, context);
        let module_port_list_list_0_built = ModulePortListListBuilder::default()
            .module_port_item(Box::new(module_port_item))
            .comma(Box::new(comma))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        module_port_list_list.push(module_port_list_list_0_built);
        self.push(ASTType::ModulePortListList(module_port_list_list), context);
        Ok(())
    }

    /// Semantic action for production 176:
    ///
    /// ModulePortListList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn module_port_list_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module_port_list_list_1_built = Vec::new();
        self.push(
            ASTType::ModulePortListList(module_port_list_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 177:
    ///
    /// ModulePortListOpt /* Option<T>::Some */: Comma;
    ///
    #[parol_runtime::function_name::named]
    fn module_port_list_opt_0(
        &mut self,
        _comma: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = pop_item!(self, comma, Comma, context);
        let module_port_list_opt_0_built = ModulePortListOptBuilder::default()
            .comma(Box::new(comma))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::ModulePortListOpt(Some(Box::new(module_port_list_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 178:
    ///
    /// ModulePortListOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn module_port_list_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ModulePortListOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 179:
    ///
    /// ModulePortItem: Identifier Colon Direction Type;
    ///
    #[parol_runtime::function_name::named]
    fn module_port_item(
        &mut self,
        _identifier: &ParseTreeStackEntry<'t>,
        _colon: &ParseTreeStackEntry<'t>,
        _direction: &ParseTreeStackEntry<'t>,
        _type: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#type = pop_item!(self, r#type, Type, context);
        let direction = pop_item!(self, direction, Direction, context);
        let colon = pop_item!(self, colon, Colon, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let module_port_item_built = ModulePortItemBuilder::default()
            .identifier(Box::new(identifier))
            .colon(Box::new(colon))
            .direction(Box::new(direction))
            .r#type(Box::new(r#type))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .module_port_item(&module_port_item_built)?;
        self.push(ASTType::ModulePortItem(module_port_item_built), context);
        Ok(())
    }

    /// Semantic action for production 180:
    ///
    /// Direction: Input;
    ///
    #[parol_runtime::function_name::named]
    fn direction_0(
        &mut self,
        _input: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let input = pop_item!(self, input, Input, context);
        let direction_0_built = Direction0Builder::default()
            .input(Box::new(input))
            .build()
            .into_diagnostic()?;
        let direction_0_built = Direction::Direction0(direction_0_built);
        // Calling user action here
        self.user_grammar.direction(&direction_0_built)?;
        self.push(ASTType::Direction(direction_0_built), context);
        Ok(())
    }

    /// Semantic action for production 181:
    ///
    /// Direction: Output;
    ///
    #[parol_runtime::function_name::named]
    fn direction_1(
        &mut self,
        _output: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let output = pop_item!(self, output, Output, context);
        let direction_1_built = Direction1Builder::default()
            .output(Box::new(output))
            .build()
            .into_diagnostic()?;
        let direction_1_built = Direction::Direction1(direction_1_built);
        // Calling user action here
        self.user_grammar.direction(&direction_1_built)?;
        self.push(ASTType::Direction(direction_1_built), context);
        Ok(())
    }

    /// Semantic action for production 182:
    ///
    /// Direction: Inout;
    ///
    #[parol_runtime::function_name::named]
    fn direction_2(
        &mut self,
        _inout: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inout = pop_item!(self, inout, Inout, context);
        let direction_2_built = Direction2Builder::default()
            .inout(Box::new(inout))
            .build()
            .into_diagnostic()?;
        let direction_2_built = Direction::Direction2(direction_2_built);
        // Calling user action here
        self.user_grammar.direction(&direction_2_built)?;
        self.push(ASTType::Direction(direction_2_built), context);
        Ok(())
    }

    /// Semantic action for production 183:
    ///
    /// ModuleItem: VariableDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn module_item_0(
        &mut self,
        _variable_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let variable_declaration =
            pop_item!(self, variable_declaration, VariableDeclaration, context);
        let module_item_0_built = ModuleItem0Builder::default()
            .variable_declaration(Box::new(variable_declaration))
            .build()
            .into_diagnostic()?;
        let module_item_0_built = ModuleItem::ModuleItem0(module_item_0_built);
        // Calling user action here
        self.user_grammar.module_item(&module_item_0_built)?;
        self.push(ASTType::ModuleItem(module_item_0_built), context);
        Ok(())
    }

    /// Semantic action for production 184:
    ///
    /// ModuleItem: ParameterDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn module_item_1(
        &mut self,
        _parameter_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let parameter_declaration =
            pop_item!(self, parameter_declaration, ParameterDeclaration, context);
        let module_item_1_built = ModuleItem1Builder::default()
            .parameter_declaration(Box::new(parameter_declaration))
            .build()
            .into_diagnostic()?;
        let module_item_1_built = ModuleItem::ModuleItem1(module_item_1_built);
        // Calling user action here
        self.user_grammar.module_item(&module_item_1_built)?;
        self.push(ASTType::ModuleItem(module_item_1_built), context);
        Ok(())
    }

    /// Semantic action for production 185:
    ///
    /// ModuleItem: LocalparamDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn module_item_2(
        &mut self,
        _localparam_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let localparam_declaration =
            pop_item!(self, localparam_declaration, LocalparamDeclaration, context);
        let module_item_2_built = ModuleItem2Builder::default()
            .localparam_declaration(Box::new(localparam_declaration))
            .build()
            .into_diagnostic()?;
        let module_item_2_built = ModuleItem::ModuleItem2(module_item_2_built);
        // Calling user action here
        self.user_grammar.module_item(&module_item_2_built)?;
        self.push(ASTType::ModuleItem(module_item_2_built), context);
        Ok(())
    }

    /// Semantic action for production 186:
    ///
    /// ModuleItem: AlwaysFfDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn module_item_3(
        &mut self,
        _always_ff_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let always_ff_declaration =
            pop_item!(self, always_ff_declaration, AlwaysFfDeclaration, context);
        let module_item_3_built = ModuleItem3Builder::default()
            .always_ff_declaration(Box::new(always_ff_declaration))
            .build()
            .into_diagnostic()?;
        let module_item_3_built = ModuleItem::ModuleItem3(module_item_3_built);
        // Calling user action here
        self.user_grammar.module_item(&module_item_3_built)?;
        self.push(ASTType::ModuleItem(module_item_3_built), context);
        Ok(())
    }

    /// Semantic action for production 187:
    ///
    /// ModuleItem: AlwaysCombDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn module_item_4(
        &mut self,
        _always_comb_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let always_comb_declaration = pop_item!(
            self,
            always_comb_declaration,
            AlwaysCombDeclaration,
            context
        );
        let module_item_4_built = ModuleItem4Builder::default()
            .always_comb_declaration(Box::new(always_comb_declaration))
            .build()
            .into_diagnostic()?;
        let module_item_4_built = ModuleItem::ModuleItem4(module_item_4_built);
        // Calling user action here
        self.user_grammar.module_item(&module_item_4_built)?;
        self.push(ASTType::ModuleItem(module_item_4_built), context);
        Ok(())
    }

    /// Semantic action for production 188:
    ///
    /// InterfaceDeclaration: Interface Identifier InterfaceDeclarationOpt /* Option */ LBrace InterfaceDeclarationList /* Vec */ RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn interface_declaration(
        &mut self,
        _interface: &ParseTreeStackEntry<'t>,
        _identifier: &ParseTreeStackEntry<'t>,
        _interface_declaration_opt: &ParseTreeStackEntry<'t>,
        _l_brace: &ParseTreeStackEntry<'t>,
        _interface_declaration_list: &ParseTreeStackEntry<'t>,
        _r_brace: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let interface_declaration_list = pop_and_reverse_item!(
            self,
            interface_declaration_list,
            InterfaceDeclarationList,
            context
        );
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let interface_declaration_opt = pop_item!(
            self,
            interface_declaration_opt,
            InterfaceDeclarationOpt,
            context
        );
        let identifier = pop_item!(self, identifier, Identifier, context);
        let interface = pop_item!(self, interface, Interface, context);
        let interface_declaration_built = InterfaceDeclarationBuilder::default()
            .interface(Box::new(interface))
            .identifier(Box::new(identifier))
            .interface_declaration_opt(interface_declaration_opt)
            .l_brace(Box::new(l_brace))
            .interface_declaration_list(interface_declaration_list)
            .r_brace(Box::new(r_brace))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .interface_declaration(&interface_declaration_built)?;
        self.push(
            ASTType::InterfaceDeclaration(interface_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 189:
    ///
    /// InterfaceDeclarationList /* Vec<T>::Push */: InterfaceItem InterfaceDeclarationList;
    ///
    #[parol_runtime::function_name::named]
    fn interface_declaration_list_0(
        &mut self,
        _interface_item: &ParseTreeStackEntry<'t>,
        _interface_declaration_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut interface_declaration_list = pop_item!(
            self,
            interface_declaration_list,
            InterfaceDeclarationList,
            context
        );
        let interface_item = pop_item!(self, interface_item, InterfaceItem, context);
        let interface_declaration_list_0_built = InterfaceDeclarationListBuilder::default()
            .interface_item(Box::new(interface_item))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        interface_declaration_list.push(interface_declaration_list_0_built);
        self.push(
            ASTType::InterfaceDeclarationList(interface_declaration_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 190:
    ///
    /// InterfaceDeclarationList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn interface_declaration_list_1(
        &mut self,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let interface_declaration_list_1_built = Vec::new();
        self.push(
            ASTType::InterfaceDeclarationList(interface_declaration_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 191:
    ///
    /// InterfaceDeclarationOpt /* Option<T>::Some */: WithParameter;
    ///
    #[parol_runtime::function_name::named]
    fn interface_declaration_opt_0(
        &mut self,
        _with_parameter: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let with_parameter = pop_item!(self, with_parameter, WithParameter, context);
        let interface_declaration_opt_0_built = InterfaceDeclarationOptBuilder::default()
            .with_parameter(Box::new(with_parameter))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::InterfaceDeclarationOpt(Some(Box::new(interface_declaration_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 192:
    ///
    /// InterfaceDeclarationOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn interface_declaration_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::InterfaceDeclarationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 193:
    ///
    /// InterfaceItem: VariableDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn interface_item_0(
        &mut self,
        _variable_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let variable_declaration =
            pop_item!(self, variable_declaration, VariableDeclaration, context);
        let interface_item_0_built = InterfaceItem0Builder::default()
            .variable_declaration(Box::new(variable_declaration))
            .build()
            .into_diagnostic()?;
        let interface_item_0_built = InterfaceItem::InterfaceItem0(interface_item_0_built);
        // Calling user action here
        self.user_grammar.interface_item(&interface_item_0_built)?;
        self.push(ASTType::InterfaceItem(interface_item_0_built), context);
        Ok(())
    }

    /// Semantic action for production 194:
    ///
    /// InterfaceItem: ParameterDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn interface_item_1(
        &mut self,
        _parameter_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let parameter_declaration =
            pop_item!(self, parameter_declaration, ParameterDeclaration, context);
        let interface_item_1_built = InterfaceItem1Builder::default()
            .parameter_declaration(Box::new(parameter_declaration))
            .build()
            .into_diagnostic()?;
        let interface_item_1_built = InterfaceItem::InterfaceItem1(interface_item_1_built);
        // Calling user action here
        self.user_grammar.interface_item(&interface_item_1_built)?;
        self.push(ASTType::InterfaceItem(interface_item_1_built), context);
        Ok(())
    }

    /// Semantic action for production 195:
    ///
    /// InterfaceItem: LocalparamDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn interface_item_2(
        &mut self,
        _localparam_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let localparam_declaration =
            pop_item!(self, localparam_declaration, LocalparamDeclaration, context);
        let interface_item_2_built = InterfaceItem2Builder::default()
            .localparam_declaration(Box::new(localparam_declaration))
            .build()
            .into_diagnostic()?;
        let interface_item_2_built = InterfaceItem::InterfaceItem2(interface_item_2_built);
        // Calling user action here
        self.user_grammar.interface_item(&interface_item_2_built)?;
        self.push(ASTType::InterfaceItem(interface_item_2_built), context);
        Ok(())
    }

    /// Semantic action for production 196:
    ///
    /// InterfaceItem: ModportDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn interface_item_3(
        &mut self,
        _modport_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let modport_declaration = pop_item!(self, modport_declaration, ModportDeclaration, context);
        let interface_item_3_built = InterfaceItem3Builder::default()
            .modport_declaration(Box::new(modport_declaration))
            .build()
            .into_diagnostic()?;
        let interface_item_3_built = InterfaceItem::InterfaceItem3(interface_item_3_built);
        // Calling user action here
        self.user_grammar.interface_item(&interface_item_3_built)?;
        self.push(ASTType::InterfaceItem(interface_item_3_built), context);
        Ok(())
    }

    /// Semantic action for production 197:
    ///
    /// VariableDeclaration: Identifier Colon Type Semicolon;
    ///
    #[parol_runtime::function_name::named]
    fn variable_declaration(
        &mut self,
        _identifier: &ParseTreeStackEntry<'t>,
        _colon: &ParseTreeStackEntry<'t>,
        _type: &ParseTreeStackEntry<'t>,
        _semicolon: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon = pop_item!(self, semicolon, Semicolon, context);
        let r#type = pop_item!(self, r#type, Type, context);
        let colon = pop_item!(self, colon, Colon, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let variable_declaration_built = VariableDeclarationBuilder::default()
            .identifier(Box::new(identifier))
            .colon(Box::new(colon))
            .r#type(Box::new(r#type))
            .semicolon(Box::new(semicolon))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .variable_declaration(&variable_declaration_built)?;
        self.push(
            ASTType::VariableDeclaration(variable_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 198:
    ///
    /// ParameterDeclaration: Parameter Identifier Colon Type Equ Expression Semicolon;
    ///
    #[parol_runtime::function_name::named]
    fn parameter_declaration(
        &mut self,
        _parameter: &ParseTreeStackEntry<'t>,
        _identifier: &ParseTreeStackEntry<'t>,
        _colon: &ParseTreeStackEntry<'t>,
        _type: &ParseTreeStackEntry<'t>,
        _equ: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _semicolon: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon = pop_item!(self, semicolon, Semicolon, context);
        let expression = pop_item!(self, expression, Expression, context);
        let equ = pop_item!(self, equ, Equ, context);
        let r#type = pop_item!(self, r#type, Type, context);
        let colon = pop_item!(self, colon, Colon, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let parameter = pop_item!(self, parameter, Parameter, context);
        let parameter_declaration_built = ParameterDeclarationBuilder::default()
            .parameter(Box::new(parameter))
            .identifier(Box::new(identifier))
            .colon(Box::new(colon))
            .r#type(Box::new(r#type))
            .equ(Box::new(equ))
            .expression(Box::new(expression))
            .semicolon(Box::new(semicolon))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .parameter_declaration(&parameter_declaration_built)?;
        self.push(
            ASTType::ParameterDeclaration(parameter_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 199:
    ///
    /// LocalparamDeclaration: Localparam Identifier Colon Type Equ Expression Semicolon;
    ///
    #[parol_runtime::function_name::named]
    fn localparam_declaration(
        &mut self,
        _localparam: &ParseTreeStackEntry<'t>,
        _identifier: &ParseTreeStackEntry<'t>,
        _colon: &ParseTreeStackEntry<'t>,
        _type: &ParseTreeStackEntry<'t>,
        _equ: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _semicolon: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon = pop_item!(self, semicolon, Semicolon, context);
        let expression = pop_item!(self, expression, Expression, context);
        let equ = pop_item!(self, equ, Equ, context);
        let r#type = pop_item!(self, r#type, Type, context);
        let colon = pop_item!(self, colon, Colon, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let localparam = pop_item!(self, localparam, Localparam, context);
        let localparam_declaration_built = LocalparamDeclarationBuilder::default()
            .localparam(Box::new(localparam))
            .identifier(Box::new(identifier))
            .colon(Box::new(colon))
            .r#type(Box::new(r#type))
            .equ(Box::new(equ))
            .expression(Box::new(expression))
            .semicolon(Box::new(semicolon))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .localparam_declaration(&localparam_declaration_built)?;
        self.push(
            ASTType::LocalparamDeclaration(localparam_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 200:
    ///
    /// AlwaysFfDeclaration: AlwaysFf LParen AlwaysFfConditions RParen LBrace AlwaysFfDeclarationList /* Vec */ RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_declaration(
        &mut self,
        _always_ff: &ParseTreeStackEntry<'t>,
        _l_paren: &ParseTreeStackEntry<'t>,
        _always_ff_conditions: &ParseTreeStackEntry<'t>,
        _r_paren: &ParseTreeStackEntry<'t>,
        _l_brace: &ParseTreeStackEntry<'t>,
        _always_ff_declaration_list: &ParseTreeStackEntry<'t>,
        _r_brace: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let always_ff_declaration_list = pop_and_reverse_item!(
            self,
            always_ff_declaration_list,
            AlwaysFfDeclarationList,
            context
        );
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let r_paren = pop_item!(self, r_paren, RParen, context);
        let always_ff_conditions =
            pop_item!(self, always_ff_conditions, AlwaysFfConditions, context);
        let l_paren = pop_item!(self, l_paren, LParen, context);
        let always_ff = pop_item!(self, always_ff, AlwaysFf, context);
        let always_ff_declaration_built = AlwaysFfDeclarationBuilder::default()
            .always_ff(Box::new(always_ff))
            .l_paren(Box::new(l_paren))
            .always_ff_conditions(Box::new(always_ff_conditions))
            .r_paren(Box::new(r_paren))
            .l_brace(Box::new(l_brace))
            .always_ff_declaration_list(always_ff_declaration_list)
            .r_brace(Box::new(r_brace))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .always_ff_declaration(&always_ff_declaration_built)?;
        self.push(
            ASTType::AlwaysFfDeclaration(always_ff_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 201:
    ///
    /// AlwaysFfDeclarationList /* Vec<T>::Push */: Statement AlwaysFfDeclarationList;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_declaration_list_0(
        &mut self,
        _statement: &ParseTreeStackEntry<'t>,
        _always_ff_declaration_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut always_ff_declaration_list = pop_item!(
            self,
            always_ff_declaration_list,
            AlwaysFfDeclarationList,
            context
        );
        let statement = pop_item!(self, statement, Statement, context);
        let always_ff_declaration_list_0_built = AlwaysFfDeclarationListBuilder::default()
            .statement(Box::new(statement))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        always_ff_declaration_list.push(always_ff_declaration_list_0_built);
        self.push(
            ASTType::AlwaysFfDeclarationList(always_ff_declaration_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 202:
    ///
    /// AlwaysFfDeclarationList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_declaration_list_1(
        &mut self,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let always_ff_declaration_list_1_built = Vec::new();
        self.push(
            ASTType::AlwaysFfDeclarationList(always_ff_declaration_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 203:
    ///
    /// AlwaysFfConditions: AlwaysFfCondition AlwaysFfConditionsList /* Vec */ AlwaysFfConditionsOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_conditions(
        &mut self,
        _always_ff_condition: &ParseTreeStackEntry<'t>,
        _always_ff_conditions_list: &ParseTreeStackEntry<'t>,
        _always_ff_conditions_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let always_ff_conditions_opt = pop_item!(
            self,
            always_ff_conditions_opt,
            AlwaysFfConditionsOpt,
            context
        );
        let always_ff_conditions_list = pop_and_reverse_item!(
            self,
            always_ff_conditions_list,
            AlwaysFfConditionsList,
            context
        );
        let always_ff_condition = pop_item!(self, always_ff_condition, AlwaysFfCondition, context);
        let always_ff_conditions_built = AlwaysFfConditionsBuilder::default()
            .always_ff_condition(Box::new(always_ff_condition))
            .always_ff_conditions_list(always_ff_conditions_list)
            .always_ff_conditions_opt(always_ff_conditions_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .always_ff_conditions(&always_ff_conditions_built)?;
        self.push(
            ASTType::AlwaysFfConditions(always_ff_conditions_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 204:
    ///
    /// AlwaysFfConditionsList /* Vec<T>::Push */: Comma AlwaysFfCondition AlwaysFfConditionsList;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_conditions_list_0(
        &mut self,
        _comma: &ParseTreeStackEntry<'t>,
        _always_ff_condition: &ParseTreeStackEntry<'t>,
        _always_ff_conditions_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut always_ff_conditions_list = pop_item!(
            self,
            always_ff_conditions_list,
            AlwaysFfConditionsList,
            context
        );
        let always_ff_condition = pop_item!(self, always_ff_condition, AlwaysFfCondition, context);
        let comma = pop_item!(self, comma, Comma, context);
        let always_ff_conditions_list_0_built = AlwaysFfConditionsListBuilder::default()
            .always_ff_condition(Box::new(always_ff_condition))
            .comma(Box::new(comma))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        always_ff_conditions_list.push(always_ff_conditions_list_0_built);
        self.push(
            ASTType::AlwaysFfConditionsList(always_ff_conditions_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 205:
    ///
    /// AlwaysFfConditionsList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_conditions_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let always_ff_conditions_list_1_built = Vec::new();
        self.push(
            ASTType::AlwaysFfConditionsList(always_ff_conditions_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 206:
    ///
    /// AlwaysFfConditionsOpt /* Option<T>::Some */: Comma;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_conditions_opt_0(
        &mut self,
        _comma: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = pop_item!(self, comma, Comma, context);
        let always_ff_conditions_opt_0_built = AlwaysFfConditionsOptBuilder::default()
            .comma(Box::new(comma))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::AlwaysFfConditionsOpt(Some(Box::new(always_ff_conditions_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 207:
    ///
    /// AlwaysFfConditionsOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_conditions_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::AlwaysFfConditionsOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 208:
    ///
    /// AlwaysFfCondition: AlwaysFfConditionGroup Identifier;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_condition(
        &mut self,
        _always_ff_condition_group: &ParseTreeStackEntry<'t>,
        _identifier: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let identifier = pop_item!(self, identifier, Identifier, context);
        let always_ff_condition_group = pop_item!(
            self,
            always_ff_condition_group,
            AlwaysFfConditionGroup,
            context
        );
        let always_ff_condition_built = AlwaysFfConditionBuilder::default()
            .always_ff_condition_group(Box::new(always_ff_condition_group))
            .identifier(Box::new(identifier))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .always_ff_condition(&always_ff_condition_built)?;
        self.push(
            ASTType::AlwaysFfCondition(always_ff_condition_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 209:
    ///
    /// AlwaysFfConditionGroup: Posedge;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_condition_group_0(
        &mut self,
        _posedge: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let posedge = pop_item!(self, posedge, Posedge, context);
        let always_ff_condition_group_0_built = AlwaysFfConditionGroup0Builder::default()
            .posedge(Box::new(posedge))
            .build()
            .into_diagnostic()?;
        let always_ff_condition_group_0_built =
            AlwaysFfConditionGroup::AlwaysFfConditionGroup0(always_ff_condition_group_0_built);
        self.push(
            ASTType::AlwaysFfConditionGroup(always_ff_condition_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 210:
    ///
    /// AlwaysFfConditionGroup: Negedge;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_condition_group_1(
        &mut self,
        _negedge: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let negedge = pop_item!(self, negedge, Negedge, context);
        let always_ff_condition_group_1_built = AlwaysFfConditionGroup1Builder::default()
            .negedge(Box::new(negedge))
            .build()
            .into_diagnostic()?;
        let always_ff_condition_group_1_built =
            AlwaysFfConditionGroup::AlwaysFfConditionGroup1(always_ff_condition_group_1_built);
        self.push(
            ASTType::AlwaysFfConditionGroup(always_ff_condition_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 211:
    ///
    /// AlwaysCombDeclaration: AlwaysComb LBrace AlwaysCombDeclarationList /* Vec */ RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn always_comb_declaration(
        &mut self,
        _always_comb: &ParseTreeStackEntry<'t>,
        _l_brace: &ParseTreeStackEntry<'t>,
        _always_comb_declaration_list: &ParseTreeStackEntry<'t>,
        _r_brace: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let always_comb_declaration_list = pop_and_reverse_item!(
            self,
            always_comb_declaration_list,
            AlwaysCombDeclarationList,
            context
        );
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let always_comb = pop_item!(self, always_comb, AlwaysComb, context);
        let always_comb_declaration_built = AlwaysCombDeclarationBuilder::default()
            .always_comb(Box::new(always_comb))
            .l_brace(Box::new(l_brace))
            .always_comb_declaration_list(always_comb_declaration_list)
            .r_brace(Box::new(r_brace))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .always_comb_declaration(&always_comb_declaration_built)?;
        self.push(
            ASTType::AlwaysCombDeclaration(always_comb_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 212:
    ///
    /// AlwaysCombDeclarationList /* Vec<T>::Push */: Statement AlwaysCombDeclarationList;
    ///
    #[parol_runtime::function_name::named]
    fn always_comb_declaration_list_0(
        &mut self,
        _statement: &ParseTreeStackEntry<'t>,
        _always_comb_declaration_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut always_comb_declaration_list = pop_item!(
            self,
            always_comb_declaration_list,
            AlwaysCombDeclarationList,
            context
        );
        let statement = pop_item!(self, statement, Statement, context);
        let always_comb_declaration_list_0_built = AlwaysCombDeclarationListBuilder::default()
            .statement(Box::new(statement))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        always_comb_declaration_list.push(always_comb_declaration_list_0_built);
        self.push(
            ASTType::AlwaysCombDeclarationList(always_comb_declaration_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 213:
    ///
    /// AlwaysCombDeclarationList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn always_comb_declaration_list_1(
        &mut self,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let always_comb_declaration_list_1_built = Vec::new();
        self.push(
            ASTType::AlwaysCombDeclarationList(always_comb_declaration_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 214:
    ///
    /// ModportDeclaration: Modport Identifier LBrace ModportList RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn modport_declaration(
        &mut self,
        _modport: &ParseTreeStackEntry<'t>,
        _identifier: &ParseTreeStackEntry<'t>,
        _l_brace: &ParseTreeStackEntry<'t>,
        _modport_list: &ParseTreeStackEntry<'t>,
        _r_brace: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let modport_list = pop_item!(self, modport_list, ModportList, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let modport = pop_item!(self, modport, Modport, context);
        let modport_declaration_built = ModportDeclarationBuilder::default()
            .modport(Box::new(modport))
            .identifier(Box::new(identifier))
            .l_brace(Box::new(l_brace))
            .modport_list(Box::new(modport_list))
            .r_brace(Box::new(r_brace))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .modport_declaration(&modport_declaration_built)?;
        self.push(
            ASTType::ModportDeclaration(modport_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 215:
    ///
    /// ModportList: ModportItem ModportListList /* Vec */ ModportListOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn modport_list(
        &mut self,
        _modport_item: &ParseTreeStackEntry<'t>,
        _modport_list_list: &ParseTreeStackEntry<'t>,
        _modport_list_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let modport_list_opt = pop_item!(self, modport_list_opt, ModportListOpt, context);
        let modport_list_list =
            pop_and_reverse_item!(self, modport_list_list, ModportListList, context);
        let modport_item = pop_item!(self, modport_item, ModportItem, context);
        let modport_list_built = ModportListBuilder::default()
            .modport_item(Box::new(modport_item))
            .modport_list_list(modport_list_list)
            .modport_list_opt(modport_list_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.modport_list(&modport_list_built)?;
        self.push(ASTType::ModportList(modport_list_built), context);
        Ok(())
    }

    /// Semantic action for production 216:
    ///
    /// ModportListList /* Vec<T>::Push */: Comma ModportItem ModportListList;
    ///
    #[parol_runtime::function_name::named]
    fn modport_list_list_0(
        &mut self,
        _comma: &ParseTreeStackEntry<'t>,
        _modport_item: &ParseTreeStackEntry<'t>,
        _modport_list_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut modport_list_list = pop_item!(self, modport_list_list, ModportListList, context);
        let modport_item = pop_item!(self, modport_item, ModportItem, context);
        let comma = pop_item!(self, comma, Comma, context);
        let modport_list_list_0_built = ModportListListBuilder::default()
            .modport_item(Box::new(modport_item))
            .comma(Box::new(comma))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        modport_list_list.push(modport_list_list_0_built);
        self.push(ASTType::ModportListList(modport_list_list), context);
        Ok(())
    }

    /// Semantic action for production 217:
    ///
    /// ModportListList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn modport_list_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let modport_list_list_1_built = Vec::new();
        self.push(ASTType::ModportListList(modport_list_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 218:
    ///
    /// ModportListOpt /* Option<T>::Some */: Comma;
    ///
    #[parol_runtime::function_name::named]
    fn modport_list_opt_0(
        &mut self,
        _comma: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = pop_item!(self, comma, Comma, context);
        let modport_list_opt_0_built = ModportListOptBuilder::default()
            .comma(Box::new(comma))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::ModportListOpt(Some(Box::new(modport_list_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 219:
    ///
    /// ModportListOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn modport_list_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ModportListOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 220:
    ///
    /// ModportItem: Identifier Colon Direction;
    ///
    #[parol_runtime::function_name::named]
    fn modport_item(
        &mut self,
        _identifier: &ParseTreeStackEntry<'t>,
        _colon: &ParseTreeStackEntry<'t>,
        _direction: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let direction = pop_item!(self, direction, Direction, context);
        let colon = pop_item!(self, colon, Colon, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let modport_item_built = ModportItemBuilder::default()
            .identifier(Box::new(identifier))
            .colon(Box::new(colon))
            .direction(Box::new(direction))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.modport_item(&modport_item_built)?;
        self.push(ASTType::ModportItem(modport_item_built), context);
        Ok(())
    }
}

impl<'t> UserActionsTrait<'t> for VerylGrammarAuto<'t, '_> {
    ///
    /// This function is implemented automatically for the user's item VerylGrammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeStackEntry<'t>],
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        match prod_num {
            0 => self.line_comment(&children[0], parse_tree),
            1 => self.block_comment(&children[0], parse_tree),
            2 => self.comments(&children[0], parse_tree),
            3 => self.comments_list_0(&children[0], &children[1], parse_tree),
            4 => self.comments_list_group_0(&children[0], parse_tree),
            5 => self.comments_list_group_1(&children[0], parse_tree),
            6 => self.comments_list_1(parse_tree),
            7 => self.comment(&children[0], parse_tree),
            8 => self.comment_opt_0(&children[0], parse_tree),
            9 => self.comment_opt_group_0(&children[0], parse_tree),
            10 => self.comment_opt_group_1(&children[0], parse_tree),
            11 => self.comment_opt_1(parse_tree),
            12 => self.start_token(&children[0], parse_tree),
            13 => self.start(&children[0], parse_tree),
            14 => self.based_binary_token(&children[0], &children[1], parse_tree),
            15 => self.based_octal_token(&children[0], &children[1], parse_tree),
            16 => self.based_decimal_token(&children[0], &children[1], parse_tree),
            17 => self.based_hex_token(&children[0], &children[1], parse_tree),
            18 => self.base_less_token(&children[0], &children[1], parse_tree),
            19 => self.based_binary(&children[0], parse_tree),
            20 => self.based_octal(&children[0], parse_tree),
            21 => self.based_decimal(&children[0], parse_tree),
            22 => self.based_hex(&children[0], parse_tree),
            23 => self.base_less(&children[0], parse_tree),
            24 => self.plus_token(&children[0], &children[1], parse_tree),
            25 => self.minus_token(&children[0], &children[1], parse_tree),
            26 => self.star_token(&children[0], &children[1], parse_tree),
            27 => self.slash_token(&children[0], &children[1], parse_tree),
            28 => self.colon_token(&children[0], &children[1], parse_tree),
            29 => self.semicolon_token(&children[0], &children[1], parse_tree),
            30 => self.comma_token(&children[0], &children[1], parse_tree),
            31 => self.l_paren_token(&children[0], &children[1], parse_tree),
            32 => self.r_paren_token(&children[0], &children[1], parse_tree),
            33 => self.l_bracket_token(&children[0], &children[1], parse_tree),
            34 => self.r_bracket_token(&children[0], &children[1], parse_tree),
            35 => self.l_brace_token(&children[0], &children[1], parse_tree),
            36 => self.r_brace_token(&children[0], &children[1], parse_tree),
            37 => self.equ_token(&children[0], &children[1], parse_tree),
            38 => self.hash_token(&children[0], &children[1], parse_tree),
            39 => self.plus(&children[0], parse_tree),
            40 => self.minus(&children[0], parse_tree),
            41 => self.star(&children[0], parse_tree),
            42 => self.slash(&children[0], parse_tree),
            43 => self.colon(&children[0], parse_tree),
            44 => self.semicolon(&children[0], parse_tree),
            45 => self.comma(&children[0], parse_tree),
            46 => self.l_paren(&children[0], parse_tree),
            47 => self.r_paren(&children[0], parse_tree),
            48 => self.l_bracket(&children[0], parse_tree),
            49 => self.r_bracket(&children[0], parse_tree),
            50 => self.l_brace(&children[0], parse_tree),
            51 => self.r_brace(&children[0], parse_tree),
            52 => self.equ(&children[0], parse_tree),
            53 => self.hash(&children[0], parse_tree),
            54 => self.logic_token(&children[0], &children[1], parse_tree),
            55 => self.bit_token(&children[0], &children[1], parse_tree),
            56 => self.always_ff_token(&children[0], &children[1], parse_tree),
            57 => self.always_comb_token(&children[0], &children[1], parse_tree),
            58 => self.posedge_token(&children[0], &children[1], parse_tree),
            59 => self.negedge_token(&children[0], &children[1], parse_tree),
            60 => self.if_token(&children[0], &children[1], parse_tree),
            61 => self.else_token(&children[0], &children[1], parse_tree),
            62 => self.parameter_token(&children[0], &children[1], parse_tree),
            63 => self.localparam_token(&children[0], &children[1], parse_tree),
            64 => self.module_token(&children[0], &children[1], parse_tree),
            65 => self.interface_token(&children[0], &children[1], parse_tree),
            66 => self.input_token(&children[0], &children[1], parse_tree),
            67 => self.output_token(&children[0], &children[1], parse_tree),
            68 => self.inout_token(&children[0], &children[1], parse_tree),
            69 => self.modport_token(&children[0], &children[1], parse_tree),
            70 => self.u32_token(&children[0], &children[1], parse_tree),
            71 => self.u64_token(&children[0], &children[1], parse_tree),
            72 => self.i32_token(&children[0], &children[1], parse_tree),
            73 => self.i64_token(&children[0], &children[1], parse_tree),
            74 => self.f32_token(&children[0], &children[1], parse_tree),
            75 => self.f64_token(&children[0], &children[1], parse_tree),
            76 => self.logic(&children[0], parse_tree),
            77 => self.bit(&children[0], parse_tree),
            78 => self.always_ff(&children[0], parse_tree),
            79 => self.always_comb(&children[0], parse_tree),
            80 => self.posedge(&children[0], parse_tree),
            81 => self.negedge(&children[0], parse_tree),
            82 => self.r#if(&children[0], parse_tree),
            83 => self.r#else(&children[0], parse_tree),
            84 => self.parameter(&children[0], parse_tree),
            85 => self.localparam(&children[0], parse_tree),
            86 => self.module(&children[0], parse_tree),
            87 => self.interface(&children[0], parse_tree),
            88 => self.input(&children[0], parse_tree),
            89 => self.output(&children[0], parse_tree),
            90 => self.inout(&children[0], parse_tree),
            91 => self.modport(&children[0], parse_tree),
            92 => self.u32(&children[0], parse_tree),
            93 => self.u64(&children[0], parse_tree),
            94 => self.i32(&children[0], parse_tree),
            95 => self.i64(&children[0], parse_tree),
            96 => self.f32(&children[0], parse_tree),
            97 => self.f64(&children[0], parse_tree),
            98 => self.identifier_token(&children[0], &children[1], parse_tree),
            99 => self.identifier(&children[0], parse_tree),
            100 => self.veryl(&children[0], &children[1], parse_tree),
            101 => self.veryl_list_0(&children[0], &children[1], parse_tree),
            102 => self.veryl_list_1(parse_tree),
            103 => self.description_0(&children[0], parse_tree),
            104 => self.description_1(&children[0], parse_tree),
            105 => self.number(&children[0], parse_tree),
            106 => self.integral_number_0(&children[0], parse_tree),
            107 => self.integral_number_1(&children[0], parse_tree),
            108 => self.integral_number_2(&children[0], parse_tree),
            109 => self.integral_number_3(&children[0], parse_tree),
            110 => self.integral_number_4(&children[0], parse_tree),
            111 => self.operator_precedence1_0(&children[0], parse_tree),
            112 => self.operator_precedence1_1(&children[0], parse_tree),
            113 => self.operator_precedence2_0(&children[0], parse_tree),
            114 => self.operator_precedence2_1(&children[0], parse_tree),
            115 => self.expression(&children[0], parse_tree),
            116 => self.expression0(&children[0], &children[1], parse_tree),
            117 => self.expression0_list_0(&children[0], &children[1], &children[2], parse_tree),
            118 => self.expression0_list_1(parse_tree),
            119 => self.expression1(&children[0], &children[1], parse_tree),
            120 => self.expression1_list_0(&children[0], &children[1], &children[2], parse_tree),
            121 => self.expression1_list_1(parse_tree),
            122 => self.expression2(&children[0], parse_tree),
            123 => self.factor_0(&children[0], parse_tree),
            124 => self.factor_1(&children[0], &children[1], parse_tree),
            125 => self.factor_list_0(&children[0], &children[1], parse_tree),
            126 => self.factor_list_1(parse_tree),
            127 => self.factor_2(&children[0], &children[1], &children[2], parse_tree),
            128 => self.statement_0(&children[0], parse_tree),
            129 => self.statement_1(&children[0], parse_tree),
            130 => self.assignment_statement(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            131 => self.if_statement(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
                parse_tree,
            ),
            132 => self.if_statement_list_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
                parse_tree,
            ),
            133 => self.if_statement_list_1(parse_tree),
            134 => self.if_statement_opt_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            135 => self.if_statement_opt_1(parse_tree),
            136 => self.range(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            137 => self.range_opt_0(&children[0], &children[1], parse_tree),
            138 => self.range_opt_1(parse_tree),
            139 => self.width(&children[0], &children[1], &children[2], parse_tree),
            140 => self.builtin_type_0(&children[0], parse_tree),
            141 => self.builtin_type_1(&children[0], parse_tree),
            142 => self.builtin_type_2(&children[0], parse_tree),
            143 => self.builtin_type_3(&children[0], parse_tree),
            144 => self.builtin_type_4(&children[0], parse_tree),
            145 => self.builtin_type_5(&children[0], parse_tree),
            146 => self.builtin_type_6(&children[0], parse_tree),
            147 => self.builtin_type_7(&children[0], parse_tree),
            148 => self.r#type(&children[0], &children[1], parse_tree),
            149 => self.type_group_0(&children[0], parse_tree),
            150 => self.type_group_1(&children[0], parse_tree),
            151 => self.type_list_0(&children[0], &children[1], parse_tree),
            152 => self.type_list_1(parse_tree),
            153 => self.with_parameter(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            154 => self.with_parameter_opt_0(&children[0], parse_tree),
            155 => self.with_parameter_opt_1(parse_tree),
            156 => self.with_parameter_list(&children[0], &children[1], &children[2], parse_tree),
            157 => self.with_parameter_list_list_0(
                &children[0],
                &children[1],
                &children[2],
                parse_tree,
            ),
            158 => self.with_parameter_list_list_1(parse_tree),
            159 => self.with_parameter_list_opt_0(&children[0], parse_tree),
            160 => self.with_parameter_list_opt_1(parse_tree),
            161 => self.with_parameter_item(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                parse_tree,
            ),
            162 => self.with_parameter_item_group_0(&children[0], parse_tree),
            163 => self.with_parameter_item_group_1(&children[0], parse_tree),
            164 => self.module_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
                parse_tree,
            ),
            165 => self.module_declaration_list_0(&children[0], &children[1], parse_tree),
            166 => self.module_declaration_list_1(parse_tree),
            167 => self.module_declaration_opt0_0(&children[0], parse_tree),
            168 => self.module_declaration_opt0_1(parse_tree),
            169 => self.module_declaration_opt_0(&children[0], parse_tree),
            170 => self.module_declaration_opt_1(parse_tree),
            171 => self.module_port(&children[0], &children[1], &children[2], parse_tree),
            172 => self.module_port_opt_0(&children[0], parse_tree),
            173 => self.module_port_opt_1(parse_tree),
            174 => self.module_port_list(&children[0], &children[1], &children[2], parse_tree),
            175 => {
                self.module_port_list_list_0(&children[0], &children[1], &children[2], parse_tree)
            }
            176 => self.module_port_list_list_1(parse_tree),
            177 => self.module_port_list_opt_0(&children[0], parse_tree),
            178 => self.module_port_list_opt_1(parse_tree),
            179 => self.module_port_item(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            180 => self.direction_0(&children[0], parse_tree),
            181 => self.direction_1(&children[0], parse_tree),
            182 => self.direction_2(&children[0], parse_tree),
            183 => self.module_item_0(&children[0], parse_tree),
            184 => self.module_item_1(&children[0], parse_tree),
            185 => self.module_item_2(&children[0], parse_tree),
            186 => self.module_item_3(&children[0], parse_tree),
            187 => self.module_item_4(&children[0], parse_tree),
            188 => self.interface_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                parse_tree,
            ),
            189 => self.interface_declaration_list_0(&children[0], &children[1], parse_tree),
            190 => self.interface_declaration_list_1(parse_tree),
            191 => self.interface_declaration_opt_0(&children[0], parse_tree),
            192 => self.interface_declaration_opt_1(parse_tree),
            193 => self.interface_item_0(&children[0], parse_tree),
            194 => self.interface_item_1(&children[0], parse_tree),
            195 => self.interface_item_2(&children[0], parse_tree),
            196 => self.interface_item_3(&children[0], parse_tree),
            197 => self.variable_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            198 => self.parameter_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
                parse_tree,
            ),
            199 => self.localparam_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
                parse_tree,
            ),
            200 => self.always_ff_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
                parse_tree,
            ),
            201 => self.always_ff_declaration_list_0(&children[0], &children[1], parse_tree),
            202 => self.always_ff_declaration_list_1(parse_tree),
            203 => self.always_ff_conditions(&children[0], &children[1], &children[2], parse_tree),
            204 => self.always_ff_conditions_list_0(
                &children[0],
                &children[1],
                &children[2],
                parse_tree,
            ),
            205 => self.always_ff_conditions_list_1(parse_tree),
            206 => self.always_ff_conditions_opt_0(&children[0], parse_tree),
            207 => self.always_ff_conditions_opt_1(parse_tree),
            208 => self.always_ff_condition(&children[0], &children[1], parse_tree),
            209 => self.always_ff_condition_group_0(&children[0], parse_tree),
            210 => self.always_ff_condition_group_1(&children[0], parse_tree),
            211 => self.always_comb_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            212 => self.always_comb_declaration_list_0(&children[0], &children[1], parse_tree),
            213 => self.always_comb_declaration_list_1(parse_tree),
            214 => self.modport_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                parse_tree,
            ),
            215 => self.modport_list(&children[0], &children[1], &children[2], parse_tree),
            216 => self.modport_list_list_0(&children[0], &children[1], &children[2], parse_tree),
            217 => self.modport_list_list_1(parse_tree),
            218 => self.modport_list_opt_0(&children[0], parse_tree),
            219 => self.modport_list_opt_1(parse_tree),
            220 => self.modport_item(&children[0], &children[1], &children[2], parse_tree),
            _ => Err(miette!("Unhandled production number: {}", prod_num)),
        }
    }
}
