use crate::git::Git;
use crate::metadata::{Dependency, Metadata};
use crate::metadata_error::MetadataError;
use crate::pubdata::{Pubdata, Release};
use crate::{utils, PathPair};
use semver::{Version, VersionReq};
use serde::{Deserialize, Serialize};
use std::collections::{HashMap, HashSet};
use std::fs;
use std::path::Path;
use std::str::FromStr;
use url::Url;
use uuid::Uuid;

#[derive(Clone, Debug, Default, Serialize, Deserialize)]
#[serde(deny_unknown_fields)]
pub struct Lockfile {
    pub projects: HashMap<Uuid, Lock>,
    #[serde(skip)]
    fetch: bool,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
#[serde(deny_unknown_fields)]
pub struct Lock {
    pub name: String,
    pub version: Version,
    pub url: Url,
    pub revision: String,
    pub dependencies: Vec<(String, Uuid)>,
}

impl Lockfile {
    pub fn load<T: AsRef<Path>>(path: T) -> Result<Self, MetadataError> {
        let path = path.as_ref().canonicalize()?;
        let text = fs::read_to_string(path)?;
        Self::from_str(&text)
    }

    pub fn save<T: AsRef<Path>>(&self, path: T) -> Result<(), MetadataError> {
        let mut text = String::new();
        text.push_str("# This file is automatically @generated by Veryl.\n");
        text.push_str("# It is not intended for manual editing.\n");
        text.push_str(&toml::to_string_pretty(&self)?);
        fs::write(&path, text.as_bytes())?;
        Ok(())
    }

    pub fn new(metadata: &Metadata) -> Result<Self, MetadataError> {
        let mut ret = Lockfile {
            fetch: true,
            ..Lockfile::default()
        };

        let mut name_table = HashSet::new();
        let mut uuid_table = HashSet::new();
        let locks = ret.gen_locks(metadata, &mut name_table, &mut uuid_table)?;
        for lock in locks {
            let uuid = Self::gen_uuid(&lock.url, &lock.revision)?;
            ret.projects.insert(uuid, lock);
        }

        Ok(ret)
    }

    pub fn update(&mut self, metadata: &Metadata, fetch: bool) -> Result<(), MetadataError> {
        self.fetch = fetch;

        let mut name_table = HashSet::new();
        let mut uuid_table = HashSet::new();
        for (uuid, lock) in &self.projects {
            name_table.insert(lock.name.clone());
            uuid_table.insert(*uuid);
        }

        let locks = self.gen_locks(metadata, &mut name_table, &mut uuid_table)?;
        for lock in locks {
            let uuid = Self::gen_uuid(&lock.url, &lock.revision)?;
            self.projects.insert(uuid, lock);
        }

        Ok(())
    }

    pub fn paths(&self, base_dst: &Path) -> Result<Vec<PathPair>, MetadataError> {
        let mut ret = Vec::new();

        for lock in self.projects.values() {
            let metadata = self.get_metadata(&lock.url, &lock.revision)?;
            let path = metadata.metadata_path.parent().unwrap();

            for src in &utils::gather_files_with_extension(path, "vl")? {
                let rel = src.strip_prefix(path)?;
                let mut dst = base_dst.join(&lock.name);
                dst.push(rel);
                dst.set_extension("sv");
                ret.push(PathPair {
                    prj: lock.name.clone(),
                    src: src.to_path_buf(),
                    dst,
                });
            }
        }

        Ok(ret)
    }

    fn gen_uuid(url: &Url, revision: &str) -> Result<Uuid, MetadataError> {
        let mut url = url.as_str().to_string();
        url.push_str(revision);
        Ok(Uuid::new_v5(&Uuid::NAMESPACE_URL, url.as_bytes()))
    }

    fn gen_locks(
        &self,
        metadata: &Metadata,
        name_table: &mut HashSet<String>,
        uuid_table: &mut HashSet<Uuid>,
    ) -> Result<Vec<Lock>, MetadataError> {
        let mut ret = Vec::new();

        for (url, dep) in &metadata.dependencies {
            let entries = self.resolve_dependency(url, dep)?;

            for (release, name) in entries {
                let uuid = Self::gen_uuid(url, &release.revision)?;
                let metadata = self.get_metadata(url, &release.revision)?;
                let mut name = name.unwrap_or(metadata.project.name.clone());
                if name_table.contains(&name) {
                    let mut suffix = 0;
                    loop {
                        let new_name = format!("{name}_{suffix}");
                        if !name_table.contains(&new_name) {
                            name = new_name;
                            break;
                        }
                        suffix += 1;
                    }
                }
                name_table.insert(name.clone());

                let mut dependencies = Vec::new();
                for (url, dep) in &metadata.dependencies {
                    let entries = self.resolve_dependency(url, dep)?;
                    for (release, name) in entries {
                        let uuid = Self::gen_uuid(url, &release.revision)?;
                        let metadata = self.get_metadata(url, &release.revision)?;
                        let name = name.unwrap_or(metadata.project.name.clone());
                        // project local name is not required to check name_table

                        dependencies.push((name.clone(), uuid));
                    }
                }

                let lock = Lock {
                    name: name.clone(),
                    version: release.version,
                    url: url.clone(),
                    revision: release.revision,
                    dependencies,
                };

                if !uuid_table.contains(&uuid) {
                    ret.push(lock);
                    uuid_table.insert(uuid);
                    let mut locks = self.gen_locks(&metadata, name_table, uuid_table)?;
                    ret.append(&mut locks);
                }
            }
        }

        Ok(ret)
    }

    fn resolve_dependency(
        &self,
        url: &Url,
        dep: &Dependency,
    ) -> Result<Vec<(Release, Option<String>)>, MetadataError> {
        Ok(match dep {
            Dependency::Version(x) => {
                let release = self.resolve_version(url, x)?;
                vec![(release, None)]
            }
            Dependency::Single(x) => {
                let release = self.resolve_version(url, &x.version)?;
                vec![(release, Some(x.name.clone()))]
            }
            Dependency::Multi(x) => {
                let mut ret = Vec::new();
                for x in x {
                    let release = self.resolve_version(url, &x.version)?;
                    ret.push((release, Some(x.name.clone())));
                }
                ret
            }
        })
    }

    fn resolve_version(
        &self,
        url: &Url,
        version_req: &VersionReq,
    ) -> Result<Release, MetadataError> {
        let resolve_dir = Metadata::cache_dir().join("resolve");

        if !resolve_dir.exists() {
            fs::create_dir_all(&resolve_dir)?;
        }

        let uuid = Self::gen_uuid(url, "")?;

        let path = resolve_dir.join(uuid.simple().encode_lower(&mut Uuid::encode_buffer()));
        let git = Git::clone(url, &path)?;
        if self.fetch {
            git.fetch()?;
        }
        git.checkout(None)?;

        let toml = path.join("Veryl.pub");
        let mut pubdata = Pubdata::load(&toml)?;

        pubdata.releases.sort_by(|a, b| b.version.cmp(&a.version));

        for release in &pubdata.releases {
            if version_req.matches(&release.version) {
                return Ok(release.clone());
            }
        }

        Err(MetadataError::VersionNotFound {
            url: url.clone(),
            version: version_req.to_string(),
        })
    }

    fn get_metadata(&self, url: &Url, revision: &str) -> Result<Metadata, MetadataError> {
        let dependencies_dir = Metadata::cache_dir().join("dependencies");

        if !dependencies_dir.exists() {
            fs::create_dir_all(&dependencies_dir)?;
        }

        let uuid = Self::gen_uuid(url, revision)?;

        let path = dependencies_dir.join(uuid.simple().encode_lower(&mut Uuid::encode_buffer()));
        let git = Git::clone(url, &path)?;
        if self.fetch {
            git.fetch()?;
        }
        git.checkout(Some(revision))?;

        let toml = path.join("Veryl.toml");
        let metadata = Metadata::load(toml)?;
        Ok(metadata)
    }
}

impl FromStr for Lockfile {
    type Err = MetadataError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let lockfile: Lockfile = toml::from_str(s)?;
        Ok(lockfile)
    }
}
