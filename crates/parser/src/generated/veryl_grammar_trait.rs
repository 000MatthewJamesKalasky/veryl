// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

use parol_runtime::derive_builder::Builder;
use parol_runtime::id_tree::Tree;
#[allow(unused_imports)]
use parol_runtime::parol_macros::{pop_and_reverse_item, pop_item};

use parol_runtime::log::trace;
#[allow(unused_imports)]
use parol_runtime::miette::{bail, miette, IntoDiagnostic, Result};
use parol_runtime::parser::{ParseTreeStackEntry, ParseTreeType, UserActionsTrait};

use std::marker::PhantomData;

/// Semantic actions trait generated for the user grammar
/// All functions have default implementations.
pub trait VerylGrammarTrait {
    /// Semantic action for non-terminal 'MultiComment'
    fn multi_comment(&mut self, _arg: &MultiComment) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Comments'
    fn comments(&mut self, _arg: &Comments) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StartToken'
    fn start_token(&mut self, _arg: &StartToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Start'
    fn start(&mut self, _arg: &Start) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ExponentToken'
    fn exponent_token(&mut self, _arg: &ExponentToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'FixedPointToken'
    fn fixed_point_token(&mut self, _arg: &FixedPointToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BasedBinaryToken'
    fn based_binary_token(&mut self, _arg: &BasedBinaryToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BasedOctalToken'
    fn based_octal_token(&mut self, _arg: &BasedOctalToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BasedDecimalToken'
    fn based_decimal_token(&mut self, _arg: &BasedDecimalToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BasedHexToken'
    fn based_hex_token(&mut self, _arg: &BasedHexToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BaseLessToken'
    fn base_less_token(&mut self, _arg: &BaseLessToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AllBitToken'
    fn all_bit_token(&mut self, _arg: &AllBitToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Exponent'
    fn exponent(&mut self, _arg: &Exponent) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'FixedPoint'
    fn fixed_point(&mut self, _arg: &FixedPoint) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BasedBinary'
    fn based_binary(&mut self, _arg: &BasedBinary) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BasedOctal'
    fn based_octal(&mut self, _arg: &BasedOctal) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BasedDecimal'
    fn based_decimal(&mut self, _arg: &BasedDecimal) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BasedHex'
    fn based_hex(&mut self, _arg: &BasedHex) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BaseLess'
    fn base_less(&mut self, _arg: &BaseLess) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AllBit'
    fn all_bit(&mut self, _arg: &AllBit) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BangEquEquToken'
    fn bang_equ_equ_token(&mut self, _arg: &BangEquEquToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BangEquQuestToken'
    fn bang_equ_quest_token(&mut self, _arg: &BangEquQuestToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EquEquEquToken'
    fn equ_equ_equ_token(&mut self, _arg: &EquEquEquToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EquEquQuestToken'
    fn equ_equ_quest_token(&mut self, _arg: &EquEquQuestToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'GTGTGTToken'
    fn g_t_g_t_g_t_token(&mut self, _arg: &GTGTGTToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LTLTLTToken'
    fn l_t_l_t_l_t_token(&mut self, _arg: &LTLTLTToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BangEquEqu'
    fn bang_equ_equ(&mut self, _arg: &BangEquEqu) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BangEquQuest'
    fn bang_equ_quest(&mut self, _arg: &BangEquQuest) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EquEquEqu'
    fn equ_equ_equ(&mut self, _arg: &EquEquEqu) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EquEquQuest'
    fn equ_equ_quest(&mut self, _arg: &EquEquQuest) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'GTGTGT'
    fn g_t_g_t_g_t(&mut self, _arg: &GTGTGT) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LTLTLT'
    fn l_t_l_t_l_t(&mut self, _arg: &LTLTLT) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AmpAmpToken'
    fn amp_amp_token(&mut self, _arg: &AmpAmpToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'CircumflexTildeToken'
    fn circumflex_tilde_token(&mut self, _arg: &CircumflexTildeToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BangEquToken'
    fn bang_equ_token(&mut self, _arg: &BangEquToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EquEquToken'
    fn equ_equ_token(&mut self, _arg: &EquEquToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'GTEquToken'
    fn g_t_equ_token(&mut self, _arg: &GTEquToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'GTGTToken'
    fn g_t_g_t_token(&mut self, _arg: &GTGTToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LTEquToken'
    fn l_t_equ_token(&mut self, _arg: &LTEquToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LTLTToken'
    fn l_t_l_t_token(&mut self, _arg: &LTLTToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'OrOrToken'
    fn or_or_token(&mut self, _arg: &OrOrToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StarStarToken'
    fn star_star_token(&mut self, _arg: &StarStarToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TildeAmpToken'
    fn tilde_amp_token(&mut self, _arg: &TildeAmpToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TildeCircumflexToken'
    fn tilde_circumflex_token(&mut self, _arg: &TildeCircumflexToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TildeOrToken'
    fn tilde_or_token(&mut self, _arg: &TildeOrToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AmpAmp'
    fn amp_amp(&mut self, _arg: &AmpAmp) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'CircumflexTilde'
    fn circumflex_tilde(&mut self, _arg: &CircumflexTilde) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BangEqu'
    fn bang_equ(&mut self, _arg: &BangEqu) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EquEqu'
    fn equ_equ(&mut self, _arg: &EquEqu) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'GTEqu'
    fn g_t_equ(&mut self, _arg: &GTEqu) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'GTGT'
    fn g_t_g_t(&mut self, _arg: &GTGT) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LTEqu'
    fn l_t_equ(&mut self, _arg: &LTEqu) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LTLT'
    fn l_t_l_t(&mut self, _arg: &LTLT) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'OrOr'
    fn or_or(&mut self, _arg: &OrOr) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StarStar'
    fn star_star(&mut self, _arg: &StarStar) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TildeAmp'
    fn tilde_amp(&mut self, _arg: &TildeAmp) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TildeCircumflex'
    fn tilde_circumflex(&mut self, _arg: &TildeCircumflex) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TildeOr'
    fn tilde_or(&mut self, _arg: &TildeOr) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AmpToken'
    fn amp_token(&mut self, _arg: &AmpToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BangToken'
    fn bang_token(&mut self, _arg: &BangToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ColonToken'
    fn colon_token(&mut self, _arg: &ColonToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'CommaToken'
    fn comma_token(&mut self, _arg: &CommaToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'CircumflexToken'
    fn circumflex_token(&mut self, _arg: &CircumflexToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EquToken'
    fn equ_token(&mut self, _arg: &EquToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'GTToken'
    fn g_t_token(&mut self, _arg: &GTToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'HashToken'
    fn hash_token(&mut self, _arg: &HashToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LBraceToken'
    fn l_brace_token(&mut self, _arg: &LBraceToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LBracketToken'
    fn l_bracket_token(&mut self, _arg: &LBracketToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LParenToken'
    fn l_paren_token(&mut self, _arg: &LParenToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LTToken'
    fn l_t_token(&mut self, _arg: &LTToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MinusToken'
    fn minus_token(&mut self, _arg: &MinusToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'OrToken'
    fn or_token(&mut self, _arg: &OrToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PercentToken'
    fn percent_token(&mut self, _arg: &PercentToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PlusToken'
    fn plus_token(&mut self, _arg: &PlusToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RBraceToken'
    fn r_brace_token(&mut self, _arg: &RBraceToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RBracketToken'
    fn r_bracket_token(&mut self, _arg: &RBracketToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RParenToken'
    fn r_paren_token(&mut self, _arg: &RParenToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'SemicolonToken'
    fn semicolon_token(&mut self, _arg: &SemicolonToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'SlashToken'
    fn slash_token(&mut self, _arg: &SlashToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StarToken'
    fn star_token(&mut self, _arg: &StarToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TildeToken'
    fn tilde_token(&mut self, _arg: &TildeToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Amp'
    fn amp(&mut self, _arg: &Amp) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Bang'
    fn bang(&mut self, _arg: &Bang) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Circumflex'
    fn circumflex(&mut self, _arg: &Circumflex) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Colon'
    fn colon(&mut self, _arg: &Colon) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Comma'
    fn comma(&mut self, _arg: &Comma) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Equ'
    fn equ(&mut self, _arg: &Equ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'GT'
    fn g_t(&mut self, _arg: &GT) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Hash'
    fn hash(&mut self, _arg: &Hash) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LBrace'
    fn l_brace(&mut self, _arg: &LBrace) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LBracket'
    fn l_bracket(&mut self, _arg: &LBracket) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LParen'
    fn l_paren(&mut self, _arg: &LParen) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LT'
    fn l_t(&mut self, _arg: &LT) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Minus'
    fn minus(&mut self, _arg: &Minus) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Or'
    fn or(&mut self, _arg: &Or) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Percent'
    fn percent(&mut self, _arg: &Percent) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Plus'
    fn plus(&mut self, _arg: &Plus) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RBrace'
    fn r_brace(&mut self, _arg: &RBrace) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RBracket'
    fn r_bracket(&mut self, _arg: &RBracket) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RParen'
    fn r_paren(&mut self, _arg: &RParen) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Semicolon'
    fn semicolon(&mut self, _arg: &Semicolon) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Slash'
    fn slash(&mut self, _arg: &Slash) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Star'
    fn star(&mut self, _arg: &Star) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Tilde'
    fn tilde(&mut self, _arg: &Tilde) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AlwaysCombToken'
    fn always_comb_token(&mut self, _arg: &AlwaysCombToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AlwaysFfToken'
    fn always_ff_token(&mut self, _arg: &AlwaysFfToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AssignToken'
    fn assign_token(&mut self, _arg: &AssignToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BitToken'
    fn bit_token(&mut self, _arg: &BitToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ElseToken'
    fn else_token(&mut self, _arg: &ElseToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'F32Token'
    fn f32_token(&mut self, _arg: &F32Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'F64Token'
    fn f64_token(&mut self, _arg: &F64Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'I32Token'
    fn i32_token(&mut self, _arg: &I32Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'I64Token'
    fn i64_token(&mut self, _arg: &I64Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IfToken'
    fn if_token(&mut self, _arg: &IfToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InoutToken'
    fn inout_token(&mut self, _arg: &InoutToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InputToken'
    fn input_token(&mut self, _arg: &InputToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InterfaceToken'
    fn interface_token(&mut self, _arg: &InterfaceToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LocalparamToken'
    fn localparam_token(&mut self, _arg: &LocalparamToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LogicToken'
    fn logic_token(&mut self, _arg: &LogicToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModportToken'
    fn modport_token(&mut self, _arg: &ModportToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModuleToken'
    fn module_token(&mut self, _arg: &ModuleToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'NegedgeToken'
    fn negedge_token(&mut self, _arg: &NegedgeToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'OutputToken'
    fn output_token(&mut self, _arg: &OutputToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ParameterToken'
    fn parameter_token(&mut self, _arg: &ParameterToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PosedgeToken'
    fn posedge_token(&mut self, _arg: &PosedgeToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'U32Token'
    fn u32_token(&mut self, _arg: &U32Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'U64Token'
    fn u64_token(&mut self, _arg: &U64Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AlwaysComb'
    fn always_comb(&mut self, _arg: &AlwaysComb) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AlwaysFf'
    fn always_ff(&mut self, _arg: &AlwaysFf) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Assign'
    fn assign(&mut self, _arg: &Assign) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Bit'
    fn bit(&mut self, _arg: &Bit) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Else'
    fn r#else(&mut self, _arg: &Else) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'F32'
    fn f32(&mut self, _arg: &F32) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'F64'
    fn f64(&mut self, _arg: &F64) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'I32'
    fn i32(&mut self, _arg: &I32) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'I64'
    fn i64(&mut self, _arg: &I64) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'If'
    fn r#if(&mut self, _arg: &If) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Inout'
    fn inout(&mut self, _arg: &Inout) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Input'
    fn input(&mut self, _arg: &Input) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Interface'
    fn interface(&mut self, _arg: &Interface) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Localparam'
    fn localparam(&mut self, _arg: &Localparam) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Logic'
    fn logic(&mut self, _arg: &Logic) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Modport'
    fn modport(&mut self, _arg: &Modport) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Module'
    fn module(&mut self, _arg: &Module) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Negedge'
    fn negedge(&mut self, _arg: &Negedge) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Output'
    fn output(&mut self, _arg: &Output) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Parameter'
    fn parameter(&mut self, _arg: &Parameter) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Posedge'
    fn posedge(&mut self, _arg: &Posedge) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'U32'
    fn u32(&mut self, _arg: &U32) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'U64'
    fn u64(&mut self, _arg: &U64) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IdentifierToken'
    fn identifier_token(&mut self, _arg: &IdentifierToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Identifier'
    fn identifier(&mut self, _arg: &Identifier) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Veryl'
    fn veryl(&mut self, _arg: &Veryl) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Description'
    fn description(&mut self, _arg: &Description) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Number'
    fn number(&mut self, _arg: &Number) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IntegralNumber'
    fn integral_number(&mut self, _arg: &IntegralNumber) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RealNumber'
    fn real_number(&mut self, _arg: &RealNumber) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'OperatorPrecedence01'
    fn operator_precedence01(&mut self, _arg: &OperatorPrecedence01) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'OperatorPrecedence02'
    fn operator_precedence02(&mut self, _arg: &OperatorPrecedence02) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'OperatorPrecedence03'
    fn operator_precedence03(&mut self, _arg: &OperatorPrecedence03) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'OperatorPrecedence04'
    fn operator_precedence04(&mut self, _arg: &OperatorPrecedence04) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'OperatorPrecedence05'
    fn operator_precedence05(&mut self, _arg: &OperatorPrecedence05) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'OperatorPrecedence06'
    fn operator_precedence06(&mut self, _arg: &OperatorPrecedence06) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'OperatorPrecedence07'
    fn operator_precedence07(&mut self, _arg: &OperatorPrecedence07) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'OperatorPrecedence08'
    fn operator_precedence08(&mut self, _arg: &OperatorPrecedence08) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'OperatorPrecedence09'
    fn operator_precedence09(&mut self, _arg: &OperatorPrecedence09) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'OperatorPrecedence10'
    fn operator_precedence10(&mut self, _arg: &OperatorPrecedence10) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'OperatorPrecedence11'
    fn operator_precedence11(&mut self, _arg: &OperatorPrecedence11) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'OperatorPrecedence12'
    fn operator_precedence12(&mut self, _arg: &OperatorPrecedence12) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression'
    fn expression(&mut self, _arg: &Expression) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression00'
    fn expression00(&mut self, _arg: &Expression00) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression01'
    fn expression01(&mut self, _arg: &Expression01) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression02'
    fn expression02(&mut self, _arg: &Expression02) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression03'
    fn expression03(&mut self, _arg: &Expression03) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression04'
    fn expression04(&mut self, _arg: &Expression04) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression05'
    fn expression05(&mut self, _arg: &Expression05) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression06'
    fn expression06(&mut self, _arg: &Expression06) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression07'
    fn expression07(&mut self, _arg: &Expression07) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression08'
    fn expression08(&mut self, _arg: &Expression08) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression09'
    fn expression09(&mut self, _arg: &Expression09) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression10'
    fn expression10(&mut self, _arg: &Expression10) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression11'
    fn expression11(&mut self, _arg: &Expression11) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression12'
    fn expression12(&mut self, _arg: &Expression12) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Factor'
    fn factor(&mut self, _arg: &Factor) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Statement'
    fn statement(&mut self, _arg: &Statement) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AssignmentStatement'
    fn assignment_statement(&mut self, _arg: &AssignmentStatement) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IfStatement'
    fn if_statement(&mut self, _arg: &IfStatement) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Range'
    fn range(&mut self, _arg: &Range) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Width'
    fn width(&mut self, _arg: &Width) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BuiltinType'
    fn builtin_type(&mut self, _arg: &BuiltinType) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Type'
    fn r#type(&mut self, _arg: &Type) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WithParameter'
    fn with_parameter(&mut self, _arg: &WithParameter) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WithParameterList'
    fn with_parameter_list(&mut self, _arg: &WithParameterList) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WithParameterItem'
    fn with_parameter_item(&mut self, _arg: &WithParameterItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModuleDeclaration'
    fn module_declaration(&mut self, _arg: &ModuleDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModulePort'
    fn module_port(&mut self, _arg: &ModulePort) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModulePortList'
    fn module_port_list(&mut self, _arg: &ModulePortList) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModulePortItem'
    fn module_port_item(&mut self, _arg: &ModulePortItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Direction'
    fn direction(&mut self, _arg: &Direction) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModuleItem'
    fn module_item(&mut self, _arg: &ModuleItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InterfaceDeclaration'
    fn interface_declaration(&mut self, _arg: &InterfaceDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InterfaceItem'
    fn interface_item(&mut self, _arg: &InterfaceItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'VariableDeclaration'
    fn variable_declaration(&mut self, _arg: &VariableDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ParameterDeclaration'
    fn parameter_declaration(&mut self, _arg: &ParameterDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LocalparamDeclaration'
    fn localparam_declaration(&mut self, _arg: &LocalparamDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AlwaysFfDeclaration'
    fn always_ff_declaration(&mut self, _arg: &AlwaysFfDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AlwaysFfConditions'
    fn always_ff_conditions(&mut self, _arg: &AlwaysFfConditions) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AlwaysFfCondition'
    fn always_ff_condition(&mut self, _arg: &AlwaysFfCondition) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AlwaysCombDeclaration'
    fn always_comb_declaration(&mut self, _arg: &AlwaysCombDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AssignDeclaration'
    fn assign_declaration(&mut self, _arg: &AssignDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModportDeclaration'
    fn modport_declaration(&mut self, _arg: &ModportDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModportList'
    fn modport_list(&mut self, _arg: &ModportList) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModportItem'
    fn modport_item(&mut self, _arg: &ModportItem) -> Result<()> {
        Ok(())
    }
}

// -------------------------------------------------------------------------------------------------
//
// Output Types of productions deduced from the structure of the transformed grammar
//

///
/// Type derived for production 157
///
/// Description: ModuleDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Description0 {
    pub module_declaration: Box<ModuleDeclaration>,
}

///
/// Type derived for production 158
///
/// Description: InterfaceDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Description1 {
    pub interface_declaration: Box<InterfaceDeclaration>,
}

///
/// Type derived for production 159
///
/// Number: IntegralNumber;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Number0 {
    pub integral_number: Box<IntegralNumber>,
}

///
/// Type derived for production 160
///
/// Number: RealNumber;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Number1 {
    pub real_number: Box<RealNumber>,
}

///
/// Type derived for production 161
///
/// IntegralNumber: BasedBinary;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct IntegralNumber0 {
    pub based_binary: Box<BasedBinary>,
}

///
/// Type derived for production 162
///
/// IntegralNumber: BasedOctal;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct IntegralNumber1 {
    pub based_octal: Box<BasedOctal>,
}

///
/// Type derived for production 163
///
/// IntegralNumber: BasedDecimal;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct IntegralNumber2 {
    pub based_decimal: Box<BasedDecimal>,
}

///
/// Type derived for production 164
///
/// IntegralNumber: BasedHex;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct IntegralNumber3 {
    pub based_hex: Box<BasedHex>,
}

///
/// Type derived for production 165
///
/// IntegralNumber: BaseLess;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct IntegralNumber4 {
    pub base_less: Box<BaseLess>,
}

///
/// Type derived for production 166
///
/// IntegralNumber: AllBit;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct IntegralNumber5 {
    pub all_bit: Box<AllBit>,
}

///
/// Type derived for production 167
///
/// RealNumber: FixedPoint;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct RealNumber0 {
    pub fixed_point: Box<FixedPoint>,
}

///
/// Type derived for production 168
///
/// RealNumber: Exponent;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct RealNumber1 {
    pub exponent: Box<Exponent>,
}

///
/// Type derived for production 172
///
/// OperatorPrecedence04: Circumflex;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct OperatorPrecedence4 {
    pub circumflex: Box<Circumflex>,
}

///
/// Type derived for production 173
///
/// OperatorPrecedence04: TildeCircumflex;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct OperatorPrecedence5 {
    pub tilde_circumflex: Box<TildeCircumflex>,
}

///
/// Type derived for production 174
///
/// OperatorPrecedence04: CircumflexTilde;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct OperatorPrecedence6 {
    pub circumflex_tilde: Box<CircumflexTilde>,
}

///
/// Type derived for production 176
///
/// OperatorPrecedence06: EquEqu;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct OperatorPrecedence8 {
    pub equ_equ: Box<EquEqu>,
}

///
/// Type derived for production 177
///
/// OperatorPrecedence06: BangEqu;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct OperatorPrecedence9 {
    pub bang_equ: Box<BangEqu>,
}

///
/// Type derived for production 178
///
/// OperatorPrecedence06: EquEquEqu;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct OperatorPrecedence13 {
    pub equ_equ_equ: Box<EquEquEqu>,
}

///
/// Type derived for production 179
///
/// OperatorPrecedence06: BangEquEqu;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct OperatorPrecedence14 {
    pub bang_equ_equ: Box<BangEquEqu>,
}

///
/// Type derived for production 180
///
/// OperatorPrecedence06: EquEquQuest;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct OperatorPrecedence15 {
    pub equ_equ_quest: Box<EquEquQuest>,
}

///
/// Type derived for production 181
///
/// OperatorPrecedence06: BangEquQuest;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct OperatorPrecedence16 {
    pub bang_equ_quest: Box<BangEquQuest>,
}

///
/// Type derived for production 182
///
/// OperatorPrecedence07: LT;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct OperatorPrecedence17 {
    pub l_t: Box<LT>,
}

///
/// Type derived for production 183
///
/// OperatorPrecedence07: LTEqu;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct OperatorPrecedence18 {
    pub l_t_equ: Box<LTEqu>,
}

///
/// Type derived for production 184
///
/// OperatorPrecedence07: GT;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct OperatorPrecedence19 {
    pub g_t: Box<GT>,
}

///
/// Type derived for production 185
///
/// OperatorPrecedence07: GTEqu;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct OperatorPrecedence20 {
    pub g_t_equ: Box<GTEqu>,
}

///
/// Type derived for production 186
///
/// OperatorPrecedence08: LTLT;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct OperatorPrecedence21 {
    pub l_t_l_t: Box<LTLT>,
}

///
/// Type derived for production 187
///
/// OperatorPrecedence08: GTGT;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct OperatorPrecedence22 {
    pub g_t_g_t: Box<GTGT>,
}

///
/// Type derived for production 188
///
/// OperatorPrecedence08: LTLTLT;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct OperatorPrecedence23 {
    pub l_t_l_t_l_t: Box<LTLTLT>,
}

///
/// Type derived for production 189
///
/// OperatorPrecedence08: GTGTGT;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct OperatorPrecedence24 {
    pub g_t_g_t_g_t: Box<GTGTGT>,
}

///
/// Type derived for production 190
///
/// OperatorPrecedence09: Plus;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct OperatorPrecedence25 {
    pub plus: Box<Plus>,
}

///
/// Type derived for production 191
///
/// OperatorPrecedence09: Minus;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct OperatorPrecedence26 {
    pub minus: Box<Minus>,
}

///
/// Type derived for production 192
///
/// OperatorPrecedence10: Star;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct OperatorPrecedence27 {
    pub star: Box<Star>,
}

///
/// Type derived for production 193
///
/// OperatorPrecedence10: Slash;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct OperatorPrecedence28 {
    pub slash: Box<Slash>,
}

///
/// Type derived for production 194
///
/// OperatorPrecedence10: Percent;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct OperatorPrecedence29 {
    pub percent: Box<Percent>,
}

///
/// Type derived for production 196
///
/// OperatorPrecedence12: Plus;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct OperatorPrecedence31 {
    pub plus: Box<Plus>,
}

///
/// Type derived for production 197
///
/// OperatorPrecedence12: Minus;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct OperatorPrecedence32 {
    pub minus: Box<Minus>,
}

///
/// Type derived for production 198
///
/// OperatorPrecedence12: Bang;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct OperatorPrecedence33 {
    pub bang: Box<Bang>,
}

///
/// Type derived for production 199
///
/// OperatorPrecedence12: Tilde;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct OperatorPrecedence34 {
    pub tilde: Box<Tilde>,
}

///
/// Type derived for production 200
///
/// OperatorPrecedence12: Amp;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct OperatorPrecedence35 {
    pub amp: Box<Amp>,
}

///
/// Type derived for production 201
///
/// OperatorPrecedence12: Or;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct OperatorPrecedence36 {
    pub or: Box<Or>,
}

///
/// Type derived for production 202
///
/// OperatorPrecedence12: Circumflex;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct OperatorPrecedence37 {
    pub circumflex: Box<Circumflex>,
}

///
/// Type derived for production 203
///
/// OperatorPrecedence12: TildeAmp;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct OperatorPrecedence38 {
    pub tilde_amp: Box<TildeAmp>,
}

///
/// Type derived for production 204
///
/// OperatorPrecedence12: TildeOr;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct OperatorPrecedence39 {
    pub tilde_or: Box<TildeOr>,
}

///
/// Type derived for production 205
///
/// OperatorPrecedence12: TildeCircumflex;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct OperatorPrecedence40 {
    pub tilde_circumflex: Box<TildeCircumflex>,
}

///
/// Type derived for production 206
///
/// OperatorPrecedence12: CircumflexTilde;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct OperatorPrecedence41 {
    pub circumflex_tilde: Box<CircumflexTilde>,
}

///
/// Type derived for production 245
///
/// Factor: Number;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Factor0 {
    pub number: Box<Number>,
}

///
/// Type derived for production 246
///
/// Factor: Identifier FactorList /* Vec */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Factor1 {
    pub identifier: Box<Identifier>,
    pub factor_list: Vec<FactorList>,
}

///
/// Type derived for production 249
///
/// Factor: LParen Expression RParen;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Factor2 {
    pub l_paren: Box<LParen>,
    pub expression: Box<Expression>,
    pub r_paren: Box<RParen>,
}

///
/// Type derived for production 250
///
/// Statement: AssignmentStatement;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Statement0 {
    pub assignment_statement: Box<AssignmentStatement>,
}

///
/// Type derived for production 251
///
/// Statement: IfStatement;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Statement1 {
    pub if_statement: Box<IfStatement>,
}

///
/// Type derived for production 262
///
/// BuiltinType: Logic;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BuiltinType0 {
    pub logic: Box<Logic>,
}

///
/// Type derived for production 263
///
/// BuiltinType: Bit;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BuiltinType1 {
    pub bit: Box<Bit>,
}

///
/// Type derived for production 264
///
/// BuiltinType: U32;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BuiltinType2 {
    pub u32: Box<U32>,
}

///
/// Type derived for production 265
///
/// BuiltinType: U64;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BuiltinType3 {
    pub u64: Box<U64>,
}

///
/// Type derived for production 266
///
/// BuiltinType: I32;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BuiltinType4 {
    pub i32: Box<I32>,
}

///
/// Type derived for production 267
///
/// BuiltinType: I64;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BuiltinType5 {
    pub i64: Box<I64>,
}

///
/// Type derived for production 268
///
/// BuiltinType: F32;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BuiltinType6 {
    pub f32: Box<F32>,
}

///
/// Type derived for production 269
///
/// BuiltinType: F64;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BuiltinType7 {
    pub f64: Box<F64>,
}

///
/// Type derived for production 271
///
/// TypeGroup: BuiltinType;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct TypeGroup0 {
    pub builtin_type: Box<BuiltinType>,
}

///
/// Type derived for production 272
///
/// TypeGroup: Identifier;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct TypeGroup1 {
    pub identifier: Box<Identifier>,
}

///
/// Type derived for production 284
///
/// WithParameterItemGroup: Parameter;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct WithParameterItemGroup0 {
    pub parameter: Box<Parameter>,
}

///
/// Type derived for production 285
///
/// WithParameterItemGroup: Localparam;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct WithParameterItemGroup1 {
    pub localparam: Box<Localparam>,
}

///
/// Type derived for production 302
///
/// Direction: Input;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Direction0 {
    pub input: Box<Input>,
}

///
/// Type derived for production 303
///
/// Direction: Output;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Direction1 {
    pub output: Box<Output>,
}

///
/// Type derived for production 304
///
/// Direction: Inout;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Direction2 {
    pub inout: Box<Inout>,
}

///
/// Type derived for production 305
///
/// ModuleItem: VariableDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModuleItem0 {
    pub variable_declaration: Box<VariableDeclaration>,
}

///
/// Type derived for production 306
///
/// ModuleItem: ParameterDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModuleItem1 {
    pub parameter_declaration: Box<ParameterDeclaration>,
}

///
/// Type derived for production 307
///
/// ModuleItem: LocalparamDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModuleItem2 {
    pub localparam_declaration: Box<LocalparamDeclaration>,
}

///
/// Type derived for production 308
///
/// ModuleItem: AlwaysFfDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModuleItem3 {
    pub always_ff_declaration: Box<AlwaysFfDeclaration>,
}

///
/// Type derived for production 309
///
/// ModuleItem: AlwaysCombDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModuleItem4 {
    pub always_comb_declaration: Box<AlwaysCombDeclaration>,
}

///
/// Type derived for production 310
///
/// ModuleItem: AssignDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModuleItem5 {
    pub assign_declaration: Box<AssignDeclaration>,
}

///
/// Type derived for production 316
///
/// InterfaceItem: VariableDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct InterfaceItem0 {
    pub variable_declaration: Box<VariableDeclaration>,
}

///
/// Type derived for production 317
///
/// InterfaceItem: ParameterDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct InterfaceItem1 {
    pub parameter_declaration: Box<ParameterDeclaration>,
}

///
/// Type derived for production 318
///
/// InterfaceItem: LocalparamDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct InterfaceItem2 {
    pub localparam_declaration: Box<LocalparamDeclaration>,
}

///
/// Type derived for production 319
///
/// InterfaceItem: ModportDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct InterfaceItem3 {
    pub modport_declaration: Box<ModportDeclaration>,
}

///
/// Type derived for production 332
///
/// AlwaysFfConditionGroup: Posedge;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AlwaysFfConditionGroup0 {
    pub posedge: Box<Posedge>,
}

///
/// Type derived for production 333
///
/// AlwaysFfConditionGroup: Negedge;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AlwaysFfConditionGroup1 {
    pub negedge: Box<Negedge>,
}

// -------------------------------------------------------------------------------------------------
//
// Types of non-terminals deduced from the structure of the transformed grammar
//

///
/// Type derived for non-terminal AllBit
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AllBit {
    pub all_bit_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal AllBitToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AllBitToken {
    pub tick_l_bracket01_r_bracket: crate::veryl_token::OwnedToken, /* '[01] */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal AlwaysComb
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AlwaysComb {
    pub always_comb_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal AlwaysCombDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AlwaysCombDeclaration {
    pub always_comb: Box<AlwaysComb>,
    pub l_brace: Box<LBrace>,
    pub always_comb_declaration_list: Vec<AlwaysCombDeclarationList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal AlwaysCombDeclarationList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AlwaysCombDeclarationList {
    pub statement: Box<Statement>,
}

///
/// Type derived for non-terminal AlwaysCombToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AlwaysCombToken {
    pub always_underscore_comb: crate::veryl_token::OwnedToken, /* always_comb */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal AlwaysFf
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AlwaysFf {
    pub always_ff_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal AlwaysFfCondition
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AlwaysFfCondition {
    pub always_ff_condition_group: Box<AlwaysFfConditionGroup>,
    pub identifier: Box<Identifier>,
}

///
/// Type derived for non-terminal AlwaysFfConditionGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum AlwaysFfConditionGroup {
    AlwaysFfConditionGroup0(AlwaysFfConditionGroup0),
    AlwaysFfConditionGroup1(AlwaysFfConditionGroup1),
}

///
/// Type derived for non-terminal AlwaysFfConditions
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AlwaysFfConditions {
    pub always_ff_condition: Box<AlwaysFfCondition>,
    pub always_ff_conditions_list: Vec<AlwaysFfConditionsList>,
    pub always_ff_conditions_opt: Option<Box<AlwaysFfConditionsOpt>>,
}

///
/// Type derived for non-terminal AlwaysFfConditionsList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AlwaysFfConditionsList {
    pub comma: Box<Comma>,
    pub always_ff_condition: Box<AlwaysFfCondition>,
}

///
/// Type derived for non-terminal AlwaysFfConditionsOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AlwaysFfConditionsOpt {
    pub comma: Box<Comma>,
}

///
/// Type derived for non-terminal AlwaysFfDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AlwaysFfDeclaration {
    pub always_ff: Box<AlwaysFf>,
    pub l_paren: Box<LParen>,
    pub always_ff_conditions: Box<AlwaysFfConditions>,
    pub r_paren: Box<RParen>,
    pub l_brace: Box<LBrace>,
    pub always_ff_declaration_list: Vec<AlwaysFfDeclarationList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal AlwaysFfDeclarationList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AlwaysFfDeclarationList {
    pub statement: Box<Statement>,
}

///
/// Type derived for non-terminal AlwaysFfToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AlwaysFfToken {
    pub always_underscore_ff: crate::veryl_token::OwnedToken, /* always_ff */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Amp
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Amp {
    pub amp_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal AmpAmp
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AmpAmp {
    pub amp_amp_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal AmpAmpToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AmpAmpToken {
    pub amp_amp: crate::veryl_token::OwnedToken, /* && */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal AmpToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AmpToken {
    pub amp: crate::veryl_token::OwnedToken, /* & */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Assign
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Assign {
    pub assign_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal AssignDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AssignDeclaration {
    pub assign: Box<Assign>,
    pub identifier: Box<Identifier>,
    pub assign_declaration_opt: Option<Box<AssignDeclarationOpt>>,
    pub equ: Box<Equ>,
    pub expression: Box<Expression>,
    pub semicolon: Box<Semicolon>,
}

///
/// Type derived for non-terminal AssignDeclarationOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AssignDeclarationOpt {
    pub colon: Box<Colon>,
    pub r#type: Box<Type>,
}

///
/// Type derived for non-terminal AssignToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AssignToken {
    pub assign: crate::veryl_token::OwnedToken, /* assign */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal AssignmentStatement
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct AssignmentStatement {
    pub identifier: Box<Identifier>,
    pub equ: Box<Equ>,
    pub expression: Box<Expression>,
    pub semicolon: Box<Semicolon>,
}

///
/// Type derived for non-terminal Bang
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Bang {
    pub bang_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal BangEqu
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BangEqu {
    pub bang_equ_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal BangEquEqu
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BangEquEqu {
    pub bang_equ_equ_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal BangEquEquToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BangEquEquToken {
    pub bang_equ_equ: crate::veryl_token::OwnedToken, /* !== */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal BangEquQuest
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BangEquQuest {
    pub bang_equ_quest_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal BangEquQuestToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BangEquQuestToken {
    pub bang_equ_quest: crate::veryl_token::OwnedToken, /* !=? */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal BangEquToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BangEquToken {
    pub bang_equ: crate::veryl_token::OwnedToken, /* != */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal BangToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BangToken {
    pub bang: crate::veryl_token::OwnedToken, /* ! */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal BaseLess
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BaseLess {
    pub base_less_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal BaseLessToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BaseLessToken {
    pub l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star:
        crate::veryl_token::OwnedToken, /* [0-9]+(?:_[0-9]+)* */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal BasedBinary
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BasedBinary {
    pub based_binary_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal BasedBinaryToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BasedBinaryToken {
    pub l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_tick_b_l_bracket0_minus1xz_x_z_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus1xz_x_z_r_bracket_plus_r_paren_star:
        crate::veryl_token::OwnedToken, /* [0-9]+(?:_[0-9]+)*'b[0-1xzXZ]+(?:_[0-1xzXZ]+)* */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal BasedDecimal
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BasedDecimal {
    pub based_decimal_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal BasedDecimalToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BasedDecimalToken {
    pub l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_tick_d_l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star:
        crate::veryl_token::OwnedToken, /* [0-9]+(?:_[0-9]+)*'d[0-9]+(?:_[0-9]+)* */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal BasedHex
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BasedHex {
    pub based_hex_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal BasedHexToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BasedHexToken {
    pub l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_tick_h_l_bracket0_minus9a_minus_f_a_minus_fxz_x_z_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9a_minus_f_a_minus_fxz_x_z_r_bracket_plus_r_paren_star:
        crate::veryl_token::OwnedToken, /* [0-9]+(?:_[0-9]+)*'h[0-9a-fA-FxzXZ]+(?:_[0-9a-fA-FxzXZ]+)* */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal BasedOctal
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BasedOctal {
    pub based_octal_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal BasedOctalToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BasedOctalToken {
    pub l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_tick_o_l_bracket0_minus7xz_x_z_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus7xz_x_z_r_bracket_plus_r_paren_star:
        crate::veryl_token::OwnedToken, /* [0-9]+(?:_[0-9]+)*'o[0-7xzXZ]+(?:_[0-7xzXZ]+)* */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Bit
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Bit {
    pub bit_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal BitToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct BitToken {
    pub bit: crate::veryl_token::OwnedToken, /* bit */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal BuiltinType
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum BuiltinType {
    BuiltinType0(BuiltinType0),
    BuiltinType1(BuiltinType1),
    BuiltinType2(BuiltinType2),
    BuiltinType3(BuiltinType3),
    BuiltinType4(BuiltinType4),
    BuiltinType5(BuiltinType5),
    BuiltinType6(BuiltinType6),
    BuiltinType7(BuiltinType7),
}

///
/// Type derived for non-terminal Circumflex
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Circumflex {
    pub circumflex_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal CircumflexTilde
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct CircumflexTilde {
    pub circumflex_tilde_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal CircumflexTildeToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct CircumflexTildeToken {
    pub circumflex_tilde: crate::veryl_token::OwnedToken, /* ^~ */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal CircumflexToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct CircumflexToken {
    pub circumflex: crate::veryl_token::OwnedToken, /* ^ */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Colon
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Colon {
    pub colon_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal ColonToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ColonToken {
    pub colon: crate::veryl_token::OwnedToken, /* : */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Comma
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Comma {
    pub comma_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal CommaToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct CommaToken {
    pub comma: crate::veryl_token::OwnedToken, /* , */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Comments
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Comments {
    pub comments_opt: Option<Box<CommentsOpt>>,
}

///
/// Type derived for non-terminal CommentsOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct CommentsOpt {
    pub multi_comment: Box<MultiComment>,
}

///
/// Type derived for non-terminal Description
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Description {
    Description0(Description0),
    Description1(Description1),
}

///
/// Type derived for non-terminal Direction
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Direction {
    Direction0(Direction0),
    Direction1(Direction1),
    Direction2(Direction2),
}

///
/// Type derived for non-terminal Else
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Else {
    pub else_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal ElseToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ElseToken {
    pub r#else: crate::veryl_token::OwnedToken, /* else */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Equ
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Equ {
    pub equ_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal EquEqu
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct EquEqu {
    pub equ_equ_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal EquEquEqu
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct EquEquEqu {
    pub equ_equ_equ_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal EquEquEquToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct EquEquEquToken {
    pub equ_equ_equ: crate::veryl_token::OwnedToken, /* === */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal EquEquQuest
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct EquEquQuest {
    pub equ_equ_quest_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal EquEquQuestToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct EquEquQuestToken {
    pub equ_equ_quest: crate::veryl_token::OwnedToken, /* ==? */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal EquEquToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct EquEquToken {
    pub equ_equ: crate::veryl_token::OwnedToken, /* == */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal EquToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct EquToken {
    pub equ: crate::veryl_token::OwnedToken, /* = */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Exponent
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Exponent {
    pub exponent_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal ExponentToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ExponentToken {
    pub l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_dot_l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_l_bracket_e_e_r_bracket_l_bracket_plus_minus_r_bracket_quest_l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star:
        crate::veryl_token::OwnedToken, /* [0-9]+(?:_[0-9]+)*\.[0-9]+(?:_[0-9]+)*[eE][+-]?[0-9]+(?:_[0-9]+)* */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Expression
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Expression {
    pub expression00: Box<Expression00>,
}

///
/// Type derived for non-terminal Expression00
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Expression00 {
    pub expression01: Box<Expression01>,
    pub expression00_list: Vec<Expression00List>,
}

///
/// Type derived for non-terminal Expression00List
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Expression00List {
    pub operator_precedence01: Box<OperatorPrecedence01>,
    pub expression01: Box<Expression01>,
}

///
/// Type derived for non-terminal Expression01
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Expression01 {
    pub expression02: Box<Expression02>,
    pub expression01_list: Vec<Expression01List>,
}

///
/// Type derived for non-terminal Expression01List
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Expression01List {
    pub operator_precedence02: Box<OperatorPrecedence02>,
    pub expression02: Box<Expression02>,
}

///
/// Type derived for non-terminal Expression02
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Expression02 {
    pub expression03: Box<Expression03>,
    pub expression02_list: Vec<Expression02List>,
}

///
/// Type derived for non-terminal Expression02List
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Expression02List {
    pub operator_precedence03: Box<OperatorPrecedence03>,
    pub expression03: Box<Expression03>,
}

///
/// Type derived for non-terminal Expression03
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Expression03 {
    pub expression04: Box<Expression04>,
    pub expression03_list: Vec<Expression03List>,
}

///
/// Type derived for non-terminal Expression03List
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Expression03List {
    pub operator_precedence04: Box<OperatorPrecedence04>,
    pub expression04: Box<Expression04>,
}

///
/// Type derived for non-terminal Expression04
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Expression04 {
    pub expression05: Box<Expression05>,
    pub expression04_list: Vec<Expression04List>,
}

///
/// Type derived for non-terminal Expression04List
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Expression04List {
    pub operator_precedence05: Box<OperatorPrecedence05>,
    pub expression05: Box<Expression05>,
}

///
/// Type derived for non-terminal Expression05
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Expression05 {
    pub expression06: Box<Expression06>,
    pub expression05_list: Vec<Expression05List>,
}

///
/// Type derived for non-terminal Expression05List
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Expression05List {
    pub operator_precedence06: Box<OperatorPrecedence06>,
    pub expression06: Box<Expression06>,
}

///
/// Type derived for non-terminal Expression06
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Expression06 {
    pub expression07: Box<Expression07>,
    pub expression06_list: Vec<Expression06List>,
}

///
/// Type derived for non-terminal Expression06List
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Expression06List {
    pub operator_precedence07: Box<OperatorPrecedence07>,
    pub expression07: Box<Expression07>,
}

///
/// Type derived for non-terminal Expression07
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Expression07 {
    pub expression08: Box<Expression08>,
    pub expression07_list: Vec<Expression07List>,
}

///
/// Type derived for non-terminal Expression07List
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Expression07List {
    pub operator_precedence08: Box<OperatorPrecedence08>,
    pub expression08: Box<Expression08>,
}

///
/// Type derived for non-terminal Expression08
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Expression08 {
    pub expression09: Box<Expression09>,
    pub expression08_list: Vec<Expression08List>,
}

///
/// Type derived for non-terminal Expression08List
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Expression08List {
    pub operator_precedence09: Box<OperatorPrecedence09>,
    pub expression09: Box<Expression09>,
}

///
/// Type derived for non-terminal Expression09
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Expression09 {
    pub expression10: Box<Expression10>,
    pub expression09_list: Vec<Expression09List>,
}

///
/// Type derived for non-terminal Expression09List
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Expression09List {
    pub operator_precedence10: Box<OperatorPrecedence10>,
    pub expression10: Box<Expression10>,
}

///
/// Type derived for non-terminal Expression10
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Expression10 {
    pub expression11: Box<Expression11>,
    pub expression10_list: Vec<Expression10List>,
}

///
/// Type derived for non-terminal Expression10List
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Expression10List {
    pub operator_precedence11: Box<OperatorPrecedence11>,
    pub expression11: Box<Expression11>,
}

///
/// Type derived for non-terminal Expression11
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Expression11 {
    pub expression11_opt: Option<Box<Expression11Opt>>,
    pub expression12: Box<Expression12>,
}

///
/// Type derived for non-terminal Expression11Opt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Expression11Opt {
    pub operator_precedence12: Box<OperatorPrecedence12>,
}

///
/// Type derived for non-terminal Expression12
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Expression12 {
    pub factor: Box<Factor>,
}

///
/// Type derived for non-terminal F32
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct F32 {
    pub f32_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal F32Token
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct F32Token {
    pub f32: crate::veryl_token::OwnedToken, /* f32 */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal F64
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct F64 {
    pub f64_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal F64Token
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct F64Token {
    pub f64: crate::veryl_token::OwnedToken, /* f64 */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Factor
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Factor {
    Factor0(Factor0),
    Factor1(Factor1),
    Factor2(Factor2),
}

///
/// Type derived for non-terminal FactorList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct FactorList {
    pub range: Box<Range>,
}

///
/// Type derived for non-terminal FixedPoint
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct FixedPoint {
    pub fixed_point_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal FixedPointToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct FixedPointToken {
    pub l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_dot_l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star:
        crate::veryl_token::OwnedToken, /* [0-9]+(?:_[0-9]+)*\.[0-9]+(?:_[0-9]+)* */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal GT
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct GT {
    pub g_t_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal GTEqu
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct GTEqu {
    pub g_t_equ_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal GTEquToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct GTEquToken {
    pub g_t_equ: crate::veryl_token::OwnedToken, /* >= */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal GTGT
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct GTGT {
    pub g_t_g_t_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal GTGTGT
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct GTGTGT {
    pub g_t_g_t_g_t_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal GTGTGTToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct GTGTGTToken {
    pub g_t_g_t_g_t: crate::veryl_token::OwnedToken, /* >>> */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal GTGTToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct GTGTToken {
    pub g_t_g_t: crate::veryl_token::OwnedToken, /* >> */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal GTToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct GTToken {
    pub g_t: crate::veryl_token::OwnedToken, /* > */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Hash
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Hash {
    pub hash_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal HashToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct HashToken {
    pub hash: crate::veryl_token::OwnedToken, /* # */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal I32
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct I32 {
    pub i32_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal I32Token
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct I32Token {
    pub i32: crate::veryl_token::OwnedToken, /* i32 */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal I64
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct I64 {
    pub i64_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal I64Token
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct I64Token {
    pub i64: crate::veryl_token::OwnedToken, /* i64 */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Identifier
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Identifier {
    pub identifier_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal IdentifierToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct IdentifierToken {
    pub l_bracket_a_minus_z_a_minus_z_underscore_r_bracket_l_bracket0_minus9a_minus_z_a_minus_z_underscore_r_bracket_star:
        crate::veryl_token::OwnedToken, /* [a-zA-Z_][0-9a-zA-Z_]* */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal If
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct If {
    pub if_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal IfStatement
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct IfStatement {
    pub r#if: Box<If>,
    pub expression: Box<Expression>,
    pub l_brace: Box<LBrace>,
    pub statement: Box<Statement>,
    pub r_brace: Box<RBrace>,
    pub if_statement_list: Vec<IfStatementList>,
    pub if_statement_opt: Option<Box<IfStatementOpt>>,
}

///
/// Type derived for non-terminal IfStatementList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct IfStatementList {
    pub r#else: Box<Else>,
    pub r#if: Box<If>,
    pub expression: Box<Expression>,
    pub l_brace: Box<LBrace>,
    pub statement: Box<Statement>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal IfStatementOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct IfStatementOpt {
    pub r#else: Box<Else>,
    pub l_brace: Box<LBrace>,
    pub statement: Box<Statement>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal IfToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct IfToken {
    pub r#if: crate::veryl_token::OwnedToken, /* if */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Inout
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Inout {
    pub inout_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal InoutToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct InoutToken {
    pub inout: crate::veryl_token::OwnedToken, /* inout */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Input
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Input {
    pub input_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal InputToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct InputToken {
    pub input: crate::veryl_token::OwnedToken, /* input */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal IntegralNumber
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum IntegralNumber {
    IntegralNumber0(IntegralNumber0),
    IntegralNumber1(IntegralNumber1),
    IntegralNumber2(IntegralNumber2),
    IntegralNumber3(IntegralNumber3),
    IntegralNumber4(IntegralNumber4),
    IntegralNumber5(IntegralNumber5),
}

///
/// Type derived for non-terminal Interface
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Interface {
    pub interface_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal InterfaceDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct InterfaceDeclaration {
    pub interface: Box<Interface>,
    pub identifier: Box<Identifier>,
    pub interface_declaration_opt: Option<Box<InterfaceDeclarationOpt>>,
    pub l_brace: Box<LBrace>,
    pub interface_declaration_list: Vec<InterfaceDeclarationList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal InterfaceDeclarationList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct InterfaceDeclarationList {
    pub interface_item: Box<InterfaceItem>,
}

///
/// Type derived for non-terminal InterfaceDeclarationOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct InterfaceDeclarationOpt {
    pub with_parameter: Box<WithParameter>,
}

///
/// Type derived for non-terminal InterfaceItem
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum InterfaceItem {
    InterfaceItem0(InterfaceItem0),
    InterfaceItem1(InterfaceItem1),
    InterfaceItem2(InterfaceItem2),
    InterfaceItem3(InterfaceItem3),
}

///
/// Type derived for non-terminal InterfaceToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct InterfaceToken {
    pub interface: crate::veryl_token::OwnedToken, /* interface */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal LBrace
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LBrace {
    pub l_brace_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal LBraceToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LBraceToken {
    pub l_brace: crate::veryl_token::OwnedToken, /* { */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal LBracket
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LBracket {
    pub l_bracket_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal LBracketToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LBracketToken {
    pub l_bracket: crate::veryl_token::OwnedToken, /* [ */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal LParen
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LParen {
    pub l_paren_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal LParenToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LParenToken {
    pub l_paren: crate::veryl_token::OwnedToken, /* ( */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal LT
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LT {
    pub l_t_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal LTEqu
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LTEqu {
    pub l_t_equ_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal LTEquToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LTEquToken {
    pub l_t_equ: crate::veryl_token::OwnedToken, /* <= */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal LTLT
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LTLT {
    pub l_t_l_t_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal LTLTLT
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LTLTLT {
    pub l_t_l_t_l_t_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal LTLTLTToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LTLTLTToken {
    pub l_t_l_t_l_t: crate::veryl_token::OwnedToken, /* <<< */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal LTLTToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LTLTToken {
    pub l_t_l_t: crate::veryl_token::OwnedToken, /* << */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal LTToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LTToken {
    pub l_t: crate::veryl_token::OwnedToken, /* < */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Localparam
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Localparam {
    pub localparam_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal LocalparamDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LocalparamDeclaration {
    pub localparam: Box<Localparam>,
    pub identifier: Box<Identifier>,
    pub colon: Box<Colon>,
    pub r#type: Box<Type>,
    pub equ: Box<Equ>,
    pub expression: Box<Expression>,
    pub semicolon: Box<Semicolon>,
}

///
/// Type derived for non-terminal LocalparamToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LocalparamToken {
    pub localparam: crate::veryl_token::OwnedToken, /* localparam */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Logic
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Logic {
    pub logic_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal LogicToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct LogicToken {
    pub logic: crate::veryl_token::OwnedToken, /* logic */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Minus
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Minus {
    pub minus_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal MinusToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct MinusToken {
    pub minus: crate::veryl_token::OwnedToken, /* - */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Modport
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Modport {
    pub modport_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal ModportDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModportDeclaration {
    pub modport: Box<Modport>,
    pub identifier: Box<Identifier>,
    pub l_brace: Box<LBrace>,
    pub modport_list: Box<ModportList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal ModportItem
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModportItem {
    pub identifier: Box<Identifier>,
    pub colon: Box<Colon>,
    pub direction: Box<Direction>,
}

///
/// Type derived for non-terminal ModportList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModportList {
    pub modport_item: Box<ModportItem>,
    pub modport_list_list: Vec<ModportListList>,
    pub modport_list_opt: Option<Box<ModportListOpt>>,
}

///
/// Type derived for non-terminal ModportListList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModportListList {
    pub comma: Box<Comma>,
    pub modport_item: Box<ModportItem>,
}

///
/// Type derived for non-terminal ModportListOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModportListOpt {
    pub comma: Box<Comma>,
}

///
/// Type derived for non-terminal ModportToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModportToken {
    pub modport: crate::veryl_token::OwnedToken, /* modport */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Module
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Module {
    pub module_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal ModuleDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModuleDeclaration {
    pub module: Box<Module>,
    pub identifier: Box<Identifier>,
    pub module_declaration_opt: Option<Box<ModuleDeclarationOpt>>,
    pub module_declaration_opt0: Option<Box<ModuleDeclarationOpt0>>,
    pub l_brace: Box<LBrace>,
    pub module_declaration_list: Vec<ModuleDeclarationList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal ModuleDeclarationList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModuleDeclarationList {
    pub module_item: Box<ModuleItem>,
}

///
/// Type derived for non-terminal ModuleDeclarationOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModuleDeclarationOpt {
    pub with_parameter: Box<WithParameter>,
}

///
/// Type derived for non-terminal ModuleDeclarationOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModuleDeclarationOpt0 {
    pub module_port: Box<ModulePort>,
}

///
/// Type derived for non-terminal ModuleItem
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ModuleItem {
    ModuleItem0(ModuleItem0),
    ModuleItem1(ModuleItem1),
    ModuleItem2(ModuleItem2),
    ModuleItem3(ModuleItem3),
    ModuleItem4(ModuleItem4),
    ModuleItem5(ModuleItem5),
}

///
/// Type derived for non-terminal ModulePort
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModulePort {
    pub l_paren: Box<LParen>,
    pub module_port_opt: Option<Box<ModulePortOpt>>,
    pub r_paren: Box<RParen>,
}

///
/// Type derived for non-terminal ModulePortItem
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModulePortItem {
    pub identifier: Box<Identifier>,
    pub colon: Box<Colon>,
    pub direction: Box<Direction>,
    pub r#type: Box<Type>,
}

///
/// Type derived for non-terminal ModulePortList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModulePortList {
    pub module_port_item: Box<ModulePortItem>,
    pub module_port_list_list: Vec<ModulePortListList>,
    pub module_port_list_opt: Option<Box<ModulePortListOpt>>,
}

///
/// Type derived for non-terminal ModulePortListList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModulePortListList {
    pub comma: Box<Comma>,
    pub module_port_item: Box<ModulePortItem>,
}

///
/// Type derived for non-terminal ModulePortListOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModulePortListOpt {
    pub comma: Box<Comma>,
}

///
/// Type derived for non-terminal ModulePortOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModulePortOpt {
    pub module_port_list: Box<ModulePortList>,
}

///
/// Type derived for non-terminal ModuleToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ModuleToken {
    pub module: crate::veryl_token::OwnedToken, /* module */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal MultiComment
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct MultiComment {
    pub multi_comment: crate::veryl_token::OwnedToken, /* (?:(?:(?://.*(?:\r\n|\r|\n|$))|(?:(?ms)/\u{2a}.*?\u{2a}/))\s*)+ */
}

///
/// Type derived for non-terminal Negedge
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Negedge {
    pub negedge_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal NegedgeToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct NegedgeToken {
    pub negedge: crate::veryl_token::OwnedToken, /* negedge */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Number
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Number {
    Number0(Number0),
    Number1(Number1),
}

///
/// Type derived for non-terminal OperatorPrecedence01
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct OperatorPrecedence01 {
    pub or_or: Box<OrOr>,
}

///
/// Type derived for non-terminal OperatorPrecedence02
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct OperatorPrecedence02 {
    pub amp_amp: Box<AmpAmp>,
}

///
/// Type derived for non-terminal OperatorPrecedence03
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct OperatorPrecedence03 {
    pub or: Box<Or>,
}

///
/// Type derived for non-terminal OperatorPrecedence04
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum OperatorPrecedence04 {
    OperatorPrecedence040(OperatorPrecedence4),
    OperatorPrecedence041(OperatorPrecedence5),
    OperatorPrecedence042(OperatorPrecedence6),
}

///
/// Type derived for non-terminal OperatorPrecedence05
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct OperatorPrecedence05 {
    pub amp: Box<Amp>,
}

///
/// Type derived for non-terminal OperatorPrecedence06
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum OperatorPrecedence06 {
    OperatorPrecedence060(OperatorPrecedence8),
    OperatorPrecedence061(OperatorPrecedence9),
    OperatorPrecedence062(OperatorPrecedence13),
    OperatorPrecedence063(OperatorPrecedence14),
    OperatorPrecedence064(OperatorPrecedence15),
    OperatorPrecedence065(OperatorPrecedence16),
}

///
/// Type derived for non-terminal OperatorPrecedence07
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum OperatorPrecedence07 {
    OperatorPrecedence070(OperatorPrecedence17),
    OperatorPrecedence071(OperatorPrecedence18),
    OperatorPrecedence072(OperatorPrecedence19),
    OperatorPrecedence073(OperatorPrecedence20),
}

///
/// Type derived for non-terminal OperatorPrecedence08
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum OperatorPrecedence08 {
    OperatorPrecedence080(OperatorPrecedence21),
    OperatorPrecedence081(OperatorPrecedence22),
    OperatorPrecedence082(OperatorPrecedence23),
    OperatorPrecedence083(OperatorPrecedence24),
}

///
/// Type derived for non-terminal OperatorPrecedence09
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum OperatorPrecedence09 {
    OperatorPrecedence090(OperatorPrecedence25),
    OperatorPrecedence091(OperatorPrecedence26),
}

///
/// Type derived for non-terminal OperatorPrecedence10
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum OperatorPrecedence10 {
    OperatorPrecedence100(OperatorPrecedence27),
    OperatorPrecedence101(OperatorPrecedence28),
    OperatorPrecedence102(OperatorPrecedence29),
}

///
/// Type derived for non-terminal OperatorPrecedence11
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct OperatorPrecedence11 {
    pub star_star: Box<StarStar>,
}

///
/// Type derived for non-terminal OperatorPrecedence12
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum OperatorPrecedence12 {
    OperatorPrecedence120(OperatorPrecedence31),
    OperatorPrecedence121(OperatorPrecedence32),
    OperatorPrecedence122(OperatorPrecedence33),
    OperatorPrecedence123(OperatorPrecedence34),
    OperatorPrecedence124(OperatorPrecedence35),
    OperatorPrecedence125(OperatorPrecedence36),
    OperatorPrecedence126(OperatorPrecedence37),
    OperatorPrecedence127(OperatorPrecedence38),
    OperatorPrecedence128(OperatorPrecedence39),
    OperatorPrecedence129(OperatorPrecedence40),
    OperatorPrecedence1210(OperatorPrecedence41),
}

///
/// Type derived for non-terminal Or
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Or {
    pub or_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal OrOr
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct OrOr {
    pub or_or_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal OrOrToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct OrOrToken {
    pub or_or: crate::veryl_token::OwnedToken, /* || */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal OrToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct OrToken {
    pub or: crate::veryl_token::OwnedToken, /* | */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Output
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Output {
    pub output_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal OutputToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct OutputToken {
    pub output: crate::veryl_token::OwnedToken, /* output */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Parameter
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Parameter {
    pub parameter_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal ParameterDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ParameterDeclaration {
    pub parameter: Box<Parameter>,
    pub identifier: Box<Identifier>,
    pub colon: Box<Colon>,
    pub r#type: Box<Type>,
    pub equ: Box<Equ>,
    pub expression: Box<Expression>,
    pub semicolon: Box<Semicolon>,
}

///
/// Type derived for non-terminal ParameterToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct ParameterToken {
    pub parameter: crate::veryl_token::OwnedToken, /* parameter */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Percent
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Percent {
    pub percent_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal PercentToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct PercentToken {
    pub percent: crate::veryl_token::OwnedToken, /* % */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Plus
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Plus {
    pub plus_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal PlusToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct PlusToken {
    pub plus: crate::veryl_token::OwnedToken, /* + */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Posedge
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Posedge {
    pub posedge_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal PosedgeToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct PosedgeToken {
    pub posedge: crate::veryl_token::OwnedToken, /* posedge */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal RBrace
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct RBrace {
    pub r_brace_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal RBraceToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct RBraceToken {
    pub r_brace: crate::veryl_token::OwnedToken, /* } */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal RBracket
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct RBracket {
    pub r_bracket_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal RBracketToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct RBracketToken {
    pub r_bracket: crate::veryl_token::OwnedToken, /* ] */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal RParen
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct RParen {
    pub r_paren_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal RParenToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct RParenToken {
    pub r_paren: crate::veryl_token::OwnedToken, /* ) */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Range
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Range {
    pub l_bracket: Box<LBracket>,
    pub expression: Box<Expression>,
    pub range_opt: Option<Box<RangeOpt>>,
    pub r_bracket: Box<RBracket>,
}

///
/// Type derived for non-terminal RangeOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct RangeOpt {
    pub colon: Box<Colon>,
    pub expression: Box<Expression>,
}

///
/// Type derived for non-terminal RealNumber
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum RealNumber {
    RealNumber0(RealNumber0),
    RealNumber1(RealNumber1),
}

///
/// Type derived for non-terminal Semicolon
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Semicolon {
    pub semicolon_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal SemicolonToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct SemicolonToken {
    pub semicolon: crate::veryl_token::OwnedToken, /* ; */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Slash
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Slash {
    pub slash_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal SlashToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct SlashToken {
    pub slash: crate::veryl_token::OwnedToken, /* / */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Star
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Star {
    pub star_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal StarStar
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct StarStar {
    pub star_star_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal StarStarToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct StarStarToken {
    pub star_star: crate::veryl_token::OwnedToken, /* ** */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal StarToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct StarToken {
    pub star: crate::veryl_token::OwnedToken, /* * */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Start
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Start {
    pub start_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal StartToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct StartToken {
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Statement
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Statement {
    Statement0(Statement0),
    Statement1(Statement1),
}

///
/// Type derived for non-terminal Tilde
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Tilde {
    pub tilde_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal TildeAmp
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct TildeAmp {
    pub tilde_amp_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal TildeAmpToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct TildeAmpToken {
    pub tilde_amp: crate::veryl_token::OwnedToken, /* ~& */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal TildeCircumflex
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct TildeCircumflex {
    pub tilde_circumflex_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal TildeCircumflexToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct TildeCircumflexToken {
    pub tilde_circumflex: crate::veryl_token::OwnedToken, /* ~^ */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal TildeOr
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct TildeOr {
    pub tilde_or_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal TildeOrToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct TildeOrToken {
    pub tilde_or: crate::veryl_token::OwnedToken, /* ~| */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal TildeToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct TildeToken {
    pub tilde: crate::veryl_token::OwnedToken, /* ~ */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Type
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Type {
    pub type_group: Box<TypeGroup>,
    pub type_list: Vec<TypeList>,
}

///
/// Type derived for non-terminal TypeGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum TypeGroup {
    TypeGroup0(TypeGroup0),
    TypeGroup1(TypeGroup1),
}

///
/// Type derived for non-terminal TypeList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct TypeList {
    pub width: Box<Width>,
}

///
/// Type derived for non-terminal U32
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct U32 {
    pub u32_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal U32Token
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct U32Token {
    pub u32: crate::veryl_token::OwnedToken, /* u32 */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal U64
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct U64 {
    pub u64_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal U64Token
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct U64Token {
    pub u64: crate::veryl_token::OwnedToken, /* u64 */
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal VariableDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct VariableDeclaration {
    pub identifier: Box<Identifier>,
    pub colon: Box<Colon>,
    pub r#type: Box<Type>,
    pub semicolon: Box<Semicolon>,
}

///
/// Type derived for non-terminal Veryl
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Veryl {
    pub start: Box<Start>,
    pub veryl_list: Vec<VerylList>,
}

///
/// Type derived for non-terminal VerylList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct VerylList {
    pub description: Box<Description>,
}

///
/// Type derived for non-terminal Width
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct Width {
    pub l_bracket: Box<LBracket>,
    pub expression: Box<Expression>,
    pub r_bracket: Box<RBracket>,
}

///
/// Type derived for non-terminal WithParameter
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct WithParameter {
    pub hash: Box<Hash>,
    pub l_paren: Box<LParen>,
    pub with_parameter_opt: Option<Box<WithParameterOpt>>,
    pub r_paren: Box<RParen>,
}

///
/// Type derived for non-terminal WithParameterItem
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct WithParameterItem {
    pub with_parameter_item_group: Box<WithParameterItemGroup>,
    pub identifier: Box<Identifier>,
    pub colon: Box<Colon>,
    pub r#type: Box<Type>,
    pub equ: Box<Equ>,
    pub expression: Box<Expression>,
}

///
/// Type derived for non-terminal WithParameterItemGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum WithParameterItemGroup {
    WithParameterItemGroup0(WithParameterItemGroup0),
    WithParameterItemGroup1(WithParameterItemGroup1),
}

///
/// Type derived for non-terminal WithParameterList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct WithParameterList {
    pub with_parameter_item: Box<WithParameterItem>,
    pub with_parameter_list_list: Vec<WithParameterListList>,
    pub with_parameter_list_opt: Option<Box<WithParameterListOpt>>,
}

///
/// Type derived for non-terminal WithParameterListList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct WithParameterListList {
    pub comma: Box<Comma>,
    pub with_parameter_item: Box<WithParameterItem>,
}

///
/// Type derived for non-terminal WithParameterListOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct WithParameterListOpt {
    pub comma: Box<Comma>,
}

///
/// Type derived for non-terminal WithParameterOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
pub struct WithParameterOpt {
    pub with_parameter_list: Box<WithParameterList>,
}

// -------------------------------------------------------------------------------------------------

///
/// Deduced ASTType of expanded grammar
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ASTType {
    AllBit(AllBit),
    AllBitToken(AllBitToken),
    AlwaysComb(AlwaysComb),
    AlwaysCombDeclaration(AlwaysCombDeclaration),
    AlwaysCombDeclarationList(Vec<AlwaysCombDeclarationList>),
    AlwaysCombToken(AlwaysCombToken),
    AlwaysFf(AlwaysFf),
    AlwaysFfCondition(AlwaysFfCondition),
    AlwaysFfConditionGroup(AlwaysFfConditionGroup),
    AlwaysFfConditions(AlwaysFfConditions),
    AlwaysFfConditionsList(Vec<AlwaysFfConditionsList>),
    AlwaysFfConditionsOpt(Option<Box<AlwaysFfConditionsOpt>>),
    AlwaysFfDeclaration(AlwaysFfDeclaration),
    AlwaysFfDeclarationList(Vec<AlwaysFfDeclarationList>),
    AlwaysFfToken(AlwaysFfToken),
    Amp(Amp),
    AmpAmp(AmpAmp),
    AmpAmpToken(AmpAmpToken),
    AmpToken(AmpToken),
    Assign(Assign),
    AssignDeclaration(AssignDeclaration),
    AssignDeclarationOpt(Option<Box<AssignDeclarationOpt>>),
    AssignToken(AssignToken),
    AssignmentStatement(AssignmentStatement),
    Bang(Bang),
    BangEqu(BangEqu),
    BangEquEqu(BangEquEqu),
    BangEquEquToken(BangEquEquToken),
    BangEquQuest(BangEquQuest),
    BangEquQuestToken(BangEquQuestToken),
    BangEquToken(BangEquToken),
    BangToken(BangToken),
    BaseLess(BaseLess),
    BaseLessToken(BaseLessToken),
    BasedBinary(BasedBinary),
    BasedBinaryToken(BasedBinaryToken),
    BasedDecimal(BasedDecimal),
    BasedDecimalToken(BasedDecimalToken),
    BasedHex(BasedHex),
    BasedHexToken(BasedHexToken),
    BasedOctal(BasedOctal),
    BasedOctalToken(BasedOctalToken),
    Bit(Bit),
    BitToken(BitToken),
    BuiltinType(BuiltinType),
    Circumflex(Circumflex),
    CircumflexTilde(CircumflexTilde),
    CircumflexTildeToken(CircumflexTildeToken),
    CircumflexToken(CircumflexToken),
    Colon(Colon),
    ColonToken(ColonToken),
    Comma(Comma),
    CommaToken(CommaToken),
    Comments(Comments),
    CommentsOpt(Option<Box<CommentsOpt>>),
    Description(Description),
    Direction(Direction),
    Else(Else),
    ElseToken(ElseToken),
    Equ(Equ),
    EquEqu(EquEqu),
    EquEquEqu(EquEquEqu),
    EquEquEquToken(EquEquEquToken),
    EquEquQuest(EquEquQuest),
    EquEquQuestToken(EquEquQuestToken),
    EquEquToken(EquEquToken),
    EquToken(EquToken),
    Exponent(Exponent),
    ExponentToken(ExponentToken),
    Expression(Expression),
    Expression00(Expression00),
    Expression00List(Vec<Expression00List>),
    Expression01(Expression01),
    Expression01List(Vec<Expression01List>),
    Expression02(Expression02),
    Expression02List(Vec<Expression02List>),
    Expression03(Expression03),
    Expression03List(Vec<Expression03List>),
    Expression04(Expression04),
    Expression04List(Vec<Expression04List>),
    Expression05(Expression05),
    Expression05List(Vec<Expression05List>),
    Expression06(Expression06),
    Expression06List(Vec<Expression06List>),
    Expression07(Expression07),
    Expression07List(Vec<Expression07List>),
    Expression08(Expression08),
    Expression08List(Vec<Expression08List>),
    Expression09(Expression09),
    Expression09List(Vec<Expression09List>),
    Expression10(Expression10),
    Expression10List(Vec<Expression10List>),
    Expression11(Expression11),
    Expression11Opt(Option<Box<Expression11Opt>>),
    Expression12(Expression12),
    F32(F32),
    F32Token(F32Token),
    F64(F64),
    F64Token(F64Token),
    Factor(Factor),
    FactorList(Vec<FactorList>),
    FixedPoint(FixedPoint),
    FixedPointToken(FixedPointToken),
    GT(GT),
    GTEqu(GTEqu),
    GTEquToken(GTEquToken),
    GTGT(GTGT),
    GTGTGT(GTGTGT),
    GTGTGTToken(GTGTGTToken),
    GTGTToken(GTGTToken),
    GTToken(GTToken),
    Hash(Hash),
    HashToken(HashToken),
    I32(I32),
    I32Token(I32Token),
    I64(I64),
    I64Token(I64Token),
    Identifier(Identifier),
    IdentifierToken(IdentifierToken),
    If(If),
    IfStatement(IfStatement),
    IfStatementList(Vec<IfStatementList>),
    IfStatementOpt(Option<Box<IfStatementOpt>>),
    IfToken(IfToken),
    Inout(Inout),
    InoutToken(InoutToken),
    Input(Input),
    InputToken(InputToken),
    IntegralNumber(IntegralNumber),
    Interface(Interface),
    InterfaceDeclaration(InterfaceDeclaration),
    InterfaceDeclarationList(Vec<InterfaceDeclarationList>),
    InterfaceDeclarationOpt(Option<Box<InterfaceDeclarationOpt>>),
    InterfaceItem(InterfaceItem),
    InterfaceToken(InterfaceToken),
    LBrace(LBrace),
    LBraceToken(LBraceToken),
    LBracket(LBracket),
    LBracketToken(LBracketToken),
    LParen(LParen),
    LParenToken(LParenToken),
    LT(LT),
    LTEqu(LTEqu),
    LTEquToken(LTEquToken),
    LTLT(LTLT),
    LTLTLT(LTLTLT),
    LTLTLTToken(LTLTLTToken),
    LTLTToken(LTLTToken),
    LTToken(LTToken),
    Localparam(Localparam),
    LocalparamDeclaration(LocalparamDeclaration),
    LocalparamToken(LocalparamToken),
    Logic(Logic),
    LogicToken(LogicToken),
    Minus(Minus),
    MinusToken(MinusToken),
    Modport(Modport),
    ModportDeclaration(ModportDeclaration),
    ModportItem(ModportItem),
    ModportList(ModportList),
    ModportListList(Vec<ModportListList>),
    ModportListOpt(Option<Box<ModportListOpt>>),
    ModportToken(ModportToken),
    Module(Module),
    ModuleDeclaration(ModuleDeclaration),
    ModuleDeclarationList(Vec<ModuleDeclarationList>),
    ModuleDeclarationOpt(Option<Box<ModuleDeclarationOpt>>),
    ModuleDeclarationOpt0(Option<Box<ModuleDeclarationOpt0>>),
    ModuleItem(ModuleItem),
    ModulePort(ModulePort),
    ModulePortItem(ModulePortItem),
    ModulePortList(ModulePortList),
    ModulePortListList(Vec<ModulePortListList>),
    ModulePortListOpt(Option<Box<ModulePortListOpt>>),
    ModulePortOpt(Option<Box<ModulePortOpt>>),
    ModuleToken(ModuleToken),
    MultiComment(MultiComment),
    Negedge(Negedge),
    NegedgeToken(NegedgeToken),
    Number(Number),
    OperatorPrecedence01(OperatorPrecedence01),
    OperatorPrecedence02(OperatorPrecedence02),
    OperatorPrecedence03(OperatorPrecedence03),
    OperatorPrecedence04(OperatorPrecedence04),
    OperatorPrecedence05(OperatorPrecedence05),
    OperatorPrecedence06(OperatorPrecedence06),
    OperatorPrecedence07(OperatorPrecedence07),
    OperatorPrecedence08(OperatorPrecedence08),
    OperatorPrecedence09(OperatorPrecedence09),
    OperatorPrecedence10(OperatorPrecedence10),
    OperatorPrecedence11(OperatorPrecedence11),
    OperatorPrecedence12(OperatorPrecedence12),
    Or(Or),
    OrOr(OrOr),
    OrOrToken(OrOrToken),
    OrToken(OrToken),
    Output(Output),
    OutputToken(OutputToken),
    Parameter(Parameter),
    ParameterDeclaration(ParameterDeclaration),
    ParameterToken(ParameterToken),
    Percent(Percent),
    PercentToken(PercentToken),
    Plus(Plus),
    PlusToken(PlusToken),
    Posedge(Posedge),
    PosedgeToken(PosedgeToken),
    RBrace(RBrace),
    RBraceToken(RBraceToken),
    RBracket(RBracket),
    RBracketToken(RBracketToken),
    RParen(RParen),
    RParenToken(RParenToken),
    Range(Range),
    RangeOpt(Option<Box<RangeOpt>>),
    RealNumber(RealNumber),
    Semicolon(Semicolon),
    SemicolonToken(SemicolonToken),
    Slash(Slash),
    SlashToken(SlashToken),
    Star(Star),
    StarStar(StarStar),
    StarStarToken(StarStarToken),
    StarToken(StarToken),
    Start(Start),
    StartToken(StartToken),
    Statement(Statement),
    Tilde(Tilde),
    TildeAmp(TildeAmp),
    TildeAmpToken(TildeAmpToken),
    TildeCircumflex(TildeCircumflex),
    TildeCircumflexToken(TildeCircumflexToken),
    TildeOr(TildeOr),
    TildeOrToken(TildeOrToken),
    TildeToken(TildeToken),
    Type(Type),
    TypeGroup(TypeGroup),
    TypeList(Vec<TypeList>),
    U32(U32),
    U32Token(U32Token),
    U64(U64),
    U64Token(U64Token),
    VariableDeclaration(VariableDeclaration),
    Veryl(Veryl),
    VerylList(Vec<VerylList>),
    Width(Width),
    WithParameter(WithParameter),
    WithParameterItem(WithParameterItem),
    WithParameterItemGroup(WithParameterItemGroup),
    WithParameterList(WithParameterList),
    WithParameterListList(Vec<WithParameterListList>),
    WithParameterListOpt(Option<Box<WithParameterListOpt>>),
    WithParameterOpt(Option<Box<WithParameterOpt>>),
}

/// Auto-implemented adapter grammar
///
/// The lifetime parameter `'t` refers to the lifetime of the scanned text.
/// The lifetime parameter `'u` refers to the lifetime of user grammar object.
///
#[allow(dead_code)]
pub struct VerylGrammarAuto<'t, 'u>
where
    't: 'u,
{
    // Mutable reference of the actual user grammar to be able to call the semantic actions on it
    user_grammar: &'u mut dyn VerylGrammarTrait,
    // Stack to construct the AST on it
    item_stack: Vec<ASTType>,
    // Just to hold the lifetime generated by parol
    phantom: PhantomData<&'t str>,
}

///
/// The `VerylGrammarAuto` impl is automatically generated for the
/// given grammar.
///
impl<'t, 'u> VerylGrammarAuto<'t, 'u> {
    pub fn new(user_grammar: &'u mut dyn VerylGrammarTrait) -> Self {
        Self {
            user_grammar,
            item_stack: Vec::new(),
            phantom: PhantomData::default(),
        }
    }

    #[allow(dead_code)]
    fn push(&mut self, item: ASTType, context: &str) {
        trace!("push    {}: {:?}", context, item);
        self.item_stack.push(item)
    }

    #[allow(dead_code)]
    fn pop(&mut self, context: &str) -> Option<ASTType> {
        if !self.item_stack.is_empty() {
            let item = self.item_stack.pop();
            if let Some(ref item) = item {
                trace!("pop     {}: {:?}", context, item);
            }
            item
        } else {
            None
        }
    }

    #[allow(dead_code)]
    // Use this function for debugging purposes:
    // trace!("{}", self.trace_item_stack(context));
    fn trace_item_stack(&self, context: &str) -> std::string::String {
        format!(
            "Item stack at {}:\n{}",
            context,
            self.item_stack
                .iter()
                .rev()
                .map(|s| format!("  {:?}", s))
                .collect::<Vec<std::string::String>>()
                .join("\n")
        )
    }

    /// Semantic action for production 0:
    ///
    /// MultiComment: "(?:(?:(?://.*(?:\r\n|\r|\n|$))|(?:(?ms)/\u{2a}.*?\u{2a}/))\s*)+" : OwnedToken;
    ///
    #[parol_runtime::function_name::named]
    fn multi_comment(
        &mut self,
        multi_comment: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let multi_comment = multi_comment
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let multi_comment_built = MultiCommentBuilder::default()
            .multi_comment(multi_comment)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.multi_comment(&multi_comment_built)?;
        self.push(ASTType::MultiComment(multi_comment_built), context);
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// Comments: CommentsOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn comments(
        &mut self,
        _comments_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments_opt = pop_item!(self, comments_opt, CommentsOpt, context);
        let comments_built = CommentsBuilder::default()
            .comments_opt(comments_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.comments(&comments_built)?;
        self.push(ASTType::Comments(comments_built), context);
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// CommentsOpt /* Option<T>::Some */: MultiComment;
    ///
    #[parol_runtime::function_name::named]
    fn comments_opt_0(
        &mut self,
        _multi_comment: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let multi_comment = pop_item!(self, multi_comment, MultiComment, context);
        let comments_opt_0_built = CommentsOptBuilder::default()
            .multi_comment(Box::new(multi_comment))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::CommentsOpt(Some(Box::new(comments_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// CommentsOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn comments_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::CommentsOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// StartToken: Comments;
    ///
    #[parol_runtime::function_name::named]
    fn start_token(
        &mut self,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let start_token_built = StartTokenBuilder::default()
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.start_token(&start_token_built)?;
        self.push(ASTType::StartToken(start_token_built), context);
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// Start: StartToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn start(
        &mut self,
        _start_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let start_token = pop_item!(self, start_token, StartToken, context);
        let start_built = StartBuilder::default()
            .start_token((&start_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.start(&start_built)?;
        self.push(ASTType::Start(start_built), context);
        Ok(())
    }

    /// Semantic action for production 6:
    ///
    /// ExponentToken: /[0-9]+(?:_[0-9]+)*\.[0-9]+(?:_[0-9]+)*[eE][+-]?[0-9]+(?:_[0-9]+)*/ : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn exponent_token(
        &mut self,
        l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_dot_l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_l_bracket_e_e_r_bracket_l_bracket_plus_minus_r_bracket_quest_l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_dot_l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_l_bracket_e_e_r_bracket_l_bracket_plus_minus_r_bracket_quest_l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star = l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_dot_l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_l_bracket_e_e_r_bracket_l_bracket_plus_minus_r_bracket_quest_l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let exponent_token_built = ExponentTokenBuilder::default()
            .l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_dot_l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_l_bracket_e_e_r_bracket_l_bracket_plus_minus_r_bracket_quest_l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star(l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_dot_l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_l_bracket_e_e_r_bracket_l_bracket_plus_minus_r_bracket_quest_l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.exponent_token(&exponent_token_built)?;
        self.push(ASTType::ExponentToken(exponent_token_built), context);
        Ok(())
    }

    /// Semantic action for production 7:
    ///
    /// FixedPointToken: /[0-9]+(?:_[0-9]+)*\.[0-9]+(?:_[0-9]+)*/ : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn fixed_point_token(
        &mut self,
        l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_dot_l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_dot_l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star = l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_dot_l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let fixed_point_token_built = FixedPointTokenBuilder::default()
            .l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_dot_l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star(l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_dot_l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .fixed_point_token(&fixed_point_token_built)?;
        self.push(ASTType::FixedPointToken(fixed_point_token_built), context);
        Ok(())
    }

    /// Semantic action for production 8:
    ///
    /// BasedBinaryToken: /[0-9]+(?:_[0-9]+)*'b[0-1xzXZ]+(?:_[0-1xzXZ]+)*/ : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn based_binary_token(
        &mut self,
        l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_tick_b_l_bracket0_minus1xz_x_z_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus1xz_x_z_r_bracket_plus_r_paren_star: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_tick_b_l_bracket0_minus1xz_x_z_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus1xz_x_z_r_bracket_plus_r_paren_star = l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_tick_b_l_bracket0_minus1xz_x_z_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus1xz_x_z_r_bracket_plus_r_paren_star.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let based_binary_token_built = BasedBinaryTokenBuilder::default()
            .l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_tick_b_l_bracket0_minus1xz_x_z_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus1xz_x_z_r_bracket_plus_r_paren_star(l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_tick_b_l_bracket0_minus1xz_x_z_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus1xz_x_z_r_bracket_plus_r_paren_star)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .based_binary_token(&based_binary_token_built)?;
        self.push(ASTType::BasedBinaryToken(based_binary_token_built), context);
        Ok(())
    }

    /// Semantic action for production 9:
    ///
    /// BasedOctalToken: /[0-9]+(?:_[0-9]+)*'o[0-7xzXZ]+(?:_[0-7xzXZ]+)*/ : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn based_octal_token(
        &mut self,
        l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_tick_o_l_bracket0_minus7xz_x_z_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus7xz_x_z_r_bracket_plus_r_paren_star: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_tick_o_l_bracket0_minus7xz_x_z_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus7xz_x_z_r_bracket_plus_r_paren_star = l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_tick_o_l_bracket0_minus7xz_x_z_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus7xz_x_z_r_bracket_plus_r_paren_star.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let based_octal_token_built = BasedOctalTokenBuilder::default()
            .l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_tick_o_l_bracket0_minus7xz_x_z_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus7xz_x_z_r_bracket_plus_r_paren_star(l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_tick_o_l_bracket0_minus7xz_x_z_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus7xz_x_z_r_bracket_plus_r_paren_star)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .based_octal_token(&based_octal_token_built)?;
        self.push(ASTType::BasedOctalToken(based_octal_token_built), context);
        Ok(())
    }

    /// Semantic action for production 10:
    ///
    /// BasedDecimalToken: /[0-9]+(?:_[0-9]+)*'d[0-9]+(?:_[0-9]+)*/ : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn based_decimal_token(
        &mut self,
        l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_tick_d_l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_tick_d_l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star = l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_tick_d_l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let based_decimal_token_built = BasedDecimalTokenBuilder::default()
            .l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_tick_d_l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star(l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_tick_d_l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .based_decimal_token(&based_decimal_token_built)?;
        self.push(
            ASTType::BasedDecimalToken(based_decimal_token_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 11:
    ///
    /// BasedHexToken: /[0-9]+(?:_[0-9]+)*'h[0-9a-fA-FxzXZ]+(?:_[0-9a-fA-FxzXZ]+)*/ : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn based_hex_token(
        &mut self,
        l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_tick_h_l_bracket0_minus9a_minus_f_a_minus_fxz_x_z_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9a_minus_f_a_minus_fxz_x_z_r_bracket_plus_r_paren_star: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_tick_h_l_bracket0_minus9a_minus_f_a_minus_fxz_x_z_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9a_minus_f_a_minus_fxz_x_z_r_bracket_plus_r_paren_star = l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_tick_h_l_bracket0_minus9a_minus_f_a_minus_fxz_x_z_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9a_minus_f_a_minus_fxz_x_z_r_bracket_plus_r_paren_star.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let based_hex_token_built = BasedHexTokenBuilder::default()
            .l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_tick_h_l_bracket0_minus9a_minus_f_a_minus_fxz_x_z_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9a_minus_f_a_minus_fxz_x_z_r_bracket_plus_r_paren_star(l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star_tick_h_l_bracket0_minus9a_minus_f_a_minus_fxz_x_z_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9a_minus_f_a_minus_fxz_x_z_r_bracket_plus_r_paren_star)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.based_hex_token(&based_hex_token_built)?;
        self.push(ASTType::BasedHexToken(based_hex_token_built), context);
        Ok(())
    }

    /// Semantic action for production 12:
    ///
    /// BaseLessToken: /[0-9]+(?:_[0-9]+)*/ : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn base_less_token(
        &mut self,
        l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star = l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let base_less_token_built = BaseLessTokenBuilder::default()
            .l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star(l_bracket0_minus9_r_bracket_plus_l_paren_quest_colon_underscore_l_bracket0_minus9_r_bracket_plus_r_paren_star)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.base_less_token(&base_less_token_built)?;
        self.push(ASTType::BaseLessToken(base_less_token_built), context);
        Ok(())
    }

    /// Semantic action for production 13:
    ///
    /// AllBitToken: /'[01]/ : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn all_bit_token(
        &mut self,
        tick_l_bracket01_r_bracket: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let tick_l_bracket01_r_bracket = tick_l_bracket01_r_bracket
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let all_bit_token_built = AllBitTokenBuilder::default()
            .tick_l_bracket01_r_bracket(tick_l_bracket01_r_bracket)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.all_bit_token(&all_bit_token_built)?;
        self.push(ASTType::AllBitToken(all_bit_token_built), context);
        Ok(())
    }

    /// Semantic action for production 14:
    ///
    /// Exponent: ExponentToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn exponent(
        &mut self,
        _exponent_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let exponent_token = pop_item!(self, exponent_token, ExponentToken, context);
        let exponent_built = ExponentBuilder::default()
            .exponent_token((&exponent_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.exponent(&exponent_built)?;
        self.push(ASTType::Exponent(exponent_built), context);
        Ok(())
    }

    /// Semantic action for production 15:
    ///
    /// FixedPoint: FixedPointToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn fixed_point(
        &mut self,
        _fixed_point_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let fixed_point_token = pop_item!(self, fixed_point_token, FixedPointToken, context);
        let fixed_point_built = FixedPointBuilder::default()
            .fixed_point_token((&fixed_point_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.fixed_point(&fixed_point_built)?;
        self.push(ASTType::FixedPoint(fixed_point_built), context);
        Ok(())
    }

    /// Semantic action for production 16:
    ///
    /// BasedBinary: BasedBinaryToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn based_binary(
        &mut self,
        _based_binary_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let based_binary_token = pop_item!(self, based_binary_token, BasedBinaryToken, context);
        let based_binary_built = BasedBinaryBuilder::default()
            .based_binary_token((&based_binary_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.based_binary(&based_binary_built)?;
        self.push(ASTType::BasedBinary(based_binary_built), context);
        Ok(())
    }

    /// Semantic action for production 17:
    ///
    /// BasedOctal: BasedOctalToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn based_octal(
        &mut self,
        _based_octal_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let based_octal_token = pop_item!(self, based_octal_token, BasedOctalToken, context);
        let based_octal_built = BasedOctalBuilder::default()
            .based_octal_token((&based_octal_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.based_octal(&based_octal_built)?;
        self.push(ASTType::BasedOctal(based_octal_built), context);
        Ok(())
    }

    /// Semantic action for production 18:
    ///
    /// BasedDecimal: BasedDecimalToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn based_decimal(
        &mut self,
        _based_decimal_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let based_decimal_token = pop_item!(self, based_decimal_token, BasedDecimalToken, context);
        let based_decimal_built = BasedDecimalBuilder::default()
            .based_decimal_token((&based_decimal_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.based_decimal(&based_decimal_built)?;
        self.push(ASTType::BasedDecimal(based_decimal_built), context);
        Ok(())
    }

    /// Semantic action for production 19:
    ///
    /// BasedHex: BasedHexToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn based_hex(
        &mut self,
        _based_hex_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let based_hex_token = pop_item!(self, based_hex_token, BasedHexToken, context);
        let based_hex_built = BasedHexBuilder::default()
            .based_hex_token((&based_hex_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.based_hex(&based_hex_built)?;
        self.push(ASTType::BasedHex(based_hex_built), context);
        Ok(())
    }

    /// Semantic action for production 20:
    ///
    /// BaseLess: BaseLessToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn base_less(
        &mut self,
        _base_less_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let base_less_token = pop_item!(self, base_less_token, BaseLessToken, context);
        let base_less_built = BaseLessBuilder::default()
            .base_less_token((&base_less_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.base_less(&base_less_built)?;
        self.push(ASTType::BaseLess(base_less_built), context);
        Ok(())
    }

    /// Semantic action for production 21:
    ///
    /// AllBit: AllBitToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn all_bit(
        &mut self,
        _all_bit_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let all_bit_token = pop_item!(self, all_bit_token, AllBitToken, context);
        let all_bit_built = AllBitBuilder::default()
            .all_bit_token((&all_bit_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.all_bit(&all_bit_built)?;
        self.push(ASTType::AllBit(all_bit_built), context);
        Ok(())
    }

    /// Semantic action for production 22:
    ///
    /// BangEquEquToken: '!==' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn bang_equ_equ_token(
        &mut self,
        bang_equ_equ: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bang_equ_equ = bang_equ_equ
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let bang_equ_equ_token_built = BangEquEquTokenBuilder::default()
            .bang_equ_equ(bang_equ_equ)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .bang_equ_equ_token(&bang_equ_equ_token_built)?;
        self.push(ASTType::BangEquEquToken(bang_equ_equ_token_built), context);
        Ok(())
    }

    /// Semantic action for production 23:
    ///
    /// BangEquQuestToken: '!=?' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn bang_equ_quest_token(
        &mut self,
        bang_equ_quest: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bang_equ_quest = bang_equ_quest
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let bang_equ_quest_token_built = BangEquQuestTokenBuilder::default()
            .bang_equ_quest(bang_equ_quest)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .bang_equ_quest_token(&bang_equ_quest_token_built)?;
        self.push(
            ASTType::BangEquQuestToken(bang_equ_quest_token_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 24:
    ///
    /// EquEquEquToken: '===' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn equ_equ_equ_token(
        &mut self,
        equ_equ_equ: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let equ_equ_equ = equ_equ_equ
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let equ_equ_equ_token_built = EquEquEquTokenBuilder::default()
            .equ_equ_equ(equ_equ_equ)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .equ_equ_equ_token(&equ_equ_equ_token_built)?;
        self.push(ASTType::EquEquEquToken(equ_equ_equ_token_built), context);
        Ok(())
    }

    /// Semantic action for production 25:
    ///
    /// EquEquQuestToken: '==?' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn equ_equ_quest_token(
        &mut self,
        equ_equ_quest: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let equ_equ_quest = equ_equ_quest
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let equ_equ_quest_token_built = EquEquQuestTokenBuilder::default()
            .equ_equ_quest(equ_equ_quest)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .equ_equ_quest_token(&equ_equ_quest_token_built)?;
        self.push(
            ASTType::EquEquQuestToken(equ_equ_quest_token_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 26:
    ///
    /// GTGTGTToken: '>>>' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn g_t_g_t_g_t_token(
        &mut self,
        g_t_g_t_g_t: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let g_t_g_t_g_t = g_t_g_t_g_t
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let g_t_g_t_g_t_token_built = GTGTGTTokenBuilder::default()
            .g_t_g_t_g_t(g_t_g_t_g_t)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .g_t_g_t_g_t_token(&g_t_g_t_g_t_token_built)?;
        self.push(ASTType::GTGTGTToken(g_t_g_t_g_t_token_built), context);
        Ok(())
    }

    /// Semantic action for production 27:
    ///
    /// LTLTLTToken: '<<<' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn l_t_l_t_l_t_token(
        &mut self,
        l_t_l_t_l_t: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_t_l_t_l_t = l_t_l_t_l_t
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let l_t_l_t_l_t_token_built = LTLTLTTokenBuilder::default()
            .l_t_l_t_l_t(l_t_l_t_l_t)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .l_t_l_t_l_t_token(&l_t_l_t_l_t_token_built)?;
        self.push(ASTType::LTLTLTToken(l_t_l_t_l_t_token_built), context);
        Ok(())
    }

    /// Semantic action for production 28:
    ///
    /// BangEquEqu: BangEquEquToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn bang_equ_equ(
        &mut self,
        _bang_equ_equ_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bang_equ_equ_token = pop_item!(self, bang_equ_equ_token, BangEquEquToken, context);
        let bang_equ_equ_built = BangEquEquBuilder::default()
            .bang_equ_equ_token((&bang_equ_equ_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.bang_equ_equ(&bang_equ_equ_built)?;
        self.push(ASTType::BangEquEqu(bang_equ_equ_built), context);
        Ok(())
    }

    /// Semantic action for production 29:
    ///
    /// BangEquQuest: BangEquQuestToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn bang_equ_quest(
        &mut self,
        _bang_equ_quest_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bang_equ_quest_token =
            pop_item!(self, bang_equ_quest_token, BangEquQuestToken, context);
        let bang_equ_quest_built = BangEquQuestBuilder::default()
            .bang_equ_quest_token((&bang_equ_quest_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.bang_equ_quest(&bang_equ_quest_built)?;
        self.push(ASTType::BangEquQuest(bang_equ_quest_built), context);
        Ok(())
    }

    /// Semantic action for production 30:
    ///
    /// EquEquEqu: EquEquEquToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn equ_equ_equ(
        &mut self,
        _equ_equ_equ_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let equ_equ_equ_token = pop_item!(self, equ_equ_equ_token, EquEquEquToken, context);
        let equ_equ_equ_built = EquEquEquBuilder::default()
            .equ_equ_equ_token((&equ_equ_equ_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.equ_equ_equ(&equ_equ_equ_built)?;
        self.push(ASTType::EquEquEqu(equ_equ_equ_built), context);
        Ok(())
    }

    /// Semantic action for production 31:
    ///
    /// EquEquQuest: EquEquQuestToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn equ_equ_quest(
        &mut self,
        _equ_equ_quest_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let equ_equ_quest_token = pop_item!(self, equ_equ_quest_token, EquEquQuestToken, context);
        let equ_equ_quest_built = EquEquQuestBuilder::default()
            .equ_equ_quest_token((&equ_equ_quest_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.equ_equ_quest(&equ_equ_quest_built)?;
        self.push(ASTType::EquEquQuest(equ_equ_quest_built), context);
        Ok(())
    }

    /// Semantic action for production 32:
    ///
    /// GTGTGT: GTGTGTToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn g_t_g_t_g_t(
        &mut self,
        _g_t_g_t_g_t_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let g_t_g_t_g_t_token = pop_item!(self, g_t_g_t_g_t_token, GTGTGTToken, context);
        let g_t_g_t_g_t_built = GTGTGTBuilder::default()
            .g_t_g_t_g_t_token((&g_t_g_t_g_t_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.g_t_g_t_g_t(&g_t_g_t_g_t_built)?;
        self.push(ASTType::GTGTGT(g_t_g_t_g_t_built), context);
        Ok(())
    }

    /// Semantic action for production 33:
    ///
    /// LTLTLT: LTLTLTToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn l_t_l_t_l_t(
        &mut self,
        _l_t_l_t_l_t_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_t_l_t_l_t_token = pop_item!(self, l_t_l_t_l_t_token, LTLTLTToken, context);
        let l_t_l_t_l_t_built = LTLTLTBuilder::default()
            .l_t_l_t_l_t_token((&l_t_l_t_l_t_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.l_t_l_t_l_t(&l_t_l_t_l_t_built)?;
        self.push(ASTType::LTLTLT(l_t_l_t_l_t_built), context);
        Ok(())
    }

    /// Semantic action for production 34:
    ///
    /// AmpAmpToken: '&&' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn amp_amp_token(
        &mut self,
        amp_amp: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let amp_amp = amp_amp.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let amp_amp_token_built = AmpAmpTokenBuilder::default()
            .amp_amp(amp_amp)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.amp_amp_token(&amp_amp_token_built)?;
        self.push(ASTType::AmpAmpToken(amp_amp_token_built), context);
        Ok(())
    }

    /// Semantic action for production 35:
    ///
    /// CircumflexTildeToken: '^~' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn circumflex_tilde_token(
        &mut self,
        circumflex_tilde: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let circumflex_tilde = circumflex_tilde
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let circumflex_tilde_token_built = CircumflexTildeTokenBuilder::default()
            .circumflex_tilde(circumflex_tilde)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .circumflex_tilde_token(&circumflex_tilde_token_built)?;
        self.push(
            ASTType::CircumflexTildeToken(circumflex_tilde_token_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 36:
    ///
    /// BangEquToken: '!=' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn bang_equ_token(
        &mut self,
        bang_equ: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bang_equ = bang_equ.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let bang_equ_token_built = BangEquTokenBuilder::default()
            .bang_equ(bang_equ)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.bang_equ_token(&bang_equ_token_built)?;
        self.push(ASTType::BangEquToken(bang_equ_token_built), context);
        Ok(())
    }

    /// Semantic action for production 37:
    ///
    /// EquEquToken: '==' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn equ_equ_token(
        &mut self,
        equ_equ: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let equ_equ = equ_equ.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let equ_equ_token_built = EquEquTokenBuilder::default()
            .equ_equ(equ_equ)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.equ_equ_token(&equ_equ_token_built)?;
        self.push(ASTType::EquEquToken(equ_equ_token_built), context);
        Ok(())
    }

    /// Semantic action for production 38:
    ///
    /// GTEquToken: '>=' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn g_t_equ_token(
        &mut self,
        g_t_equ: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let g_t_equ = g_t_equ.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let g_t_equ_token_built = GTEquTokenBuilder::default()
            .g_t_equ(g_t_equ)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.g_t_equ_token(&g_t_equ_token_built)?;
        self.push(ASTType::GTEquToken(g_t_equ_token_built), context);
        Ok(())
    }

    /// Semantic action for production 39:
    ///
    /// GTGTToken: '>>' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn g_t_g_t_token(
        &mut self,
        g_t_g_t: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let g_t_g_t = g_t_g_t.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let g_t_g_t_token_built = GTGTTokenBuilder::default()
            .g_t_g_t(g_t_g_t)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.g_t_g_t_token(&g_t_g_t_token_built)?;
        self.push(ASTType::GTGTToken(g_t_g_t_token_built), context);
        Ok(())
    }

    /// Semantic action for production 40:
    ///
    /// LTEquToken: '<=' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn l_t_equ_token(
        &mut self,
        l_t_equ: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_t_equ = l_t_equ.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let l_t_equ_token_built = LTEquTokenBuilder::default()
            .l_t_equ(l_t_equ)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.l_t_equ_token(&l_t_equ_token_built)?;
        self.push(ASTType::LTEquToken(l_t_equ_token_built), context);
        Ok(())
    }

    /// Semantic action for production 41:
    ///
    /// LTLTToken: '<<' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn l_t_l_t_token(
        &mut self,
        l_t_l_t: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_t_l_t = l_t_l_t.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let l_t_l_t_token_built = LTLTTokenBuilder::default()
            .l_t_l_t(l_t_l_t)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.l_t_l_t_token(&l_t_l_t_token_built)?;
        self.push(ASTType::LTLTToken(l_t_l_t_token_built), context);
        Ok(())
    }

    /// Semantic action for production 42:
    ///
    /// OrOrToken: '||' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn or_or_token(
        &mut self,
        or_or: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let or_or = or_or.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let or_or_token_built = OrOrTokenBuilder::default()
            .or_or(or_or)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.or_or_token(&or_or_token_built)?;
        self.push(ASTType::OrOrToken(or_or_token_built), context);
        Ok(())
    }

    /// Semantic action for production 43:
    ///
    /// StarStarToken: '**' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn star_star_token(
        &mut self,
        star_star: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let star_star = star_star.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let star_star_token_built = StarStarTokenBuilder::default()
            .star_star(star_star)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.star_star_token(&star_star_token_built)?;
        self.push(ASTType::StarStarToken(star_star_token_built), context);
        Ok(())
    }

    /// Semantic action for production 44:
    ///
    /// TildeAmpToken: '~&' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn tilde_amp_token(
        &mut self,
        tilde_amp: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let tilde_amp = tilde_amp.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let tilde_amp_token_built = TildeAmpTokenBuilder::default()
            .tilde_amp(tilde_amp)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.tilde_amp_token(&tilde_amp_token_built)?;
        self.push(ASTType::TildeAmpToken(tilde_amp_token_built), context);
        Ok(())
    }

    /// Semantic action for production 45:
    ///
    /// TildeCircumflexToken: '~^' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn tilde_circumflex_token(
        &mut self,
        tilde_circumflex: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let tilde_circumflex = tilde_circumflex
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let tilde_circumflex_token_built = TildeCircumflexTokenBuilder::default()
            .tilde_circumflex(tilde_circumflex)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .tilde_circumflex_token(&tilde_circumflex_token_built)?;
        self.push(
            ASTType::TildeCircumflexToken(tilde_circumflex_token_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 46:
    ///
    /// TildeOrToken: '~|' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn tilde_or_token(
        &mut self,
        tilde_or: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let tilde_or = tilde_or.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let tilde_or_token_built = TildeOrTokenBuilder::default()
            .tilde_or(tilde_or)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.tilde_or_token(&tilde_or_token_built)?;
        self.push(ASTType::TildeOrToken(tilde_or_token_built), context);
        Ok(())
    }

    /// Semantic action for production 47:
    ///
    /// AmpAmp: AmpAmpToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn amp_amp(
        &mut self,
        _amp_amp_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let amp_amp_token = pop_item!(self, amp_amp_token, AmpAmpToken, context);
        let amp_amp_built = AmpAmpBuilder::default()
            .amp_amp_token((&amp_amp_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.amp_amp(&amp_amp_built)?;
        self.push(ASTType::AmpAmp(amp_amp_built), context);
        Ok(())
    }

    /// Semantic action for production 48:
    ///
    /// CircumflexTilde: CircumflexTildeToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn circumflex_tilde(
        &mut self,
        _circumflex_tilde_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let circumflex_tilde_token =
            pop_item!(self, circumflex_tilde_token, CircumflexTildeToken, context);
        let circumflex_tilde_built = CircumflexTildeBuilder::default()
            .circumflex_tilde_token((&circumflex_tilde_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .circumflex_tilde(&circumflex_tilde_built)?;
        self.push(ASTType::CircumflexTilde(circumflex_tilde_built), context);
        Ok(())
    }

    /// Semantic action for production 49:
    ///
    /// BangEqu: BangEquToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn bang_equ(
        &mut self,
        _bang_equ_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bang_equ_token = pop_item!(self, bang_equ_token, BangEquToken, context);
        let bang_equ_built = BangEquBuilder::default()
            .bang_equ_token((&bang_equ_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.bang_equ(&bang_equ_built)?;
        self.push(ASTType::BangEqu(bang_equ_built), context);
        Ok(())
    }

    /// Semantic action for production 50:
    ///
    /// EquEqu: EquEquToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn equ_equ(
        &mut self,
        _equ_equ_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let equ_equ_token = pop_item!(self, equ_equ_token, EquEquToken, context);
        let equ_equ_built = EquEquBuilder::default()
            .equ_equ_token((&equ_equ_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.equ_equ(&equ_equ_built)?;
        self.push(ASTType::EquEqu(equ_equ_built), context);
        Ok(())
    }

    /// Semantic action for production 51:
    ///
    /// GTEqu: GTEquToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn g_t_equ(
        &mut self,
        _g_t_equ_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let g_t_equ_token = pop_item!(self, g_t_equ_token, GTEquToken, context);
        let g_t_equ_built = GTEquBuilder::default()
            .g_t_equ_token((&g_t_equ_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.g_t_equ(&g_t_equ_built)?;
        self.push(ASTType::GTEqu(g_t_equ_built), context);
        Ok(())
    }

    /// Semantic action for production 52:
    ///
    /// GTGT: GTGTToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn g_t_g_t(
        &mut self,
        _g_t_g_t_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let g_t_g_t_token = pop_item!(self, g_t_g_t_token, GTGTToken, context);
        let g_t_g_t_built = GTGTBuilder::default()
            .g_t_g_t_token((&g_t_g_t_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.g_t_g_t(&g_t_g_t_built)?;
        self.push(ASTType::GTGT(g_t_g_t_built), context);
        Ok(())
    }

    /// Semantic action for production 53:
    ///
    /// LTEqu: LTEquToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn l_t_equ(
        &mut self,
        _l_t_equ_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_t_equ_token = pop_item!(self, l_t_equ_token, LTEquToken, context);
        let l_t_equ_built = LTEquBuilder::default()
            .l_t_equ_token((&l_t_equ_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.l_t_equ(&l_t_equ_built)?;
        self.push(ASTType::LTEqu(l_t_equ_built), context);
        Ok(())
    }

    /// Semantic action for production 54:
    ///
    /// LTLT: LTLTToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn l_t_l_t(
        &mut self,
        _l_t_l_t_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_t_l_t_token = pop_item!(self, l_t_l_t_token, LTLTToken, context);
        let l_t_l_t_built = LTLTBuilder::default()
            .l_t_l_t_token((&l_t_l_t_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.l_t_l_t(&l_t_l_t_built)?;
        self.push(ASTType::LTLT(l_t_l_t_built), context);
        Ok(())
    }

    /// Semantic action for production 55:
    ///
    /// OrOr: OrOrToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn or_or(
        &mut self,
        _or_or_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let or_or_token = pop_item!(self, or_or_token, OrOrToken, context);
        let or_or_built = OrOrBuilder::default()
            .or_or_token((&or_or_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.or_or(&or_or_built)?;
        self.push(ASTType::OrOr(or_or_built), context);
        Ok(())
    }

    /// Semantic action for production 56:
    ///
    /// StarStar: StarStarToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn star_star(
        &mut self,
        _star_star_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let star_star_token = pop_item!(self, star_star_token, StarStarToken, context);
        let star_star_built = StarStarBuilder::default()
            .star_star_token((&star_star_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.star_star(&star_star_built)?;
        self.push(ASTType::StarStar(star_star_built), context);
        Ok(())
    }

    /// Semantic action for production 57:
    ///
    /// TildeAmp: TildeAmpToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn tilde_amp(
        &mut self,
        _tilde_amp_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let tilde_amp_token = pop_item!(self, tilde_amp_token, TildeAmpToken, context);
        let tilde_amp_built = TildeAmpBuilder::default()
            .tilde_amp_token((&tilde_amp_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.tilde_amp(&tilde_amp_built)?;
        self.push(ASTType::TildeAmp(tilde_amp_built), context);
        Ok(())
    }

    /// Semantic action for production 58:
    ///
    /// TildeCircumflex: TildeCircumflexToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn tilde_circumflex(
        &mut self,
        _tilde_circumflex_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let tilde_circumflex_token =
            pop_item!(self, tilde_circumflex_token, TildeCircumflexToken, context);
        let tilde_circumflex_built = TildeCircumflexBuilder::default()
            .tilde_circumflex_token((&tilde_circumflex_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .tilde_circumflex(&tilde_circumflex_built)?;
        self.push(ASTType::TildeCircumflex(tilde_circumflex_built), context);
        Ok(())
    }

    /// Semantic action for production 59:
    ///
    /// TildeOr: TildeOrToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn tilde_or(
        &mut self,
        _tilde_or_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let tilde_or_token = pop_item!(self, tilde_or_token, TildeOrToken, context);
        let tilde_or_built = TildeOrBuilder::default()
            .tilde_or_token((&tilde_or_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.tilde_or(&tilde_or_built)?;
        self.push(ASTType::TildeOr(tilde_or_built), context);
        Ok(())
    }

    /// Semantic action for production 60:
    ///
    /// AmpToken: '&' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn amp_token(
        &mut self,
        amp: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let amp = amp.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let amp_token_built = AmpTokenBuilder::default()
            .amp(amp)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.amp_token(&amp_token_built)?;
        self.push(ASTType::AmpToken(amp_token_built), context);
        Ok(())
    }

    /// Semantic action for production 61:
    ///
    /// BangToken: '!' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn bang_token(
        &mut self,
        bang: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bang = bang.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let bang_token_built = BangTokenBuilder::default()
            .bang(bang)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.bang_token(&bang_token_built)?;
        self.push(ASTType::BangToken(bang_token_built), context);
        Ok(())
    }

    /// Semantic action for production 62:
    ///
    /// ColonToken: ':' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn colon_token(
        &mut self,
        colon: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let colon = colon.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let colon_token_built = ColonTokenBuilder::default()
            .colon(colon)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.colon_token(&colon_token_built)?;
        self.push(ASTType::ColonToken(colon_token_built), context);
        Ok(())
    }

    /// Semantic action for production 63:
    ///
    /// CommaToken: ',' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn comma_token(
        &mut self,
        comma: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = comma.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let comma_token_built = CommaTokenBuilder::default()
            .comma(comma)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.comma_token(&comma_token_built)?;
        self.push(ASTType::CommaToken(comma_token_built), context);
        Ok(())
    }

    /// Semantic action for production 64:
    ///
    /// CircumflexToken: '^' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn circumflex_token(
        &mut self,
        circumflex: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let circumflex = circumflex.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let circumflex_token_built = CircumflexTokenBuilder::default()
            .circumflex(circumflex)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .circumflex_token(&circumflex_token_built)?;
        self.push(ASTType::CircumflexToken(circumflex_token_built), context);
        Ok(())
    }

    /// Semantic action for production 65:
    ///
    /// EquToken: '=' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn equ_token(
        &mut self,
        equ: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let equ = equ.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let equ_token_built = EquTokenBuilder::default()
            .equ(equ)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.equ_token(&equ_token_built)?;
        self.push(ASTType::EquToken(equ_token_built), context);
        Ok(())
    }

    /// Semantic action for production 66:
    ///
    /// GTToken: '>' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn g_t_token(
        &mut self,
        g_t: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let g_t = g_t.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let g_t_token_built = GTTokenBuilder::default()
            .g_t(g_t)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.g_t_token(&g_t_token_built)?;
        self.push(ASTType::GTToken(g_t_token_built), context);
        Ok(())
    }

    /// Semantic action for production 67:
    ///
    /// HashToken: '#' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn hash_token(
        &mut self,
        hash: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let hash = hash.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let hash_token_built = HashTokenBuilder::default()
            .hash(hash)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.hash_token(&hash_token_built)?;
        self.push(ASTType::HashToken(hash_token_built), context);
        Ok(())
    }

    /// Semantic action for production 68:
    ///
    /// LBraceToken: '{' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn l_brace_token(
        &mut self,
        l_brace: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_brace = l_brace.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let l_brace_token_built = LBraceTokenBuilder::default()
            .l_brace(l_brace)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.l_brace_token(&l_brace_token_built)?;
        self.push(ASTType::LBraceToken(l_brace_token_built), context);
        Ok(())
    }

    /// Semantic action for production 69:
    ///
    /// LBracketToken: '[' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn l_bracket_token(
        &mut self,
        l_bracket: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_bracket = l_bracket.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let l_bracket_token_built = LBracketTokenBuilder::default()
            .l_bracket(l_bracket)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.l_bracket_token(&l_bracket_token_built)?;
        self.push(ASTType::LBracketToken(l_bracket_token_built), context);
        Ok(())
    }

    /// Semantic action for production 70:
    ///
    /// LParenToken: '(' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn l_paren_token(
        &mut self,
        l_paren: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_paren = l_paren.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let l_paren_token_built = LParenTokenBuilder::default()
            .l_paren(l_paren)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.l_paren_token(&l_paren_token_built)?;
        self.push(ASTType::LParenToken(l_paren_token_built), context);
        Ok(())
    }

    /// Semantic action for production 71:
    ///
    /// LTToken: '<' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn l_t_token(
        &mut self,
        l_t: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_t = l_t.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let l_t_token_built = LTTokenBuilder::default()
            .l_t(l_t)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.l_t_token(&l_t_token_built)?;
        self.push(ASTType::LTToken(l_t_token_built), context);
        Ok(())
    }

    /// Semantic action for production 72:
    ///
    /// MinusToken: '-' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn minus_token(
        &mut self,
        minus: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let minus = minus.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let minus_token_built = MinusTokenBuilder::default()
            .minus(minus)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.minus_token(&minus_token_built)?;
        self.push(ASTType::MinusToken(minus_token_built), context);
        Ok(())
    }

    /// Semantic action for production 73:
    ///
    /// OrToken: '|' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn or_token(
        &mut self,
        or: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let or = or.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let or_token_built = OrTokenBuilder::default()
            .or(or)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.or_token(&or_token_built)?;
        self.push(ASTType::OrToken(or_token_built), context);
        Ok(())
    }

    /// Semantic action for production 74:
    ///
    /// PercentToken: '%' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn percent_token(
        &mut self,
        percent: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let percent = percent.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let percent_token_built = PercentTokenBuilder::default()
            .percent(percent)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.percent_token(&percent_token_built)?;
        self.push(ASTType::PercentToken(percent_token_built), context);
        Ok(())
    }

    /// Semantic action for production 75:
    ///
    /// PlusToken: '+' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn plus_token(
        &mut self,
        plus: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let plus = plus.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let plus_token_built = PlusTokenBuilder::default()
            .plus(plus)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.plus_token(&plus_token_built)?;
        self.push(ASTType::PlusToken(plus_token_built), context);
        Ok(())
    }

    /// Semantic action for production 76:
    ///
    /// RBraceToken: '}' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn r_brace_token(
        &mut self,
        r_brace: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = r_brace.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let r_brace_token_built = RBraceTokenBuilder::default()
            .r_brace(r_brace)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.r_brace_token(&r_brace_token_built)?;
        self.push(ASTType::RBraceToken(r_brace_token_built), context);
        Ok(())
    }

    /// Semantic action for production 77:
    ///
    /// RBracketToken: ']' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn r_bracket_token(
        &mut self,
        r_bracket: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_bracket = r_bracket.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let r_bracket_token_built = RBracketTokenBuilder::default()
            .r_bracket(r_bracket)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.r_bracket_token(&r_bracket_token_built)?;
        self.push(ASTType::RBracketToken(r_bracket_token_built), context);
        Ok(())
    }

    /// Semantic action for production 78:
    ///
    /// RParenToken: ')' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn r_paren_token(
        &mut self,
        r_paren: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren = r_paren.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let r_paren_token_built = RParenTokenBuilder::default()
            .r_paren(r_paren)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.r_paren_token(&r_paren_token_built)?;
        self.push(ASTType::RParenToken(r_paren_token_built), context);
        Ok(())
    }

    /// Semantic action for production 79:
    ///
    /// SemicolonToken: ';' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn semicolon_token(
        &mut self,
        semicolon: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon = semicolon.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let semicolon_token_built = SemicolonTokenBuilder::default()
            .semicolon(semicolon)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.semicolon_token(&semicolon_token_built)?;
        self.push(ASTType::SemicolonToken(semicolon_token_built), context);
        Ok(())
    }

    /// Semantic action for production 80:
    ///
    /// SlashToken: '/' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn slash_token(
        &mut self,
        slash: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let slash = slash.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let slash_token_built = SlashTokenBuilder::default()
            .slash(slash)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.slash_token(&slash_token_built)?;
        self.push(ASTType::SlashToken(slash_token_built), context);
        Ok(())
    }

    /// Semantic action for production 81:
    ///
    /// StarToken: '*' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn star_token(
        &mut self,
        star: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let star = star.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let star_token_built = StarTokenBuilder::default()
            .star(star)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.star_token(&star_token_built)?;
        self.push(ASTType::StarToken(star_token_built), context);
        Ok(())
    }

    /// Semantic action for production 82:
    ///
    /// TildeToken: '~' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn tilde_token(
        &mut self,
        tilde: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let tilde = tilde.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let tilde_token_built = TildeTokenBuilder::default()
            .tilde(tilde)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.tilde_token(&tilde_token_built)?;
        self.push(ASTType::TildeToken(tilde_token_built), context);
        Ok(())
    }

    /// Semantic action for production 83:
    ///
    /// Amp: AmpToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn amp(
        &mut self,
        _amp_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let amp_token = pop_item!(self, amp_token, AmpToken, context);
        let amp_built = AmpBuilder::default()
            .amp_token((&amp_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.amp(&amp_built)?;
        self.push(ASTType::Amp(amp_built), context);
        Ok(())
    }

    /// Semantic action for production 84:
    ///
    /// Bang: BangToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn bang(
        &mut self,
        _bang_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bang_token = pop_item!(self, bang_token, BangToken, context);
        let bang_built = BangBuilder::default()
            .bang_token((&bang_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.bang(&bang_built)?;
        self.push(ASTType::Bang(bang_built), context);
        Ok(())
    }

    /// Semantic action for production 85:
    ///
    /// Circumflex: CircumflexToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn circumflex(
        &mut self,
        _circumflex_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let circumflex_token = pop_item!(self, circumflex_token, CircumflexToken, context);
        let circumflex_built = CircumflexBuilder::default()
            .circumflex_token((&circumflex_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.circumflex(&circumflex_built)?;
        self.push(ASTType::Circumflex(circumflex_built), context);
        Ok(())
    }

    /// Semantic action for production 86:
    ///
    /// Colon: ColonToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn colon(
        &mut self,
        _colon_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let colon_token = pop_item!(self, colon_token, ColonToken, context);
        let colon_built = ColonBuilder::default()
            .colon_token((&colon_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.colon(&colon_built)?;
        self.push(ASTType::Colon(colon_built), context);
        Ok(())
    }

    /// Semantic action for production 87:
    ///
    /// Comma: CommaToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn comma(
        &mut self,
        _comma_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma_token = pop_item!(self, comma_token, CommaToken, context);
        let comma_built = CommaBuilder::default()
            .comma_token((&comma_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.comma(&comma_built)?;
        self.push(ASTType::Comma(comma_built), context);
        Ok(())
    }

    /// Semantic action for production 88:
    ///
    /// Equ: EquToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn equ(
        &mut self,
        _equ_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let equ_token = pop_item!(self, equ_token, EquToken, context);
        let equ_built = EquBuilder::default()
            .equ_token((&equ_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.equ(&equ_built)?;
        self.push(ASTType::Equ(equ_built), context);
        Ok(())
    }

    /// Semantic action for production 89:
    ///
    /// GT: GTToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn g_t(
        &mut self,
        _g_t_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let g_t_token = pop_item!(self, g_t_token, GTToken, context);
        let g_t_built = GTBuilder::default()
            .g_t_token((&g_t_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.g_t(&g_t_built)?;
        self.push(ASTType::GT(g_t_built), context);
        Ok(())
    }

    /// Semantic action for production 90:
    ///
    /// Hash: HashToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn hash(
        &mut self,
        _hash_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let hash_token = pop_item!(self, hash_token, HashToken, context);
        let hash_built = HashBuilder::default()
            .hash_token((&hash_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.hash(&hash_built)?;
        self.push(ASTType::Hash(hash_built), context);
        Ok(())
    }

    /// Semantic action for production 91:
    ///
    /// LBrace: LBraceToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn l_brace(
        &mut self,
        _l_brace_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_brace_token = pop_item!(self, l_brace_token, LBraceToken, context);
        let l_brace_built = LBraceBuilder::default()
            .l_brace_token((&l_brace_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.l_brace(&l_brace_built)?;
        self.push(ASTType::LBrace(l_brace_built), context);
        Ok(())
    }

    /// Semantic action for production 92:
    ///
    /// LBracket: LBracketToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn l_bracket(
        &mut self,
        _l_bracket_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_bracket_token = pop_item!(self, l_bracket_token, LBracketToken, context);
        let l_bracket_built = LBracketBuilder::default()
            .l_bracket_token((&l_bracket_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.l_bracket(&l_bracket_built)?;
        self.push(ASTType::LBracket(l_bracket_built), context);
        Ok(())
    }

    /// Semantic action for production 93:
    ///
    /// LParen: LParenToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn l_paren(
        &mut self,
        _l_paren_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_paren_token = pop_item!(self, l_paren_token, LParenToken, context);
        let l_paren_built = LParenBuilder::default()
            .l_paren_token((&l_paren_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.l_paren(&l_paren_built)?;
        self.push(ASTType::LParen(l_paren_built), context);
        Ok(())
    }

    /// Semantic action for production 94:
    ///
    /// LT: LTToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn l_t(
        &mut self,
        _l_t_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_t_token = pop_item!(self, l_t_token, LTToken, context);
        let l_t_built = LTBuilder::default()
            .l_t_token((&l_t_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.l_t(&l_t_built)?;
        self.push(ASTType::LT(l_t_built), context);
        Ok(())
    }

    /// Semantic action for production 95:
    ///
    /// Minus: MinusToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn minus(
        &mut self,
        _minus_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let minus_token = pop_item!(self, minus_token, MinusToken, context);
        let minus_built = MinusBuilder::default()
            .minus_token((&minus_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.minus(&minus_built)?;
        self.push(ASTType::Minus(minus_built), context);
        Ok(())
    }

    /// Semantic action for production 96:
    ///
    /// Or: OrToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn or(
        &mut self,
        _or_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let or_token = pop_item!(self, or_token, OrToken, context);
        let or_built = OrBuilder::default()
            .or_token((&or_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.or(&or_built)?;
        self.push(ASTType::Or(or_built), context);
        Ok(())
    }

    /// Semantic action for production 97:
    ///
    /// Percent: PercentToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn percent(
        &mut self,
        _percent_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let percent_token = pop_item!(self, percent_token, PercentToken, context);
        let percent_built = PercentBuilder::default()
            .percent_token((&percent_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.percent(&percent_built)?;
        self.push(ASTType::Percent(percent_built), context);
        Ok(())
    }

    /// Semantic action for production 98:
    ///
    /// Plus: PlusToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn plus(
        &mut self,
        _plus_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let plus_token = pop_item!(self, plus_token, PlusToken, context);
        let plus_built = PlusBuilder::default()
            .plus_token((&plus_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.plus(&plus_built)?;
        self.push(ASTType::Plus(plus_built), context);
        Ok(())
    }

    /// Semantic action for production 99:
    ///
    /// RBrace: RBraceToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn r_brace(
        &mut self,
        _r_brace_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace_token = pop_item!(self, r_brace_token, RBraceToken, context);
        let r_brace_built = RBraceBuilder::default()
            .r_brace_token((&r_brace_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.r_brace(&r_brace_built)?;
        self.push(ASTType::RBrace(r_brace_built), context);
        Ok(())
    }

    /// Semantic action for production 100:
    ///
    /// RBracket: RBracketToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn r_bracket(
        &mut self,
        _r_bracket_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_bracket_token = pop_item!(self, r_bracket_token, RBracketToken, context);
        let r_bracket_built = RBracketBuilder::default()
            .r_bracket_token((&r_bracket_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.r_bracket(&r_bracket_built)?;
        self.push(ASTType::RBracket(r_bracket_built), context);
        Ok(())
    }

    /// Semantic action for production 101:
    ///
    /// RParen: RParenToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn r_paren(
        &mut self,
        _r_paren_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren_token = pop_item!(self, r_paren_token, RParenToken, context);
        let r_paren_built = RParenBuilder::default()
            .r_paren_token((&r_paren_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.r_paren(&r_paren_built)?;
        self.push(ASTType::RParen(r_paren_built), context);
        Ok(())
    }

    /// Semantic action for production 102:
    ///
    /// Semicolon: SemicolonToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn semicolon(
        &mut self,
        _semicolon_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon_token = pop_item!(self, semicolon_token, SemicolonToken, context);
        let semicolon_built = SemicolonBuilder::default()
            .semicolon_token((&semicolon_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.semicolon(&semicolon_built)?;
        self.push(ASTType::Semicolon(semicolon_built), context);
        Ok(())
    }

    /// Semantic action for production 103:
    ///
    /// Slash: SlashToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn slash(
        &mut self,
        _slash_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let slash_token = pop_item!(self, slash_token, SlashToken, context);
        let slash_built = SlashBuilder::default()
            .slash_token((&slash_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.slash(&slash_built)?;
        self.push(ASTType::Slash(slash_built), context);
        Ok(())
    }

    /// Semantic action for production 104:
    ///
    /// Star: StarToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn star(
        &mut self,
        _star_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let star_token = pop_item!(self, star_token, StarToken, context);
        let star_built = StarBuilder::default()
            .star_token((&star_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.star(&star_built)?;
        self.push(ASTType::Star(star_built), context);
        Ok(())
    }

    /// Semantic action for production 105:
    ///
    /// Tilde: TildeToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn tilde(
        &mut self,
        _tilde_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let tilde_token = pop_item!(self, tilde_token, TildeToken, context);
        let tilde_built = TildeBuilder::default()
            .tilde_token((&tilde_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.tilde(&tilde_built)?;
        self.push(ASTType::Tilde(tilde_built), context);
        Ok(())
    }

    /// Semantic action for production 106:
    ///
    /// AlwaysCombToken: 'always_comb' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn always_comb_token(
        &mut self,
        always_underscore_comb: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let always_underscore_comb = always_underscore_comb
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let always_comb_token_built = AlwaysCombTokenBuilder::default()
            .always_underscore_comb(always_underscore_comb)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .always_comb_token(&always_comb_token_built)?;
        self.push(ASTType::AlwaysCombToken(always_comb_token_built), context);
        Ok(())
    }

    /// Semantic action for production 107:
    ///
    /// AlwaysFfToken: 'always_ff' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_token(
        &mut self,
        always_underscore_ff: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let always_underscore_ff = always_underscore_ff
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let always_ff_token_built = AlwaysFfTokenBuilder::default()
            .always_underscore_ff(always_underscore_ff)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.always_ff_token(&always_ff_token_built)?;
        self.push(ASTType::AlwaysFfToken(always_ff_token_built), context);
        Ok(())
    }

    /// Semantic action for production 108:
    ///
    /// AssignToken: 'assign' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn assign_token(
        &mut self,
        assign: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let assign = assign.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let assign_token_built = AssignTokenBuilder::default()
            .assign(assign)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.assign_token(&assign_token_built)?;
        self.push(ASTType::AssignToken(assign_token_built), context);
        Ok(())
    }

    /// Semantic action for production 109:
    ///
    /// BitToken: 'bit' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn bit_token(
        &mut self,
        bit: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bit = bit.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let bit_token_built = BitTokenBuilder::default()
            .bit(bit)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.bit_token(&bit_token_built)?;
        self.push(ASTType::BitToken(bit_token_built), context);
        Ok(())
    }

    /// Semantic action for production 110:
    ///
    /// ElseToken: 'else' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn else_token(
        &mut self,
        r#else: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#else = r#else.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let else_token_built = ElseTokenBuilder::default()
            .r#else(r#else)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.else_token(&else_token_built)?;
        self.push(ASTType::ElseToken(else_token_built), context);
        Ok(())
    }

    /// Semantic action for production 111:
    ///
    /// F32Token: 'f32' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn f32_token(
        &mut self,
        f32: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let f32 = f32.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let f32_token_built = F32TokenBuilder::default()
            .f32(f32)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.f32_token(&f32_token_built)?;
        self.push(ASTType::F32Token(f32_token_built), context);
        Ok(())
    }

    /// Semantic action for production 112:
    ///
    /// F64Token: 'f64' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn f64_token(
        &mut self,
        f64: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let f64 = f64.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let f64_token_built = F64TokenBuilder::default()
            .f64(f64)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.f64_token(&f64_token_built)?;
        self.push(ASTType::F64Token(f64_token_built), context);
        Ok(())
    }

    /// Semantic action for production 113:
    ///
    /// I32Token: 'i32' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn i32_token(
        &mut self,
        i32: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let i32 = i32.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let i32_token_built = I32TokenBuilder::default()
            .i32(i32)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.i32_token(&i32_token_built)?;
        self.push(ASTType::I32Token(i32_token_built), context);
        Ok(())
    }

    /// Semantic action for production 114:
    ///
    /// I64Token: 'i64' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn i64_token(
        &mut self,
        i64: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let i64 = i64.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let i64_token_built = I64TokenBuilder::default()
            .i64(i64)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.i64_token(&i64_token_built)?;
        self.push(ASTType::I64Token(i64_token_built), context);
        Ok(())
    }

    /// Semantic action for production 115:
    ///
    /// IfToken: 'if' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn if_token(
        &mut self,
        r#if: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#if = r#if.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let if_token_built = IfTokenBuilder::default()
            .r#if(r#if)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.if_token(&if_token_built)?;
        self.push(ASTType::IfToken(if_token_built), context);
        Ok(())
    }

    /// Semantic action for production 116:
    ///
    /// InoutToken: 'inout' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn inout_token(
        &mut self,
        inout: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inout = inout.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let inout_token_built = InoutTokenBuilder::default()
            .inout(inout)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.inout_token(&inout_token_built)?;
        self.push(ASTType::InoutToken(inout_token_built), context);
        Ok(())
    }

    /// Semantic action for production 117:
    ///
    /// InputToken: 'input' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn input_token(
        &mut self,
        input: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let input = input.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let input_token_built = InputTokenBuilder::default()
            .input(input)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.input_token(&input_token_built)?;
        self.push(ASTType::InputToken(input_token_built), context);
        Ok(())
    }

    /// Semantic action for production 118:
    ///
    /// InterfaceToken: 'interface' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn interface_token(
        &mut self,
        interface: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let interface = interface.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let interface_token_built = InterfaceTokenBuilder::default()
            .interface(interface)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.interface_token(&interface_token_built)?;
        self.push(ASTType::InterfaceToken(interface_token_built), context);
        Ok(())
    }

    /// Semantic action for production 119:
    ///
    /// LocalparamToken: 'localparam' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn localparam_token(
        &mut self,
        localparam: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let localparam = localparam.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let localparam_token_built = LocalparamTokenBuilder::default()
            .localparam(localparam)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .localparam_token(&localparam_token_built)?;
        self.push(ASTType::LocalparamToken(localparam_token_built), context);
        Ok(())
    }

    /// Semantic action for production 120:
    ///
    /// LogicToken: 'logic' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn logic_token(
        &mut self,
        logic: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logic = logic.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let logic_token_built = LogicTokenBuilder::default()
            .logic(logic)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.logic_token(&logic_token_built)?;
        self.push(ASTType::LogicToken(logic_token_built), context);
        Ok(())
    }

    /// Semantic action for production 121:
    ///
    /// ModportToken: 'modport' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn modport_token(
        &mut self,
        modport: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let modport = modport.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let modport_token_built = ModportTokenBuilder::default()
            .modport(modport)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.modport_token(&modport_token_built)?;
        self.push(ASTType::ModportToken(modport_token_built), context);
        Ok(())
    }

    /// Semantic action for production 122:
    ///
    /// ModuleToken: 'module' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn module_token(
        &mut self,
        module: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module = module.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let module_token_built = ModuleTokenBuilder::default()
            .module(module)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.module_token(&module_token_built)?;
        self.push(ASTType::ModuleToken(module_token_built), context);
        Ok(())
    }

    /// Semantic action for production 123:
    ///
    /// NegedgeToken: 'negedge' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn negedge_token(
        &mut self,
        negedge: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let negedge = negedge.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let negedge_token_built = NegedgeTokenBuilder::default()
            .negedge(negedge)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.negedge_token(&negedge_token_built)?;
        self.push(ASTType::NegedgeToken(negedge_token_built), context);
        Ok(())
    }

    /// Semantic action for production 124:
    ///
    /// OutputToken: 'output' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn output_token(
        &mut self,
        output: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let output = output.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let output_token_built = OutputTokenBuilder::default()
            .output(output)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.output_token(&output_token_built)?;
        self.push(ASTType::OutputToken(output_token_built), context);
        Ok(())
    }

    /// Semantic action for production 125:
    ///
    /// ParameterToken: 'parameter' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn parameter_token(
        &mut self,
        parameter: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let parameter = parameter.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let parameter_token_built = ParameterTokenBuilder::default()
            .parameter(parameter)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.parameter_token(&parameter_token_built)?;
        self.push(ASTType::ParameterToken(parameter_token_built), context);
        Ok(())
    }

    /// Semantic action for production 126:
    ///
    /// PosedgeToken: 'posedge' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn posedge_token(
        &mut self,
        posedge: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let posedge = posedge.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let posedge_token_built = PosedgeTokenBuilder::default()
            .posedge(posedge)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.posedge_token(&posedge_token_built)?;
        self.push(ASTType::PosedgeToken(posedge_token_built), context);
        Ok(())
    }

    /// Semantic action for production 127:
    ///
    /// U32Token: 'u32' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn u32_token(
        &mut self,
        u32: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let u32 = u32.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let u32_token_built = U32TokenBuilder::default()
            .u32(u32)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.u32_token(&u32_token_built)?;
        self.push(ASTType::U32Token(u32_token_built), context);
        Ok(())
    }

    /// Semantic action for production 128:
    ///
    /// U64Token: 'u64' : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn u64_token(
        &mut self,
        u64: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let u64 = u64.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let u64_token_built = U64TokenBuilder::default()
            .u64(u64)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.u64_token(&u64_token_built)?;
        self.push(ASTType::U64Token(u64_token_built), context);
        Ok(())
    }

    /// Semantic action for production 129:
    ///
    /// AlwaysComb: AlwaysCombToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn always_comb(
        &mut self,
        _always_comb_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let always_comb_token = pop_item!(self, always_comb_token, AlwaysCombToken, context);
        let always_comb_built = AlwaysCombBuilder::default()
            .always_comb_token((&always_comb_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.always_comb(&always_comb_built)?;
        self.push(ASTType::AlwaysComb(always_comb_built), context);
        Ok(())
    }

    /// Semantic action for production 130:
    ///
    /// AlwaysFf: AlwaysFfToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff(
        &mut self,
        _always_ff_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let always_ff_token = pop_item!(self, always_ff_token, AlwaysFfToken, context);
        let always_ff_built = AlwaysFfBuilder::default()
            .always_ff_token((&always_ff_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.always_ff(&always_ff_built)?;
        self.push(ASTType::AlwaysFf(always_ff_built), context);
        Ok(())
    }

    /// Semantic action for production 131:
    ///
    /// Assign: AssignToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn assign(
        &mut self,
        _assign_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let assign_token = pop_item!(self, assign_token, AssignToken, context);
        let assign_built = AssignBuilder::default()
            .assign_token((&assign_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.assign(&assign_built)?;
        self.push(ASTType::Assign(assign_built), context);
        Ok(())
    }

    /// Semantic action for production 132:
    ///
    /// Bit: BitToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn bit(
        &mut self,
        _bit_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bit_token = pop_item!(self, bit_token, BitToken, context);
        let bit_built = BitBuilder::default()
            .bit_token((&bit_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.bit(&bit_built)?;
        self.push(ASTType::Bit(bit_built), context);
        Ok(())
    }

    /// Semantic action for production 133:
    ///
    /// Else: ElseToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn r#else(
        &mut self,
        _else_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let else_token = pop_item!(self, else_token, ElseToken, context);
        let r#else_built = ElseBuilder::default()
            .else_token((&else_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.r#else(&r#else_built)?;
        self.push(ASTType::Else(r#else_built), context);
        Ok(())
    }

    /// Semantic action for production 134:
    ///
    /// F32: F32Token : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn f32(
        &mut self,
        _f32_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let f32_token = pop_item!(self, f32_token, F32Token, context);
        let f32_built = F32Builder::default()
            .f32_token((&f32_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.f32(&f32_built)?;
        self.push(ASTType::F32(f32_built), context);
        Ok(())
    }

    /// Semantic action for production 135:
    ///
    /// F64: F64Token : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn f64(
        &mut self,
        _f64_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let f64_token = pop_item!(self, f64_token, F64Token, context);
        let f64_built = F64Builder::default()
            .f64_token((&f64_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.f64(&f64_built)?;
        self.push(ASTType::F64(f64_built), context);
        Ok(())
    }

    /// Semantic action for production 136:
    ///
    /// I32: I32Token : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn i32(
        &mut self,
        _i32_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let i32_token = pop_item!(self, i32_token, I32Token, context);
        let i32_built = I32Builder::default()
            .i32_token((&i32_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.i32(&i32_built)?;
        self.push(ASTType::I32(i32_built), context);
        Ok(())
    }

    /// Semantic action for production 137:
    ///
    /// I64: I64Token : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn i64(
        &mut self,
        _i64_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let i64_token = pop_item!(self, i64_token, I64Token, context);
        let i64_built = I64Builder::default()
            .i64_token((&i64_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.i64(&i64_built)?;
        self.push(ASTType::I64(i64_built), context);
        Ok(())
    }

    /// Semantic action for production 138:
    ///
    /// If: IfToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn r#if(
        &mut self,
        _if_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_token = pop_item!(self, if_token, IfToken, context);
        let r#if_built = IfBuilder::default()
            .if_token((&if_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.r#if(&r#if_built)?;
        self.push(ASTType::If(r#if_built), context);
        Ok(())
    }

    /// Semantic action for production 139:
    ///
    /// Inout: InoutToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn inout(
        &mut self,
        _inout_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inout_token = pop_item!(self, inout_token, InoutToken, context);
        let inout_built = InoutBuilder::default()
            .inout_token((&inout_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.inout(&inout_built)?;
        self.push(ASTType::Inout(inout_built), context);
        Ok(())
    }

    /// Semantic action for production 140:
    ///
    /// Input: InputToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn input(
        &mut self,
        _input_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let input_token = pop_item!(self, input_token, InputToken, context);
        let input_built = InputBuilder::default()
            .input_token((&input_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.input(&input_built)?;
        self.push(ASTType::Input(input_built), context);
        Ok(())
    }

    /// Semantic action for production 141:
    ///
    /// Interface: InterfaceToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn interface(
        &mut self,
        _interface_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let interface_token = pop_item!(self, interface_token, InterfaceToken, context);
        let interface_built = InterfaceBuilder::default()
            .interface_token((&interface_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.interface(&interface_built)?;
        self.push(ASTType::Interface(interface_built), context);
        Ok(())
    }

    /// Semantic action for production 142:
    ///
    /// Localparam: LocalparamToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn localparam(
        &mut self,
        _localparam_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let localparam_token = pop_item!(self, localparam_token, LocalparamToken, context);
        let localparam_built = LocalparamBuilder::default()
            .localparam_token((&localparam_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.localparam(&localparam_built)?;
        self.push(ASTType::Localparam(localparam_built), context);
        Ok(())
    }

    /// Semantic action for production 143:
    ///
    /// Logic: LogicToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn logic(
        &mut self,
        _logic_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logic_token = pop_item!(self, logic_token, LogicToken, context);
        let logic_built = LogicBuilder::default()
            .logic_token((&logic_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.logic(&logic_built)?;
        self.push(ASTType::Logic(logic_built), context);
        Ok(())
    }

    /// Semantic action for production 144:
    ///
    /// Modport: ModportToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn modport(
        &mut self,
        _modport_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let modport_token = pop_item!(self, modport_token, ModportToken, context);
        let modport_built = ModportBuilder::default()
            .modport_token((&modport_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.modport(&modport_built)?;
        self.push(ASTType::Modport(modport_built), context);
        Ok(())
    }

    /// Semantic action for production 145:
    ///
    /// Module: ModuleToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn module(
        &mut self,
        _module_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module_token = pop_item!(self, module_token, ModuleToken, context);
        let module_built = ModuleBuilder::default()
            .module_token((&module_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.module(&module_built)?;
        self.push(ASTType::Module(module_built), context);
        Ok(())
    }

    /// Semantic action for production 146:
    ///
    /// Negedge: NegedgeToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn negedge(
        &mut self,
        _negedge_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let negedge_token = pop_item!(self, negedge_token, NegedgeToken, context);
        let negedge_built = NegedgeBuilder::default()
            .negedge_token((&negedge_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.negedge(&negedge_built)?;
        self.push(ASTType::Negedge(negedge_built), context);
        Ok(())
    }

    /// Semantic action for production 147:
    ///
    /// Output: OutputToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn output(
        &mut self,
        _output_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let output_token = pop_item!(self, output_token, OutputToken, context);
        let output_built = OutputBuilder::default()
            .output_token((&output_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.output(&output_built)?;
        self.push(ASTType::Output(output_built), context);
        Ok(())
    }

    /// Semantic action for production 148:
    ///
    /// Parameter: ParameterToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn parameter(
        &mut self,
        _parameter_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let parameter_token = pop_item!(self, parameter_token, ParameterToken, context);
        let parameter_built = ParameterBuilder::default()
            .parameter_token((&parameter_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.parameter(&parameter_built)?;
        self.push(ASTType::Parameter(parameter_built), context);
        Ok(())
    }

    /// Semantic action for production 149:
    ///
    /// Posedge: PosedgeToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn posedge(
        &mut self,
        _posedge_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let posedge_token = pop_item!(self, posedge_token, PosedgeToken, context);
        let posedge_built = PosedgeBuilder::default()
            .posedge_token((&posedge_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.posedge(&posedge_built)?;
        self.push(ASTType::Posedge(posedge_built), context);
        Ok(())
    }

    /// Semantic action for production 150:
    ///
    /// U32: U32Token : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn u32(
        &mut self,
        _u32_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let u32_token = pop_item!(self, u32_token, U32Token, context);
        let u32_built = U32Builder::default()
            .u32_token((&u32_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.u32(&u32_built)?;
        self.push(ASTType::U32(u32_built), context);
        Ok(())
    }

    /// Semantic action for production 151:
    ///
    /// U64: U64Token : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn u64(
        &mut self,
        _u64_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let u64_token = pop_item!(self, u64_token, U64Token, context);
        let u64_built = U64Builder::default()
            .u64_token((&u64_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.u64(&u64_built)?;
        self.push(ASTType::U64(u64_built), context);
        Ok(())
    }

    /// Semantic action for production 152:
    ///
    /// IdentifierToken: /[a-zA-Z_][0-9a-zA-Z_]*/ : OwnedToken Comments;
    ///
    #[parol_runtime::function_name::named]
    fn identifier_token(
        &mut self,
        l_bracket_a_minus_z_a_minus_z_underscore_r_bracket_l_bracket0_minus9a_minus_z_a_minus_z_underscore_r_bracket_star: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_bracket_a_minus_z_a_minus_z_underscore_r_bracket_l_bracket0_minus9a_minus_z_a_minus_z_underscore_r_bracket_star = l_bracket_a_minus_z_a_minus_z_underscore_r_bracket_l_bracket0_minus9a_minus_z_a_minus_z_underscore_r_bracket_star.token(parse_tree)?.try_into().into_diagnostic()?;
        let comments = pop_item!(self, comments, Comments, context);
        let identifier_token_built = IdentifierTokenBuilder::default()
            .l_bracket_a_minus_z_a_minus_z_underscore_r_bracket_l_bracket0_minus9a_minus_z_a_minus_z_underscore_r_bracket_star(l_bracket_a_minus_z_a_minus_z_underscore_r_bracket_l_bracket0_minus9a_minus_z_a_minus_z_underscore_r_bracket_star)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .identifier_token(&identifier_token_built)?;
        self.push(ASTType::IdentifierToken(identifier_token_built), context);
        Ok(())
    }

    /// Semantic action for production 153:
    ///
    /// Identifier: IdentifierToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn identifier(
        &mut self,
        _identifier_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let identifier_token = pop_item!(self, identifier_token, IdentifierToken, context);
        let identifier_built = IdentifierBuilder::default()
            .identifier_token((&identifier_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.identifier(&identifier_built)?;
        self.push(ASTType::Identifier(identifier_built), context);
        Ok(())
    }

    /// Semantic action for production 154:
    ///
    /// Veryl: Start VerylList /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn veryl(
        &mut self,
        _start: &ParseTreeStackEntry<'t>,
        _veryl_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let veryl_list = pop_and_reverse_item!(self, veryl_list, VerylList, context);
        let start = pop_item!(self, start, Start, context);
        let veryl_built = VerylBuilder::default()
            .start(Box::new(start))
            .veryl_list(veryl_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.veryl(&veryl_built)?;
        self.push(ASTType::Veryl(veryl_built), context);
        Ok(())
    }

    /// Semantic action for production 155:
    ///
    /// VerylList /* Vec<T>::Push */: Description VerylList;
    ///
    #[parol_runtime::function_name::named]
    fn veryl_list_0(
        &mut self,
        _description: &ParseTreeStackEntry<'t>,
        _veryl_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut veryl_list = pop_item!(self, veryl_list, VerylList, context);
        let description = pop_item!(self, description, Description, context);
        let veryl_list_0_built = VerylListBuilder::default()
            .description(Box::new(description))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        veryl_list.push(veryl_list_0_built);
        self.push(ASTType::VerylList(veryl_list), context);
        Ok(())
    }

    /// Semantic action for production 156:
    ///
    /// VerylList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn veryl_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let veryl_list_1_built = Vec::new();
        self.push(ASTType::VerylList(veryl_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 157:
    ///
    /// Description: ModuleDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn description_0(
        &mut self,
        _module_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module_declaration = pop_item!(self, module_declaration, ModuleDeclaration, context);
        let description_0_built = Description0Builder::default()
            .module_declaration(Box::new(module_declaration))
            .build()
            .into_diagnostic()?;
        let description_0_built = Description::Description0(description_0_built);
        // Calling user action here
        self.user_grammar.description(&description_0_built)?;
        self.push(ASTType::Description(description_0_built), context);
        Ok(())
    }

    /// Semantic action for production 158:
    ///
    /// Description: InterfaceDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn description_1(
        &mut self,
        _interface_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let interface_declaration =
            pop_item!(self, interface_declaration, InterfaceDeclaration, context);
        let description_1_built = Description1Builder::default()
            .interface_declaration(Box::new(interface_declaration))
            .build()
            .into_diagnostic()?;
        let description_1_built = Description::Description1(description_1_built);
        // Calling user action here
        self.user_grammar.description(&description_1_built)?;
        self.push(ASTType::Description(description_1_built), context);
        Ok(())
    }

    /// Semantic action for production 159:
    ///
    /// Number: IntegralNumber;
    ///
    #[parol_runtime::function_name::named]
    fn number_0(
        &mut self,
        _integral_number: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let integral_number = pop_item!(self, integral_number, IntegralNumber, context);
        let number_0_built = Number0Builder::default()
            .integral_number(Box::new(integral_number))
            .build()
            .into_diagnostic()?;
        let number_0_built = Number::Number0(number_0_built);
        // Calling user action here
        self.user_grammar.number(&number_0_built)?;
        self.push(ASTType::Number(number_0_built), context);
        Ok(())
    }

    /// Semantic action for production 160:
    ///
    /// Number: RealNumber;
    ///
    #[parol_runtime::function_name::named]
    fn number_1(
        &mut self,
        _real_number: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let real_number = pop_item!(self, real_number, RealNumber, context);
        let number_1_built = Number1Builder::default()
            .real_number(Box::new(real_number))
            .build()
            .into_diagnostic()?;
        let number_1_built = Number::Number1(number_1_built);
        // Calling user action here
        self.user_grammar.number(&number_1_built)?;
        self.push(ASTType::Number(number_1_built), context);
        Ok(())
    }

    /// Semantic action for production 161:
    ///
    /// IntegralNumber: BasedBinary;
    ///
    #[parol_runtime::function_name::named]
    fn integral_number_0(
        &mut self,
        _based_binary: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let based_binary = pop_item!(self, based_binary, BasedBinary, context);
        let integral_number_0_built = IntegralNumber0Builder::default()
            .based_binary(Box::new(based_binary))
            .build()
            .into_diagnostic()?;
        let integral_number_0_built = IntegralNumber::IntegralNumber0(integral_number_0_built);
        // Calling user action here
        self.user_grammar
            .integral_number(&integral_number_0_built)?;
        self.push(ASTType::IntegralNumber(integral_number_0_built), context);
        Ok(())
    }

    /// Semantic action for production 162:
    ///
    /// IntegralNumber: BasedOctal;
    ///
    #[parol_runtime::function_name::named]
    fn integral_number_1(
        &mut self,
        _based_octal: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let based_octal = pop_item!(self, based_octal, BasedOctal, context);
        let integral_number_1_built = IntegralNumber1Builder::default()
            .based_octal(Box::new(based_octal))
            .build()
            .into_diagnostic()?;
        let integral_number_1_built = IntegralNumber::IntegralNumber1(integral_number_1_built);
        // Calling user action here
        self.user_grammar
            .integral_number(&integral_number_1_built)?;
        self.push(ASTType::IntegralNumber(integral_number_1_built), context);
        Ok(())
    }

    /// Semantic action for production 163:
    ///
    /// IntegralNumber: BasedDecimal;
    ///
    #[parol_runtime::function_name::named]
    fn integral_number_2(
        &mut self,
        _based_decimal: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let based_decimal = pop_item!(self, based_decimal, BasedDecimal, context);
        let integral_number_2_built = IntegralNumber2Builder::default()
            .based_decimal(Box::new(based_decimal))
            .build()
            .into_diagnostic()?;
        let integral_number_2_built = IntegralNumber::IntegralNumber2(integral_number_2_built);
        // Calling user action here
        self.user_grammar
            .integral_number(&integral_number_2_built)?;
        self.push(ASTType::IntegralNumber(integral_number_2_built), context);
        Ok(())
    }

    /// Semantic action for production 164:
    ///
    /// IntegralNumber: BasedHex;
    ///
    #[parol_runtime::function_name::named]
    fn integral_number_3(
        &mut self,
        _based_hex: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let based_hex = pop_item!(self, based_hex, BasedHex, context);
        let integral_number_3_built = IntegralNumber3Builder::default()
            .based_hex(Box::new(based_hex))
            .build()
            .into_diagnostic()?;
        let integral_number_3_built = IntegralNumber::IntegralNumber3(integral_number_3_built);
        // Calling user action here
        self.user_grammar
            .integral_number(&integral_number_3_built)?;
        self.push(ASTType::IntegralNumber(integral_number_3_built), context);
        Ok(())
    }

    /// Semantic action for production 165:
    ///
    /// IntegralNumber: BaseLess;
    ///
    #[parol_runtime::function_name::named]
    fn integral_number_4(
        &mut self,
        _base_less: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let base_less = pop_item!(self, base_less, BaseLess, context);
        let integral_number_4_built = IntegralNumber4Builder::default()
            .base_less(Box::new(base_less))
            .build()
            .into_diagnostic()?;
        let integral_number_4_built = IntegralNumber::IntegralNumber4(integral_number_4_built);
        // Calling user action here
        self.user_grammar
            .integral_number(&integral_number_4_built)?;
        self.push(ASTType::IntegralNumber(integral_number_4_built), context);
        Ok(())
    }

    /// Semantic action for production 166:
    ///
    /// IntegralNumber: AllBit;
    ///
    #[parol_runtime::function_name::named]
    fn integral_number_5(
        &mut self,
        _all_bit: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let all_bit = pop_item!(self, all_bit, AllBit, context);
        let integral_number_5_built = IntegralNumber5Builder::default()
            .all_bit(Box::new(all_bit))
            .build()
            .into_diagnostic()?;
        let integral_number_5_built = IntegralNumber::IntegralNumber5(integral_number_5_built);
        // Calling user action here
        self.user_grammar
            .integral_number(&integral_number_5_built)?;
        self.push(ASTType::IntegralNumber(integral_number_5_built), context);
        Ok(())
    }

    /// Semantic action for production 167:
    ///
    /// RealNumber: FixedPoint;
    ///
    #[parol_runtime::function_name::named]
    fn real_number_0(
        &mut self,
        _fixed_point: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let fixed_point = pop_item!(self, fixed_point, FixedPoint, context);
        let real_number_0_built = RealNumber0Builder::default()
            .fixed_point(Box::new(fixed_point))
            .build()
            .into_diagnostic()?;
        let real_number_0_built = RealNumber::RealNumber0(real_number_0_built);
        // Calling user action here
        self.user_grammar.real_number(&real_number_0_built)?;
        self.push(ASTType::RealNumber(real_number_0_built), context);
        Ok(())
    }

    /// Semantic action for production 168:
    ///
    /// RealNumber: Exponent;
    ///
    #[parol_runtime::function_name::named]
    fn real_number_1(
        &mut self,
        _exponent: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let exponent = pop_item!(self, exponent, Exponent, context);
        let real_number_1_built = RealNumber1Builder::default()
            .exponent(Box::new(exponent))
            .build()
            .into_diagnostic()?;
        let real_number_1_built = RealNumber::RealNumber1(real_number_1_built);
        // Calling user action here
        self.user_grammar.real_number(&real_number_1_built)?;
        self.push(ASTType::RealNumber(real_number_1_built), context);
        Ok(())
    }

    /// Semantic action for production 169:
    ///
    /// OperatorPrecedence01: OrOr;
    ///
    #[parol_runtime::function_name::named]
    fn operator_precedence01(
        &mut self,
        _or_or: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let or_or = pop_item!(self, or_or, OrOr, context);
        let operator_precedence01_built = OperatorPrecedence01Builder::default()
            .or_or(Box::new(or_or))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .operator_precedence01(&operator_precedence01_built)?;
        self.push(
            ASTType::OperatorPrecedence01(operator_precedence01_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 170:
    ///
    /// OperatorPrecedence02: AmpAmp;
    ///
    #[parol_runtime::function_name::named]
    fn operator_precedence02(
        &mut self,
        _amp_amp: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let amp_amp = pop_item!(self, amp_amp, AmpAmp, context);
        let operator_precedence02_built = OperatorPrecedence02Builder::default()
            .amp_amp(Box::new(amp_amp))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .operator_precedence02(&operator_precedence02_built)?;
        self.push(
            ASTType::OperatorPrecedence02(operator_precedence02_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 171:
    ///
    /// OperatorPrecedence03: Or;
    ///
    #[parol_runtime::function_name::named]
    fn operator_precedence03(
        &mut self,
        _or: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let or = pop_item!(self, or, Or, context);
        let operator_precedence03_built = OperatorPrecedence03Builder::default()
            .or(Box::new(or))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .operator_precedence03(&operator_precedence03_built)?;
        self.push(
            ASTType::OperatorPrecedence03(operator_precedence03_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 172:
    ///
    /// OperatorPrecedence04: Circumflex;
    ///
    #[parol_runtime::function_name::named]
    fn operator_precedence04_0(
        &mut self,
        _circumflex: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let circumflex = pop_item!(self, circumflex, Circumflex, context);
        let operator_precedence04_0_built = OperatorPrecedence4Builder::default()
            .circumflex(Box::new(circumflex))
            .build()
            .into_diagnostic()?;
        let operator_precedence04_0_built =
            OperatorPrecedence04::OperatorPrecedence040(operator_precedence04_0_built);
        // Calling user action here
        self.user_grammar
            .operator_precedence04(&operator_precedence04_0_built)?;
        self.push(
            ASTType::OperatorPrecedence04(operator_precedence04_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 173:
    ///
    /// OperatorPrecedence04: TildeCircumflex;
    ///
    #[parol_runtime::function_name::named]
    fn operator_precedence04_1(
        &mut self,
        _tilde_circumflex: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let tilde_circumflex = pop_item!(self, tilde_circumflex, TildeCircumflex, context);
        let operator_precedence04_1_built = OperatorPrecedence5Builder::default()
            .tilde_circumflex(Box::new(tilde_circumflex))
            .build()
            .into_diagnostic()?;
        let operator_precedence04_1_built =
            OperatorPrecedence04::OperatorPrecedence041(operator_precedence04_1_built);
        // Calling user action here
        self.user_grammar
            .operator_precedence04(&operator_precedence04_1_built)?;
        self.push(
            ASTType::OperatorPrecedence04(operator_precedence04_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 174:
    ///
    /// OperatorPrecedence04: CircumflexTilde;
    ///
    #[parol_runtime::function_name::named]
    fn operator_precedence04_2(
        &mut self,
        _circumflex_tilde: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let circumflex_tilde = pop_item!(self, circumflex_tilde, CircumflexTilde, context);
        let operator_precedence04_2_built = OperatorPrecedence6Builder::default()
            .circumflex_tilde(Box::new(circumflex_tilde))
            .build()
            .into_diagnostic()?;
        let operator_precedence04_2_built =
            OperatorPrecedence04::OperatorPrecedence042(operator_precedence04_2_built);
        // Calling user action here
        self.user_grammar
            .operator_precedence04(&operator_precedence04_2_built)?;
        self.push(
            ASTType::OperatorPrecedence04(operator_precedence04_2_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 175:
    ///
    /// OperatorPrecedence05: Amp;
    ///
    #[parol_runtime::function_name::named]
    fn operator_precedence05(
        &mut self,
        _amp: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let amp = pop_item!(self, amp, Amp, context);
        let operator_precedence05_built = OperatorPrecedence05Builder::default()
            .amp(Box::new(amp))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .operator_precedence05(&operator_precedence05_built)?;
        self.push(
            ASTType::OperatorPrecedence05(operator_precedence05_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 176:
    ///
    /// OperatorPrecedence06: EquEqu;
    ///
    #[parol_runtime::function_name::named]
    fn operator_precedence06_0(
        &mut self,
        _equ_equ: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let equ_equ = pop_item!(self, equ_equ, EquEqu, context);
        let operator_precedence06_0_built = OperatorPrecedence8Builder::default()
            .equ_equ(Box::new(equ_equ))
            .build()
            .into_diagnostic()?;
        let operator_precedence06_0_built =
            OperatorPrecedence06::OperatorPrecedence060(operator_precedence06_0_built);
        // Calling user action here
        self.user_grammar
            .operator_precedence06(&operator_precedence06_0_built)?;
        self.push(
            ASTType::OperatorPrecedence06(operator_precedence06_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 177:
    ///
    /// OperatorPrecedence06: BangEqu;
    ///
    #[parol_runtime::function_name::named]
    fn operator_precedence06_1(
        &mut self,
        _bang_equ: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bang_equ = pop_item!(self, bang_equ, BangEqu, context);
        let operator_precedence06_1_built = OperatorPrecedence9Builder::default()
            .bang_equ(Box::new(bang_equ))
            .build()
            .into_diagnostic()?;
        let operator_precedence06_1_built =
            OperatorPrecedence06::OperatorPrecedence061(operator_precedence06_1_built);
        // Calling user action here
        self.user_grammar
            .operator_precedence06(&operator_precedence06_1_built)?;
        self.push(
            ASTType::OperatorPrecedence06(operator_precedence06_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 178:
    ///
    /// OperatorPrecedence06: EquEquEqu;
    ///
    #[parol_runtime::function_name::named]
    fn operator_precedence06_2(
        &mut self,
        _equ_equ_equ: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let equ_equ_equ = pop_item!(self, equ_equ_equ, EquEquEqu, context);
        let operator_precedence06_2_built = OperatorPrecedence13Builder::default()
            .equ_equ_equ(Box::new(equ_equ_equ))
            .build()
            .into_diagnostic()?;
        let operator_precedence06_2_built =
            OperatorPrecedence06::OperatorPrecedence062(operator_precedence06_2_built);
        // Calling user action here
        self.user_grammar
            .operator_precedence06(&operator_precedence06_2_built)?;
        self.push(
            ASTType::OperatorPrecedence06(operator_precedence06_2_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 179:
    ///
    /// OperatorPrecedence06: BangEquEqu;
    ///
    #[parol_runtime::function_name::named]
    fn operator_precedence06_3(
        &mut self,
        _bang_equ_equ: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bang_equ_equ = pop_item!(self, bang_equ_equ, BangEquEqu, context);
        let operator_precedence06_3_built = OperatorPrecedence14Builder::default()
            .bang_equ_equ(Box::new(bang_equ_equ))
            .build()
            .into_diagnostic()?;
        let operator_precedence06_3_built =
            OperatorPrecedence06::OperatorPrecedence063(operator_precedence06_3_built);
        // Calling user action here
        self.user_grammar
            .operator_precedence06(&operator_precedence06_3_built)?;
        self.push(
            ASTType::OperatorPrecedence06(operator_precedence06_3_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 180:
    ///
    /// OperatorPrecedence06: EquEquQuest;
    ///
    #[parol_runtime::function_name::named]
    fn operator_precedence06_4(
        &mut self,
        _equ_equ_quest: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let equ_equ_quest = pop_item!(self, equ_equ_quest, EquEquQuest, context);
        let operator_precedence06_4_built = OperatorPrecedence15Builder::default()
            .equ_equ_quest(Box::new(equ_equ_quest))
            .build()
            .into_diagnostic()?;
        let operator_precedence06_4_built =
            OperatorPrecedence06::OperatorPrecedence064(operator_precedence06_4_built);
        // Calling user action here
        self.user_grammar
            .operator_precedence06(&operator_precedence06_4_built)?;
        self.push(
            ASTType::OperatorPrecedence06(operator_precedence06_4_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 181:
    ///
    /// OperatorPrecedence06: BangEquQuest;
    ///
    #[parol_runtime::function_name::named]
    fn operator_precedence06_5(
        &mut self,
        _bang_equ_quest: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bang_equ_quest = pop_item!(self, bang_equ_quest, BangEquQuest, context);
        let operator_precedence06_5_built = OperatorPrecedence16Builder::default()
            .bang_equ_quest(Box::new(bang_equ_quest))
            .build()
            .into_diagnostic()?;
        let operator_precedence06_5_built =
            OperatorPrecedence06::OperatorPrecedence065(operator_precedence06_5_built);
        // Calling user action here
        self.user_grammar
            .operator_precedence06(&operator_precedence06_5_built)?;
        self.push(
            ASTType::OperatorPrecedence06(operator_precedence06_5_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 182:
    ///
    /// OperatorPrecedence07: LT;
    ///
    #[parol_runtime::function_name::named]
    fn operator_precedence07_0(
        &mut self,
        _l_t: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_t = pop_item!(self, l_t, LT, context);
        let operator_precedence07_0_built = OperatorPrecedence17Builder::default()
            .l_t(Box::new(l_t))
            .build()
            .into_diagnostic()?;
        let operator_precedence07_0_built =
            OperatorPrecedence07::OperatorPrecedence070(operator_precedence07_0_built);
        // Calling user action here
        self.user_grammar
            .operator_precedence07(&operator_precedence07_0_built)?;
        self.push(
            ASTType::OperatorPrecedence07(operator_precedence07_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 183:
    ///
    /// OperatorPrecedence07: LTEqu;
    ///
    #[parol_runtime::function_name::named]
    fn operator_precedence07_1(
        &mut self,
        _l_t_equ: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_t_equ = pop_item!(self, l_t_equ, LTEqu, context);
        let operator_precedence07_1_built = OperatorPrecedence18Builder::default()
            .l_t_equ(Box::new(l_t_equ))
            .build()
            .into_diagnostic()?;
        let operator_precedence07_1_built =
            OperatorPrecedence07::OperatorPrecedence071(operator_precedence07_1_built);
        // Calling user action here
        self.user_grammar
            .operator_precedence07(&operator_precedence07_1_built)?;
        self.push(
            ASTType::OperatorPrecedence07(operator_precedence07_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 184:
    ///
    /// OperatorPrecedence07: GT;
    ///
    #[parol_runtime::function_name::named]
    fn operator_precedence07_2(
        &mut self,
        _g_t: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let g_t = pop_item!(self, g_t, GT, context);
        let operator_precedence07_2_built = OperatorPrecedence19Builder::default()
            .g_t(Box::new(g_t))
            .build()
            .into_diagnostic()?;
        let operator_precedence07_2_built =
            OperatorPrecedence07::OperatorPrecedence072(operator_precedence07_2_built);
        // Calling user action here
        self.user_grammar
            .operator_precedence07(&operator_precedence07_2_built)?;
        self.push(
            ASTType::OperatorPrecedence07(operator_precedence07_2_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 185:
    ///
    /// OperatorPrecedence07: GTEqu;
    ///
    #[parol_runtime::function_name::named]
    fn operator_precedence07_3(
        &mut self,
        _g_t_equ: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let g_t_equ = pop_item!(self, g_t_equ, GTEqu, context);
        let operator_precedence07_3_built = OperatorPrecedence20Builder::default()
            .g_t_equ(Box::new(g_t_equ))
            .build()
            .into_diagnostic()?;
        let operator_precedence07_3_built =
            OperatorPrecedence07::OperatorPrecedence073(operator_precedence07_3_built);
        // Calling user action here
        self.user_grammar
            .operator_precedence07(&operator_precedence07_3_built)?;
        self.push(
            ASTType::OperatorPrecedence07(operator_precedence07_3_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 186:
    ///
    /// OperatorPrecedence08: LTLT;
    ///
    #[parol_runtime::function_name::named]
    fn operator_precedence08_0(
        &mut self,
        _l_t_l_t: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_t_l_t = pop_item!(self, l_t_l_t, LTLT, context);
        let operator_precedence08_0_built = OperatorPrecedence21Builder::default()
            .l_t_l_t(Box::new(l_t_l_t))
            .build()
            .into_diagnostic()?;
        let operator_precedence08_0_built =
            OperatorPrecedence08::OperatorPrecedence080(operator_precedence08_0_built);
        // Calling user action here
        self.user_grammar
            .operator_precedence08(&operator_precedence08_0_built)?;
        self.push(
            ASTType::OperatorPrecedence08(operator_precedence08_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 187:
    ///
    /// OperatorPrecedence08: GTGT;
    ///
    #[parol_runtime::function_name::named]
    fn operator_precedence08_1(
        &mut self,
        _g_t_g_t: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let g_t_g_t = pop_item!(self, g_t_g_t, GTGT, context);
        let operator_precedence08_1_built = OperatorPrecedence22Builder::default()
            .g_t_g_t(Box::new(g_t_g_t))
            .build()
            .into_diagnostic()?;
        let operator_precedence08_1_built =
            OperatorPrecedence08::OperatorPrecedence081(operator_precedence08_1_built);
        // Calling user action here
        self.user_grammar
            .operator_precedence08(&operator_precedence08_1_built)?;
        self.push(
            ASTType::OperatorPrecedence08(operator_precedence08_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 188:
    ///
    /// OperatorPrecedence08: LTLTLT;
    ///
    #[parol_runtime::function_name::named]
    fn operator_precedence08_2(
        &mut self,
        _l_t_l_t_l_t: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_t_l_t_l_t = pop_item!(self, l_t_l_t_l_t, LTLTLT, context);
        let operator_precedence08_2_built = OperatorPrecedence23Builder::default()
            .l_t_l_t_l_t(Box::new(l_t_l_t_l_t))
            .build()
            .into_diagnostic()?;
        let operator_precedence08_2_built =
            OperatorPrecedence08::OperatorPrecedence082(operator_precedence08_2_built);
        // Calling user action here
        self.user_grammar
            .operator_precedence08(&operator_precedence08_2_built)?;
        self.push(
            ASTType::OperatorPrecedence08(operator_precedence08_2_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 189:
    ///
    /// OperatorPrecedence08: GTGTGT;
    ///
    #[parol_runtime::function_name::named]
    fn operator_precedence08_3(
        &mut self,
        _g_t_g_t_g_t: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let g_t_g_t_g_t = pop_item!(self, g_t_g_t_g_t, GTGTGT, context);
        let operator_precedence08_3_built = OperatorPrecedence24Builder::default()
            .g_t_g_t_g_t(Box::new(g_t_g_t_g_t))
            .build()
            .into_diagnostic()?;
        let operator_precedence08_3_built =
            OperatorPrecedence08::OperatorPrecedence083(operator_precedence08_3_built);
        // Calling user action here
        self.user_grammar
            .operator_precedence08(&operator_precedence08_3_built)?;
        self.push(
            ASTType::OperatorPrecedence08(operator_precedence08_3_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 190:
    ///
    /// OperatorPrecedence09: Plus;
    ///
    #[parol_runtime::function_name::named]
    fn operator_precedence09_0(
        &mut self,
        _plus: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let plus = pop_item!(self, plus, Plus, context);
        let operator_precedence09_0_built = OperatorPrecedence25Builder::default()
            .plus(Box::new(plus))
            .build()
            .into_diagnostic()?;
        let operator_precedence09_0_built =
            OperatorPrecedence09::OperatorPrecedence090(operator_precedence09_0_built);
        // Calling user action here
        self.user_grammar
            .operator_precedence09(&operator_precedence09_0_built)?;
        self.push(
            ASTType::OperatorPrecedence09(operator_precedence09_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 191:
    ///
    /// OperatorPrecedence09: Minus;
    ///
    #[parol_runtime::function_name::named]
    fn operator_precedence09_1(
        &mut self,
        _minus: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let minus = pop_item!(self, minus, Minus, context);
        let operator_precedence09_1_built = OperatorPrecedence26Builder::default()
            .minus(Box::new(minus))
            .build()
            .into_diagnostic()?;
        let operator_precedence09_1_built =
            OperatorPrecedence09::OperatorPrecedence091(operator_precedence09_1_built);
        // Calling user action here
        self.user_grammar
            .operator_precedence09(&operator_precedence09_1_built)?;
        self.push(
            ASTType::OperatorPrecedence09(operator_precedence09_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 192:
    ///
    /// OperatorPrecedence10: Star;
    ///
    #[parol_runtime::function_name::named]
    fn operator_precedence10_0(
        &mut self,
        _star: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let star = pop_item!(self, star, Star, context);
        let operator_precedence10_0_built = OperatorPrecedence27Builder::default()
            .star(Box::new(star))
            .build()
            .into_diagnostic()?;
        let operator_precedence10_0_built =
            OperatorPrecedence10::OperatorPrecedence100(operator_precedence10_0_built);
        // Calling user action here
        self.user_grammar
            .operator_precedence10(&operator_precedence10_0_built)?;
        self.push(
            ASTType::OperatorPrecedence10(operator_precedence10_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 193:
    ///
    /// OperatorPrecedence10: Slash;
    ///
    #[parol_runtime::function_name::named]
    fn operator_precedence10_1(
        &mut self,
        _slash: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let slash = pop_item!(self, slash, Slash, context);
        let operator_precedence10_1_built = OperatorPrecedence28Builder::default()
            .slash(Box::new(slash))
            .build()
            .into_diagnostic()?;
        let operator_precedence10_1_built =
            OperatorPrecedence10::OperatorPrecedence101(operator_precedence10_1_built);
        // Calling user action here
        self.user_grammar
            .operator_precedence10(&operator_precedence10_1_built)?;
        self.push(
            ASTType::OperatorPrecedence10(operator_precedence10_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 194:
    ///
    /// OperatorPrecedence10: Percent;
    ///
    #[parol_runtime::function_name::named]
    fn operator_precedence10_2(
        &mut self,
        _percent: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let percent = pop_item!(self, percent, Percent, context);
        let operator_precedence10_2_built = OperatorPrecedence29Builder::default()
            .percent(Box::new(percent))
            .build()
            .into_diagnostic()?;
        let operator_precedence10_2_built =
            OperatorPrecedence10::OperatorPrecedence102(operator_precedence10_2_built);
        // Calling user action here
        self.user_grammar
            .operator_precedence10(&operator_precedence10_2_built)?;
        self.push(
            ASTType::OperatorPrecedence10(operator_precedence10_2_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 195:
    ///
    /// OperatorPrecedence11: StarStar;
    ///
    #[parol_runtime::function_name::named]
    fn operator_precedence11(
        &mut self,
        _star_star: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let star_star = pop_item!(self, star_star, StarStar, context);
        let operator_precedence11_built = OperatorPrecedence11Builder::default()
            .star_star(Box::new(star_star))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .operator_precedence11(&operator_precedence11_built)?;
        self.push(
            ASTType::OperatorPrecedence11(operator_precedence11_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 196:
    ///
    /// OperatorPrecedence12: Plus;
    ///
    #[parol_runtime::function_name::named]
    fn operator_precedence12_0(
        &mut self,
        _plus: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let plus = pop_item!(self, plus, Plus, context);
        let operator_precedence12_0_built = OperatorPrecedence31Builder::default()
            .plus(Box::new(plus))
            .build()
            .into_diagnostic()?;
        let operator_precedence12_0_built =
            OperatorPrecedence12::OperatorPrecedence120(operator_precedence12_0_built);
        // Calling user action here
        self.user_grammar
            .operator_precedence12(&operator_precedence12_0_built)?;
        self.push(
            ASTType::OperatorPrecedence12(operator_precedence12_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 197:
    ///
    /// OperatorPrecedence12: Minus;
    ///
    #[parol_runtime::function_name::named]
    fn operator_precedence12_1(
        &mut self,
        _minus: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let minus = pop_item!(self, minus, Minus, context);
        let operator_precedence12_1_built = OperatorPrecedence32Builder::default()
            .minus(Box::new(minus))
            .build()
            .into_diagnostic()?;
        let operator_precedence12_1_built =
            OperatorPrecedence12::OperatorPrecedence121(operator_precedence12_1_built);
        // Calling user action here
        self.user_grammar
            .operator_precedence12(&operator_precedence12_1_built)?;
        self.push(
            ASTType::OperatorPrecedence12(operator_precedence12_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 198:
    ///
    /// OperatorPrecedence12: Bang;
    ///
    #[parol_runtime::function_name::named]
    fn operator_precedence12_2(
        &mut self,
        _bang: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bang = pop_item!(self, bang, Bang, context);
        let operator_precedence12_2_built = OperatorPrecedence33Builder::default()
            .bang(Box::new(bang))
            .build()
            .into_diagnostic()?;
        let operator_precedence12_2_built =
            OperatorPrecedence12::OperatorPrecedence122(operator_precedence12_2_built);
        // Calling user action here
        self.user_grammar
            .operator_precedence12(&operator_precedence12_2_built)?;
        self.push(
            ASTType::OperatorPrecedence12(operator_precedence12_2_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 199:
    ///
    /// OperatorPrecedence12: Tilde;
    ///
    #[parol_runtime::function_name::named]
    fn operator_precedence12_3(
        &mut self,
        _tilde: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let tilde = pop_item!(self, tilde, Tilde, context);
        let operator_precedence12_3_built = OperatorPrecedence34Builder::default()
            .tilde(Box::new(tilde))
            .build()
            .into_diagnostic()?;
        let operator_precedence12_3_built =
            OperatorPrecedence12::OperatorPrecedence123(operator_precedence12_3_built);
        // Calling user action here
        self.user_grammar
            .operator_precedence12(&operator_precedence12_3_built)?;
        self.push(
            ASTType::OperatorPrecedence12(operator_precedence12_3_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 200:
    ///
    /// OperatorPrecedence12: Amp;
    ///
    #[parol_runtime::function_name::named]
    fn operator_precedence12_4(
        &mut self,
        _amp: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let amp = pop_item!(self, amp, Amp, context);
        let operator_precedence12_4_built = OperatorPrecedence35Builder::default()
            .amp(Box::new(amp))
            .build()
            .into_diagnostic()?;
        let operator_precedence12_4_built =
            OperatorPrecedence12::OperatorPrecedence124(operator_precedence12_4_built);
        // Calling user action here
        self.user_grammar
            .operator_precedence12(&operator_precedence12_4_built)?;
        self.push(
            ASTType::OperatorPrecedence12(operator_precedence12_4_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 201:
    ///
    /// OperatorPrecedence12: Or;
    ///
    #[parol_runtime::function_name::named]
    fn operator_precedence12_5(
        &mut self,
        _or: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let or = pop_item!(self, or, Or, context);
        let operator_precedence12_5_built = OperatorPrecedence36Builder::default()
            .or(Box::new(or))
            .build()
            .into_diagnostic()?;
        let operator_precedence12_5_built =
            OperatorPrecedence12::OperatorPrecedence125(operator_precedence12_5_built);
        // Calling user action here
        self.user_grammar
            .operator_precedence12(&operator_precedence12_5_built)?;
        self.push(
            ASTType::OperatorPrecedence12(operator_precedence12_5_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 202:
    ///
    /// OperatorPrecedence12: Circumflex;
    ///
    #[parol_runtime::function_name::named]
    fn operator_precedence12_6(
        &mut self,
        _circumflex: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let circumflex = pop_item!(self, circumflex, Circumflex, context);
        let operator_precedence12_6_built = OperatorPrecedence37Builder::default()
            .circumflex(Box::new(circumflex))
            .build()
            .into_diagnostic()?;
        let operator_precedence12_6_built =
            OperatorPrecedence12::OperatorPrecedence126(operator_precedence12_6_built);
        // Calling user action here
        self.user_grammar
            .operator_precedence12(&operator_precedence12_6_built)?;
        self.push(
            ASTType::OperatorPrecedence12(operator_precedence12_6_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 203:
    ///
    /// OperatorPrecedence12: TildeAmp;
    ///
    #[parol_runtime::function_name::named]
    fn operator_precedence12_7(
        &mut self,
        _tilde_amp: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let tilde_amp = pop_item!(self, tilde_amp, TildeAmp, context);
        let operator_precedence12_7_built = OperatorPrecedence38Builder::default()
            .tilde_amp(Box::new(tilde_amp))
            .build()
            .into_diagnostic()?;
        let operator_precedence12_7_built =
            OperatorPrecedence12::OperatorPrecedence127(operator_precedence12_7_built);
        // Calling user action here
        self.user_grammar
            .operator_precedence12(&operator_precedence12_7_built)?;
        self.push(
            ASTType::OperatorPrecedence12(operator_precedence12_7_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 204:
    ///
    /// OperatorPrecedence12: TildeOr;
    ///
    #[parol_runtime::function_name::named]
    fn operator_precedence12_8(
        &mut self,
        _tilde_or: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let tilde_or = pop_item!(self, tilde_or, TildeOr, context);
        let operator_precedence12_8_built = OperatorPrecedence39Builder::default()
            .tilde_or(Box::new(tilde_or))
            .build()
            .into_diagnostic()?;
        let operator_precedence12_8_built =
            OperatorPrecedence12::OperatorPrecedence128(operator_precedence12_8_built);
        // Calling user action here
        self.user_grammar
            .operator_precedence12(&operator_precedence12_8_built)?;
        self.push(
            ASTType::OperatorPrecedence12(operator_precedence12_8_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 205:
    ///
    /// OperatorPrecedence12: TildeCircumflex;
    ///
    #[parol_runtime::function_name::named]
    fn operator_precedence12_9(
        &mut self,
        _tilde_circumflex: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let tilde_circumflex = pop_item!(self, tilde_circumflex, TildeCircumflex, context);
        let operator_precedence12_9_built = OperatorPrecedence40Builder::default()
            .tilde_circumflex(Box::new(tilde_circumflex))
            .build()
            .into_diagnostic()?;
        let operator_precedence12_9_built =
            OperatorPrecedence12::OperatorPrecedence129(operator_precedence12_9_built);
        // Calling user action here
        self.user_grammar
            .operator_precedence12(&operator_precedence12_9_built)?;
        self.push(
            ASTType::OperatorPrecedence12(operator_precedence12_9_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 206:
    ///
    /// OperatorPrecedence12: CircumflexTilde;
    ///
    #[parol_runtime::function_name::named]
    fn operator_precedence12_10(
        &mut self,
        _circumflex_tilde: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let circumflex_tilde = pop_item!(self, circumflex_tilde, CircumflexTilde, context);
        let operator_precedence12_10_built = OperatorPrecedence41Builder::default()
            .circumflex_tilde(Box::new(circumflex_tilde))
            .build()
            .into_diagnostic()?;
        let operator_precedence12_10_built =
            OperatorPrecedence12::OperatorPrecedence1210(operator_precedence12_10_built);
        // Calling user action here
        self.user_grammar
            .operator_precedence12(&operator_precedence12_10_built)?;
        self.push(
            ASTType::OperatorPrecedence12(operator_precedence12_10_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 207:
    ///
    /// Expression: Expression00;
    ///
    #[parol_runtime::function_name::named]
    fn expression(
        &mut self,
        _expression00: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression00 = pop_item!(self, expression00, Expression00, context);
        let expression_built = ExpressionBuilder::default()
            .expression00(Box::new(expression00))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.expression(&expression_built)?;
        self.push(ASTType::Expression(expression_built), context);
        Ok(())
    }

    /// Semantic action for production 208:
    ///
    /// Expression00: Expression01 Expression00List /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn expression00(
        &mut self,
        _expression01: &ParseTreeStackEntry<'t>,
        _expression00_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression00_list =
            pop_and_reverse_item!(self, expression00_list, Expression00List, context);
        let expression01 = pop_item!(self, expression01, Expression01, context);
        let expression00_built = Expression00Builder::default()
            .expression01(Box::new(expression01))
            .expression00_list(expression00_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.expression00(&expression00_built)?;
        self.push(ASTType::Expression00(expression00_built), context);
        Ok(())
    }

    /// Semantic action for production 209:
    ///
    /// Expression00List /* Vec<T>::Push */: OperatorPrecedence01 Expression01 Expression00List;
    ///
    #[parol_runtime::function_name::named]
    fn expression00_list_0(
        &mut self,
        _operator_precedence01: &ParseTreeStackEntry<'t>,
        _expression01: &ParseTreeStackEntry<'t>,
        _expression00_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression00_list = pop_item!(self, expression00_list, Expression00List, context);
        let expression01 = pop_item!(self, expression01, Expression01, context);
        let operator_precedence01 =
            pop_item!(self, operator_precedence01, OperatorPrecedence01, context);
        let expression00_list_0_built = Expression00ListBuilder::default()
            .expression01(Box::new(expression01))
            .operator_precedence01(Box::new(operator_precedence01))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        expression00_list.push(expression00_list_0_built);
        self.push(ASTType::Expression00List(expression00_list), context);
        Ok(())
    }

    /// Semantic action for production 210:
    ///
    /// Expression00List /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn expression00_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression00_list_1_built = Vec::new();
        self.push(
            ASTType::Expression00List(expression00_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 211:
    ///
    /// Expression01: Expression02 Expression01List /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn expression01(
        &mut self,
        _expression02: &ParseTreeStackEntry<'t>,
        _expression01_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression01_list =
            pop_and_reverse_item!(self, expression01_list, Expression01List, context);
        let expression02 = pop_item!(self, expression02, Expression02, context);
        let expression01_built = Expression01Builder::default()
            .expression02(Box::new(expression02))
            .expression01_list(expression01_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.expression01(&expression01_built)?;
        self.push(ASTType::Expression01(expression01_built), context);
        Ok(())
    }

    /// Semantic action for production 212:
    ///
    /// Expression01List /* Vec<T>::Push */: OperatorPrecedence02 Expression02 Expression01List;
    ///
    #[parol_runtime::function_name::named]
    fn expression01_list_0(
        &mut self,
        _operator_precedence02: &ParseTreeStackEntry<'t>,
        _expression02: &ParseTreeStackEntry<'t>,
        _expression01_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression01_list = pop_item!(self, expression01_list, Expression01List, context);
        let expression02 = pop_item!(self, expression02, Expression02, context);
        let operator_precedence02 =
            pop_item!(self, operator_precedence02, OperatorPrecedence02, context);
        let expression01_list_0_built = Expression01ListBuilder::default()
            .expression02(Box::new(expression02))
            .operator_precedence02(Box::new(operator_precedence02))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        expression01_list.push(expression01_list_0_built);
        self.push(ASTType::Expression01List(expression01_list), context);
        Ok(())
    }

    /// Semantic action for production 213:
    ///
    /// Expression01List /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn expression01_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression01_list_1_built = Vec::new();
        self.push(
            ASTType::Expression01List(expression01_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 214:
    ///
    /// Expression02: Expression03 Expression02List /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn expression02(
        &mut self,
        _expression03: &ParseTreeStackEntry<'t>,
        _expression02_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression02_list =
            pop_and_reverse_item!(self, expression02_list, Expression02List, context);
        let expression03 = pop_item!(self, expression03, Expression03, context);
        let expression02_built = Expression02Builder::default()
            .expression03(Box::new(expression03))
            .expression02_list(expression02_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.expression02(&expression02_built)?;
        self.push(ASTType::Expression02(expression02_built), context);
        Ok(())
    }

    /// Semantic action for production 215:
    ///
    /// Expression02List /* Vec<T>::Push */: OperatorPrecedence03 Expression03 Expression02List;
    ///
    #[parol_runtime::function_name::named]
    fn expression02_list_0(
        &mut self,
        _operator_precedence03: &ParseTreeStackEntry<'t>,
        _expression03: &ParseTreeStackEntry<'t>,
        _expression02_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression02_list = pop_item!(self, expression02_list, Expression02List, context);
        let expression03 = pop_item!(self, expression03, Expression03, context);
        let operator_precedence03 =
            pop_item!(self, operator_precedence03, OperatorPrecedence03, context);
        let expression02_list_0_built = Expression02ListBuilder::default()
            .expression03(Box::new(expression03))
            .operator_precedence03(Box::new(operator_precedence03))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        expression02_list.push(expression02_list_0_built);
        self.push(ASTType::Expression02List(expression02_list), context);
        Ok(())
    }

    /// Semantic action for production 216:
    ///
    /// Expression02List /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn expression02_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression02_list_1_built = Vec::new();
        self.push(
            ASTType::Expression02List(expression02_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 217:
    ///
    /// Expression03: Expression04 Expression03List /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn expression03(
        &mut self,
        _expression04: &ParseTreeStackEntry<'t>,
        _expression03_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression03_list =
            pop_and_reverse_item!(self, expression03_list, Expression03List, context);
        let expression04 = pop_item!(self, expression04, Expression04, context);
        let expression03_built = Expression03Builder::default()
            .expression04(Box::new(expression04))
            .expression03_list(expression03_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.expression03(&expression03_built)?;
        self.push(ASTType::Expression03(expression03_built), context);
        Ok(())
    }

    /// Semantic action for production 218:
    ///
    /// Expression03List /* Vec<T>::Push */: OperatorPrecedence04 Expression04 Expression03List;
    ///
    #[parol_runtime::function_name::named]
    fn expression03_list_0(
        &mut self,
        _operator_precedence04: &ParseTreeStackEntry<'t>,
        _expression04: &ParseTreeStackEntry<'t>,
        _expression03_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression03_list = pop_item!(self, expression03_list, Expression03List, context);
        let expression04 = pop_item!(self, expression04, Expression04, context);
        let operator_precedence04 =
            pop_item!(self, operator_precedence04, OperatorPrecedence04, context);
        let expression03_list_0_built = Expression03ListBuilder::default()
            .expression04(Box::new(expression04))
            .operator_precedence04(Box::new(operator_precedence04))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        expression03_list.push(expression03_list_0_built);
        self.push(ASTType::Expression03List(expression03_list), context);
        Ok(())
    }

    /// Semantic action for production 219:
    ///
    /// Expression03List /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn expression03_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression03_list_1_built = Vec::new();
        self.push(
            ASTType::Expression03List(expression03_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 220:
    ///
    /// Expression04: Expression05 Expression04List /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn expression04(
        &mut self,
        _expression05: &ParseTreeStackEntry<'t>,
        _expression04_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression04_list =
            pop_and_reverse_item!(self, expression04_list, Expression04List, context);
        let expression05 = pop_item!(self, expression05, Expression05, context);
        let expression04_built = Expression04Builder::default()
            .expression05(Box::new(expression05))
            .expression04_list(expression04_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.expression04(&expression04_built)?;
        self.push(ASTType::Expression04(expression04_built), context);
        Ok(())
    }

    /// Semantic action for production 221:
    ///
    /// Expression04List /* Vec<T>::Push */: OperatorPrecedence05 Expression05 Expression04List;
    ///
    #[parol_runtime::function_name::named]
    fn expression04_list_0(
        &mut self,
        _operator_precedence05: &ParseTreeStackEntry<'t>,
        _expression05: &ParseTreeStackEntry<'t>,
        _expression04_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression04_list = pop_item!(self, expression04_list, Expression04List, context);
        let expression05 = pop_item!(self, expression05, Expression05, context);
        let operator_precedence05 =
            pop_item!(self, operator_precedence05, OperatorPrecedence05, context);
        let expression04_list_0_built = Expression04ListBuilder::default()
            .expression05(Box::new(expression05))
            .operator_precedence05(Box::new(operator_precedence05))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        expression04_list.push(expression04_list_0_built);
        self.push(ASTType::Expression04List(expression04_list), context);
        Ok(())
    }

    /// Semantic action for production 222:
    ///
    /// Expression04List /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn expression04_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression04_list_1_built = Vec::new();
        self.push(
            ASTType::Expression04List(expression04_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 223:
    ///
    /// Expression05: Expression06 Expression05List /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn expression05(
        &mut self,
        _expression06: &ParseTreeStackEntry<'t>,
        _expression05_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression05_list =
            pop_and_reverse_item!(self, expression05_list, Expression05List, context);
        let expression06 = pop_item!(self, expression06, Expression06, context);
        let expression05_built = Expression05Builder::default()
            .expression06(Box::new(expression06))
            .expression05_list(expression05_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.expression05(&expression05_built)?;
        self.push(ASTType::Expression05(expression05_built), context);
        Ok(())
    }

    /// Semantic action for production 224:
    ///
    /// Expression05List /* Vec<T>::Push */: OperatorPrecedence06 Expression06 Expression05List;
    ///
    #[parol_runtime::function_name::named]
    fn expression05_list_0(
        &mut self,
        _operator_precedence06: &ParseTreeStackEntry<'t>,
        _expression06: &ParseTreeStackEntry<'t>,
        _expression05_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression05_list = pop_item!(self, expression05_list, Expression05List, context);
        let expression06 = pop_item!(self, expression06, Expression06, context);
        let operator_precedence06 =
            pop_item!(self, operator_precedence06, OperatorPrecedence06, context);
        let expression05_list_0_built = Expression05ListBuilder::default()
            .expression06(Box::new(expression06))
            .operator_precedence06(Box::new(operator_precedence06))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        expression05_list.push(expression05_list_0_built);
        self.push(ASTType::Expression05List(expression05_list), context);
        Ok(())
    }

    /// Semantic action for production 225:
    ///
    /// Expression05List /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn expression05_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression05_list_1_built = Vec::new();
        self.push(
            ASTType::Expression05List(expression05_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 226:
    ///
    /// Expression06: Expression07 Expression06List /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn expression06(
        &mut self,
        _expression07: &ParseTreeStackEntry<'t>,
        _expression06_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression06_list =
            pop_and_reverse_item!(self, expression06_list, Expression06List, context);
        let expression07 = pop_item!(self, expression07, Expression07, context);
        let expression06_built = Expression06Builder::default()
            .expression07(Box::new(expression07))
            .expression06_list(expression06_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.expression06(&expression06_built)?;
        self.push(ASTType::Expression06(expression06_built), context);
        Ok(())
    }

    /// Semantic action for production 227:
    ///
    /// Expression06List /* Vec<T>::Push */: OperatorPrecedence07 Expression07 Expression06List;
    ///
    #[parol_runtime::function_name::named]
    fn expression06_list_0(
        &mut self,
        _operator_precedence07: &ParseTreeStackEntry<'t>,
        _expression07: &ParseTreeStackEntry<'t>,
        _expression06_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression06_list = pop_item!(self, expression06_list, Expression06List, context);
        let expression07 = pop_item!(self, expression07, Expression07, context);
        let operator_precedence07 =
            pop_item!(self, operator_precedence07, OperatorPrecedence07, context);
        let expression06_list_0_built = Expression06ListBuilder::default()
            .expression07(Box::new(expression07))
            .operator_precedence07(Box::new(operator_precedence07))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        expression06_list.push(expression06_list_0_built);
        self.push(ASTType::Expression06List(expression06_list), context);
        Ok(())
    }

    /// Semantic action for production 228:
    ///
    /// Expression06List /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn expression06_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression06_list_1_built = Vec::new();
        self.push(
            ASTType::Expression06List(expression06_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 229:
    ///
    /// Expression07: Expression08 Expression07List /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn expression07(
        &mut self,
        _expression08: &ParseTreeStackEntry<'t>,
        _expression07_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression07_list =
            pop_and_reverse_item!(self, expression07_list, Expression07List, context);
        let expression08 = pop_item!(self, expression08, Expression08, context);
        let expression07_built = Expression07Builder::default()
            .expression08(Box::new(expression08))
            .expression07_list(expression07_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.expression07(&expression07_built)?;
        self.push(ASTType::Expression07(expression07_built), context);
        Ok(())
    }

    /// Semantic action for production 230:
    ///
    /// Expression07List /* Vec<T>::Push */: OperatorPrecedence08 Expression08 Expression07List;
    ///
    #[parol_runtime::function_name::named]
    fn expression07_list_0(
        &mut self,
        _operator_precedence08: &ParseTreeStackEntry<'t>,
        _expression08: &ParseTreeStackEntry<'t>,
        _expression07_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression07_list = pop_item!(self, expression07_list, Expression07List, context);
        let expression08 = pop_item!(self, expression08, Expression08, context);
        let operator_precedence08 =
            pop_item!(self, operator_precedence08, OperatorPrecedence08, context);
        let expression07_list_0_built = Expression07ListBuilder::default()
            .expression08(Box::new(expression08))
            .operator_precedence08(Box::new(operator_precedence08))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        expression07_list.push(expression07_list_0_built);
        self.push(ASTType::Expression07List(expression07_list), context);
        Ok(())
    }

    /// Semantic action for production 231:
    ///
    /// Expression07List /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn expression07_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression07_list_1_built = Vec::new();
        self.push(
            ASTType::Expression07List(expression07_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 232:
    ///
    /// Expression08: Expression09 Expression08List /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn expression08(
        &mut self,
        _expression09: &ParseTreeStackEntry<'t>,
        _expression08_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression08_list =
            pop_and_reverse_item!(self, expression08_list, Expression08List, context);
        let expression09 = pop_item!(self, expression09, Expression09, context);
        let expression08_built = Expression08Builder::default()
            .expression09(Box::new(expression09))
            .expression08_list(expression08_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.expression08(&expression08_built)?;
        self.push(ASTType::Expression08(expression08_built), context);
        Ok(())
    }

    /// Semantic action for production 233:
    ///
    /// Expression08List /* Vec<T>::Push */: OperatorPrecedence09 Expression09 Expression08List;
    ///
    #[parol_runtime::function_name::named]
    fn expression08_list_0(
        &mut self,
        _operator_precedence09: &ParseTreeStackEntry<'t>,
        _expression09: &ParseTreeStackEntry<'t>,
        _expression08_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression08_list = pop_item!(self, expression08_list, Expression08List, context);
        let expression09 = pop_item!(self, expression09, Expression09, context);
        let operator_precedence09 =
            pop_item!(self, operator_precedence09, OperatorPrecedence09, context);
        let expression08_list_0_built = Expression08ListBuilder::default()
            .expression09(Box::new(expression09))
            .operator_precedence09(Box::new(operator_precedence09))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        expression08_list.push(expression08_list_0_built);
        self.push(ASTType::Expression08List(expression08_list), context);
        Ok(())
    }

    /// Semantic action for production 234:
    ///
    /// Expression08List /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn expression08_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression08_list_1_built = Vec::new();
        self.push(
            ASTType::Expression08List(expression08_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 235:
    ///
    /// Expression09: Expression10 Expression09List /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn expression09(
        &mut self,
        _expression10: &ParseTreeStackEntry<'t>,
        _expression09_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression09_list =
            pop_and_reverse_item!(self, expression09_list, Expression09List, context);
        let expression10 = pop_item!(self, expression10, Expression10, context);
        let expression09_built = Expression09Builder::default()
            .expression10(Box::new(expression10))
            .expression09_list(expression09_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.expression09(&expression09_built)?;
        self.push(ASTType::Expression09(expression09_built), context);
        Ok(())
    }

    /// Semantic action for production 236:
    ///
    /// Expression09List /* Vec<T>::Push */: OperatorPrecedence10 Expression10 Expression09List;
    ///
    #[parol_runtime::function_name::named]
    fn expression09_list_0(
        &mut self,
        _operator_precedence10: &ParseTreeStackEntry<'t>,
        _expression10: &ParseTreeStackEntry<'t>,
        _expression09_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression09_list = pop_item!(self, expression09_list, Expression09List, context);
        let expression10 = pop_item!(self, expression10, Expression10, context);
        let operator_precedence10 =
            pop_item!(self, operator_precedence10, OperatorPrecedence10, context);
        let expression09_list_0_built = Expression09ListBuilder::default()
            .expression10(Box::new(expression10))
            .operator_precedence10(Box::new(operator_precedence10))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        expression09_list.push(expression09_list_0_built);
        self.push(ASTType::Expression09List(expression09_list), context);
        Ok(())
    }

    /// Semantic action for production 237:
    ///
    /// Expression09List /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn expression09_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression09_list_1_built = Vec::new();
        self.push(
            ASTType::Expression09List(expression09_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 238:
    ///
    /// Expression10: Expression11 Expression10List /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn expression10(
        &mut self,
        _expression11: &ParseTreeStackEntry<'t>,
        _expression10_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression10_list =
            pop_and_reverse_item!(self, expression10_list, Expression10List, context);
        let expression11 = pop_item!(self, expression11, Expression11, context);
        let expression10_built = Expression10Builder::default()
            .expression11(Box::new(expression11))
            .expression10_list(expression10_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.expression10(&expression10_built)?;
        self.push(ASTType::Expression10(expression10_built), context);
        Ok(())
    }

    /// Semantic action for production 239:
    ///
    /// Expression10List /* Vec<T>::Push */: OperatorPrecedence11 Expression11 Expression10List;
    ///
    #[parol_runtime::function_name::named]
    fn expression10_list_0(
        &mut self,
        _operator_precedence11: &ParseTreeStackEntry<'t>,
        _expression11: &ParseTreeStackEntry<'t>,
        _expression10_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression10_list = pop_item!(self, expression10_list, Expression10List, context);
        let expression11 = pop_item!(self, expression11, Expression11, context);
        let operator_precedence11 =
            pop_item!(self, operator_precedence11, OperatorPrecedence11, context);
        let expression10_list_0_built = Expression10ListBuilder::default()
            .expression11(Box::new(expression11))
            .operator_precedence11(Box::new(operator_precedence11))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        expression10_list.push(expression10_list_0_built);
        self.push(ASTType::Expression10List(expression10_list), context);
        Ok(())
    }

    /// Semantic action for production 240:
    ///
    /// Expression10List /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn expression10_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression10_list_1_built = Vec::new();
        self.push(
            ASTType::Expression10List(expression10_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 241:
    ///
    /// Expression11: Expression11Opt /* Option */ Expression12;
    ///
    #[parol_runtime::function_name::named]
    fn expression11(
        &mut self,
        _expression11_opt: &ParseTreeStackEntry<'t>,
        _expression12: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression12 = pop_item!(self, expression12, Expression12, context);
        let expression11_opt = pop_item!(self, expression11_opt, Expression11Opt, context);
        let expression11_built = Expression11Builder::default()
            .expression11_opt(expression11_opt)
            .expression12(Box::new(expression12))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.expression11(&expression11_built)?;
        self.push(ASTType::Expression11(expression11_built), context);
        Ok(())
    }

    /// Semantic action for production 242:
    ///
    /// Expression11Opt /* Option<T>::Some */: OperatorPrecedence12;
    ///
    #[parol_runtime::function_name::named]
    fn expression11_opt_0(
        &mut self,
        _operator_precedence12: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator_precedence12 =
            pop_item!(self, operator_precedence12, OperatorPrecedence12, context);
        let expression11_opt_0_built = Expression11OptBuilder::default()
            .operator_precedence12(Box::new(operator_precedence12))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::Expression11Opt(Some(Box::new(expression11_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 243:
    ///
    /// Expression11Opt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn expression11_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::Expression11Opt(None), context);
        Ok(())
    }

    /// Semantic action for production 244:
    ///
    /// Expression12: Factor;
    ///
    #[parol_runtime::function_name::named]
    fn expression12(
        &mut self,
        _factor: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let factor = pop_item!(self, factor, Factor, context);
        let expression12_built = Expression12Builder::default()
            .factor(Box::new(factor))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.expression12(&expression12_built)?;
        self.push(ASTType::Expression12(expression12_built), context);
        Ok(())
    }

    /// Semantic action for production 245:
    ///
    /// Factor: Number;
    ///
    #[parol_runtime::function_name::named]
    fn factor_0(
        &mut self,
        _number: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let number = pop_item!(self, number, Number, context);
        let factor_0_built = Factor0Builder::default()
            .number(Box::new(number))
            .build()
            .into_diagnostic()?;
        let factor_0_built = Factor::Factor0(factor_0_built);
        // Calling user action here
        self.user_grammar.factor(&factor_0_built)?;
        self.push(ASTType::Factor(factor_0_built), context);
        Ok(())
    }

    /// Semantic action for production 246:
    ///
    /// Factor: Identifier FactorList /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn factor_1(
        &mut self,
        _identifier: &ParseTreeStackEntry<'t>,
        _factor_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let factor_list = pop_and_reverse_item!(self, factor_list, FactorList, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let factor_1_built = Factor1Builder::default()
            .identifier(Box::new(identifier))
            .factor_list(factor_list)
            .build()
            .into_diagnostic()?;
        let factor_1_built = Factor::Factor1(factor_1_built);
        // Calling user action here
        self.user_grammar.factor(&factor_1_built)?;
        self.push(ASTType::Factor(factor_1_built), context);
        Ok(())
    }

    /// Semantic action for production 247:
    ///
    /// FactorList /* Vec<T>::Push */: Range FactorList;
    ///
    #[parol_runtime::function_name::named]
    fn factor_list_0(
        &mut self,
        _range: &ParseTreeStackEntry<'t>,
        _factor_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut factor_list = pop_item!(self, factor_list, FactorList, context);
        let range = pop_item!(self, range, Range, context);
        let factor_list_0_built = FactorListBuilder::default()
            .range(Box::new(range))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        factor_list.push(factor_list_0_built);
        self.push(ASTType::FactorList(factor_list), context);
        Ok(())
    }

    /// Semantic action for production 248:
    ///
    /// FactorList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn factor_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let factor_list_1_built = Vec::new();
        self.push(ASTType::FactorList(factor_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 249:
    ///
    /// Factor: LParen Expression RParen;
    ///
    #[parol_runtime::function_name::named]
    fn factor_2(
        &mut self,
        _l_paren: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _r_paren: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren = pop_item!(self, r_paren, RParen, context);
        let expression = pop_item!(self, expression, Expression, context);
        let l_paren = pop_item!(self, l_paren, LParen, context);
        let factor_2_built = Factor2Builder::default()
            .l_paren(Box::new(l_paren))
            .expression(Box::new(expression))
            .r_paren(Box::new(r_paren))
            .build()
            .into_diagnostic()?;
        let factor_2_built = Factor::Factor2(factor_2_built);
        // Calling user action here
        self.user_grammar.factor(&factor_2_built)?;
        self.push(ASTType::Factor(factor_2_built), context);
        Ok(())
    }

    /// Semantic action for production 250:
    ///
    /// Statement: AssignmentStatement;
    ///
    #[parol_runtime::function_name::named]
    fn statement_0(
        &mut self,
        _assignment_statement: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let assignment_statement =
            pop_item!(self, assignment_statement, AssignmentStatement, context);
        let statement_0_built = Statement0Builder::default()
            .assignment_statement(Box::new(assignment_statement))
            .build()
            .into_diagnostic()?;
        let statement_0_built = Statement::Statement0(statement_0_built);
        // Calling user action here
        self.user_grammar.statement(&statement_0_built)?;
        self.push(ASTType::Statement(statement_0_built), context);
        Ok(())
    }

    /// Semantic action for production 251:
    ///
    /// Statement: IfStatement;
    ///
    #[parol_runtime::function_name::named]
    fn statement_1(
        &mut self,
        _if_statement: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_statement = pop_item!(self, if_statement, IfStatement, context);
        let statement_1_built = Statement1Builder::default()
            .if_statement(Box::new(if_statement))
            .build()
            .into_diagnostic()?;
        let statement_1_built = Statement::Statement1(statement_1_built);
        // Calling user action here
        self.user_grammar.statement(&statement_1_built)?;
        self.push(ASTType::Statement(statement_1_built), context);
        Ok(())
    }

    /// Semantic action for production 252:
    ///
    /// AssignmentStatement: Identifier Equ Expression Semicolon;
    ///
    #[parol_runtime::function_name::named]
    fn assignment_statement(
        &mut self,
        _identifier: &ParseTreeStackEntry<'t>,
        _equ: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _semicolon: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon = pop_item!(self, semicolon, Semicolon, context);
        let expression = pop_item!(self, expression, Expression, context);
        let equ = pop_item!(self, equ, Equ, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let assignment_statement_built = AssignmentStatementBuilder::default()
            .identifier(Box::new(identifier))
            .equ(Box::new(equ))
            .expression(Box::new(expression))
            .semicolon(Box::new(semicolon))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .assignment_statement(&assignment_statement_built)?;
        self.push(
            ASTType::AssignmentStatement(assignment_statement_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 253:
    ///
    /// IfStatement: If Expression LBrace Statement RBrace IfStatementList /* Vec */ IfStatementOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn if_statement(
        &mut self,
        _if: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _l_brace: &ParseTreeStackEntry<'t>,
        _statement: &ParseTreeStackEntry<'t>,
        _r_brace: &ParseTreeStackEntry<'t>,
        _if_statement_list: &ParseTreeStackEntry<'t>,
        _if_statement_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_statement_opt = pop_item!(self, if_statement_opt, IfStatementOpt, context);
        let if_statement_list =
            pop_and_reverse_item!(self, if_statement_list, IfStatementList, context);
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let statement = pop_item!(self, statement, Statement, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let expression = pop_item!(self, expression, Expression, context);
        let r#if = pop_item!(self, r#if, If, context);
        let if_statement_built = IfStatementBuilder::default()
            .r#if(Box::new(r#if))
            .expression(Box::new(expression))
            .l_brace(Box::new(l_brace))
            .statement(Box::new(statement))
            .r_brace(Box::new(r_brace))
            .if_statement_list(if_statement_list)
            .if_statement_opt(if_statement_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.if_statement(&if_statement_built)?;
        self.push(ASTType::IfStatement(if_statement_built), context);
        Ok(())
    }

    /// Semantic action for production 254:
    ///
    /// IfStatementList /* Vec<T>::Push */: Else If Expression LBrace Statement RBrace IfStatementList;
    ///
    #[parol_runtime::function_name::named]
    fn if_statement_list_0(
        &mut self,
        _else: &ParseTreeStackEntry<'t>,
        _if: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _l_brace: &ParseTreeStackEntry<'t>,
        _statement: &ParseTreeStackEntry<'t>,
        _r_brace: &ParseTreeStackEntry<'t>,
        _if_statement_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut if_statement_list = pop_item!(self, if_statement_list, IfStatementList, context);
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let statement = pop_item!(self, statement, Statement, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let expression = pop_item!(self, expression, Expression, context);
        let r#if = pop_item!(self, r#if, If, context);
        let r#else = pop_item!(self, r#else, Else, context);
        let if_statement_list_0_built = IfStatementListBuilder::default()
            .r_brace(Box::new(r_brace))
            .statement(Box::new(statement))
            .l_brace(Box::new(l_brace))
            .expression(Box::new(expression))
            .r#if(Box::new(r#if))
            .r#else(Box::new(r#else))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        if_statement_list.push(if_statement_list_0_built);
        self.push(ASTType::IfStatementList(if_statement_list), context);
        Ok(())
    }

    /// Semantic action for production 255:
    ///
    /// IfStatementList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn if_statement_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_statement_list_1_built = Vec::new();
        self.push(ASTType::IfStatementList(if_statement_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 256:
    ///
    /// IfStatementOpt /* Option<T>::Some */: Else LBrace Statement RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn if_statement_opt_0(
        &mut self,
        _else: &ParseTreeStackEntry<'t>,
        _l_brace: &ParseTreeStackEntry<'t>,
        _statement: &ParseTreeStackEntry<'t>,
        _r_brace: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let statement = pop_item!(self, statement, Statement, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let r#else = pop_item!(self, r#else, Else, context);
        let if_statement_opt_0_built = IfStatementOptBuilder::default()
            .r#else(Box::new(r#else))
            .l_brace(Box::new(l_brace))
            .statement(Box::new(statement))
            .r_brace(Box::new(r_brace))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::IfStatementOpt(Some(Box::new(if_statement_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 257:
    ///
    /// IfStatementOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn if_statement_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::IfStatementOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 258:
    ///
    /// Range: LBracket Expression RangeOpt /* Option */ RBracket;
    ///
    #[parol_runtime::function_name::named]
    fn range(
        &mut self,
        _l_bracket: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _range_opt: &ParseTreeStackEntry<'t>,
        _r_bracket: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_bracket = pop_item!(self, r_bracket, RBracket, context);
        let range_opt = pop_item!(self, range_opt, RangeOpt, context);
        let expression = pop_item!(self, expression, Expression, context);
        let l_bracket = pop_item!(self, l_bracket, LBracket, context);
        let range_built = RangeBuilder::default()
            .l_bracket(Box::new(l_bracket))
            .expression(Box::new(expression))
            .range_opt(range_opt)
            .r_bracket(Box::new(r_bracket))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.range(&range_built)?;
        self.push(ASTType::Range(range_built), context);
        Ok(())
    }

    /// Semantic action for production 259:
    ///
    /// RangeOpt /* Option<T>::Some */: Colon Expression;
    ///
    #[parol_runtime::function_name::named]
    fn range_opt_0(
        &mut self,
        _colon: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = pop_item!(self, expression, Expression, context);
        let colon = pop_item!(self, colon, Colon, context);
        let range_opt_0_built = RangeOptBuilder::default()
            .colon(Box::new(colon))
            .expression(Box::new(expression))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::RangeOpt(Some(Box::new(range_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 260:
    ///
    /// RangeOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn range_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::RangeOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 261:
    ///
    /// Width: LBracket Expression RBracket;
    ///
    #[parol_runtime::function_name::named]
    fn width(
        &mut self,
        _l_bracket: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _r_bracket: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_bracket = pop_item!(self, r_bracket, RBracket, context);
        let expression = pop_item!(self, expression, Expression, context);
        let l_bracket = pop_item!(self, l_bracket, LBracket, context);
        let width_built = WidthBuilder::default()
            .l_bracket(Box::new(l_bracket))
            .expression(Box::new(expression))
            .r_bracket(Box::new(r_bracket))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.width(&width_built)?;
        self.push(ASTType::Width(width_built), context);
        Ok(())
    }

    /// Semantic action for production 262:
    ///
    /// BuiltinType: Logic;
    ///
    #[parol_runtime::function_name::named]
    fn builtin_type_0(
        &mut self,
        _logic: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logic = pop_item!(self, logic, Logic, context);
        let builtin_type_0_built = BuiltinType0Builder::default()
            .logic(Box::new(logic))
            .build()
            .into_diagnostic()?;
        let builtin_type_0_built = BuiltinType::BuiltinType0(builtin_type_0_built);
        // Calling user action here
        self.user_grammar.builtin_type(&builtin_type_0_built)?;
        self.push(ASTType::BuiltinType(builtin_type_0_built), context);
        Ok(())
    }

    /// Semantic action for production 263:
    ///
    /// BuiltinType: Bit;
    ///
    #[parol_runtime::function_name::named]
    fn builtin_type_1(
        &mut self,
        _bit: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bit = pop_item!(self, bit, Bit, context);
        let builtin_type_1_built = BuiltinType1Builder::default()
            .bit(Box::new(bit))
            .build()
            .into_diagnostic()?;
        let builtin_type_1_built = BuiltinType::BuiltinType1(builtin_type_1_built);
        // Calling user action here
        self.user_grammar.builtin_type(&builtin_type_1_built)?;
        self.push(ASTType::BuiltinType(builtin_type_1_built), context);
        Ok(())
    }

    /// Semantic action for production 264:
    ///
    /// BuiltinType: U32;
    ///
    #[parol_runtime::function_name::named]
    fn builtin_type_2(
        &mut self,
        _u32: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let u32 = pop_item!(self, u32, U32, context);
        let builtin_type_2_built = BuiltinType2Builder::default()
            .u32(Box::new(u32))
            .build()
            .into_diagnostic()?;
        let builtin_type_2_built = BuiltinType::BuiltinType2(builtin_type_2_built);
        // Calling user action here
        self.user_grammar.builtin_type(&builtin_type_2_built)?;
        self.push(ASTType::BuiltinType(builtin_type_2_built), context);
        Ok(())
    }

    /// Semantic action for production 265:
    ///
    /// BuiltinType: U64;
    ///
    #[parol_runtime::function_name::named]
    fn builtin_type_3(
        &mut self,
        _u64: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let u64 = pop_item!(self, u64, U64, context);
        let builtin_type_3_built = BuiltinType3Builder::default()
            .u64(Box::new(u64))
            .build()
            .into_diagnostic()?;
        let builtin_type_3_built = BuiltinType::BuiltinType3(builtin_type_3_built);
        // Calling user action here
        self.user_grammar.builtin_type(&builtin_type_3_built)?;
        self.push(ASTType::BuiltinType(builtin_type_3_built), context);
        Ok(())
    }

    /// Semantic action for production 266:
    ///
    /// BuiltinType: I32;
    ///
    #[parol_runtime::function_name::named]
    fn builtin_type_4(
        &mut self,
        _i32: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let i32 = pop_item!(self, i32, I32, context);
        let builtin_type_4_built = BuiltinType4Builder::default()
            .i32(Box::new(i32))
            .build()
            .into_diagnostic()?;
        let builtin_type_4_built = BuiltinType::BuiltinType4(builtin_type_4_built);
        // Calling user action here
        self.user_grammar.builtin_type(&builtin_type_4_built)?;
        self.push(ASTType::BuiltinType(builtin_type_4_built), context);
        Ok(())
    }

    /// Semantic action for production 267:
    ///
    /// BuiltinType: I64;
    ///
    #[parol_runtime::function_name::named]
    fn builtin_type_5(
        &mut self,
        _i64: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let i64 = pop_item!(self, i64, I64, context);
        let builtin_type_5_built = BuiltinType5Builder::default()
            .i64(Box::new(i64))
            .build()
            .into_diagnostic()?;
        let builtin_type_5_built = BuiltinType::BuiltinType5(builtin_type_5_built);
        // Calling user action here
        self.user_grammar.builtin_type(&builtin_type_5_built)?;
        self.push(ASTType::BuiltinType(builtin_type_5_built), context);
        Ok(())
    }

    /// Semantic action for production 268:
    ///
    /// BuiltinType: F32;
    ///
    #[parol_runtime::function_name::named]
    fn builtin_type_6(
        &mut self,
        _f32: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let f32 = pop_item!(self, f32, F32, context);
        let builtin_type_6_built = BuiltinType6Builder::default()
            .f32(Box::new(f32))
            .build()
            .into_diagnostic()?;
        let builtin_type_6_built = BuiltinType::BuiltinType6(builtin_type_6_built);
        // Calling user action here
        self.user_grammar.builtin_type(&builtin_type_6_built)?;
        self.push(ASTType::BuiltinType(builtin_type_6_built), context);
        Ok(())
    }

    /// Semantic action for production 269:
    ///
    /// BuiltinType: F64;
    ///
    #[parol_runtime::function_name::named]
    fn builtin_type_7(
        &mut self,
        _f64: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let f64 = pop_item!(self, f64, F64, context);
        let builtin_type_7_built = BuiltinType7Builder::default()
            .f64(Box::new(f64))
            .build()
            .into_diagnostic()?;
        let builtin_type_7_built = BuiltinType::BuiltinType7(builtin_type_7_built);
        // Calling user action here
        self.user_grammar.builtin_type(&builtin_type_7_built)?;
        self.push(ASTType::BuiltinType(builtin_type_7_built), context);
        Ok(())
    }

    /// Semantic action for production 270:
    ///
    /// Type: TypeGroup TypeList /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn r#type(
        &mut self,
        _type_group: &ParseTreeStackEntry<'t>,
        _type_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_list = pop_and_reverse_item!(self, type_list, TypeList, context);
        let type_group = pop_item!(self, type_group, TypeGroup, context);
        let r#type_built = TypeBuilder::default()
            .type_group(Box::new(type_group))
            .type_list(type_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.r#type(&r#type_built)?;
        self.push(ASTType::Type(r#type_built), context);
        Ok(())
    }

    /// Semantic action for production 271:
    ///
    /// TypeGroup: BuiltinType;
    ///
    #[parol_runtime::function_name::named]
    fn type_group_0(
        &mut self,
        _builtin_type: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let builtin_type = pop_item!(self, builtin_type, BuiltinType, context);
        let type_group_0_built = TypeGroup0Builder::default()
            .builtin_type(Box::new(builtin_type))
            .build()
            .into_diagnostic()?;
        let type_group_0_built = TypeGroup::TypeGroup0(type_group_0_built);
        self.push(ASTType::TypeGroup(type_group_0_built), context);
        Ok(())
    }

    /// Semantic action for production 272:
    ///
    /// TypeGroup: Identifier;
    ///
    #[parol_runtime::function_name::named]
    fn type_group_1(
        &mut self,
        _identifier: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let identifier = pop_item!(self, identifier, Identifier, context);
        let type_group_1_built = TypeGroup1Builder::default()
            .identifier(Box::new(identifier))
            .build()
            .into_diagnostic()?;
        let type_group_1_built = TypeGroup::TypeGroup1(type_group_1_built);
        self.push(ASTType::TypeGroup(type_group_1_built), context);
        Ok(())
    }

    /// Semantic action for production 273:
    ///
    /// TypeList /* Vec<T>::Push */: Width TypeList;
    ///
    #[parol_runtime::function_name::named]
    fn type_list_0(
        &mut self,
        _width: &ParseTreeStackEntry<'t>,
        _type_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut type_list = pop_item!(self, type_list, TypeList, context);
        let width = pop_item!(self, width, Width, context);
        let type_list_0_built = TypeListBuilder::default()
            .width(Box::new(width))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        type_list.push(type_list_0_built);
        self.push(ASTType::TypeList(type_list), context);
        Ok(())
    }

    /// Semantic action for production 274:
    ///
    /// TypeList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn type_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_list_1_built = Vec::new();
        self.push(ASTType::TypeList(type_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 275:
    ///
    /// WithParameter: Hash LParen WithParameterOpt /* Option */ RParen;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter(
        &mut self,
        _hash: &ParseTreeStackEntry<'t>,
        _l_paren: &ParseTreeStackEntry<'t>,
        _with_parameter_opt: &ParseTreeStackEntry<'t>,
        _r_paren: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren = pop_item!(self, r_paren, RParen, context);
        let with_parameter_opt = pop_item!(self, with_parameter_opt, WithParameterOpt, context);
        let l_paren = pop_item!(self, l_paren, LParen, context);
        let hash = pop_item!(self, hash, Hash, context);
        let with_parameter_built = WithParameterBuilder::default()
            .hash(Box::new(hash))
            .l_paren(Box::new(l_paren))
            .with_parameter_opt(with_parameter_opt)
            .r_paren(Box::new(r_paren))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.with_parameter(&with_parameter_built)?;
        self.push(ASTType::WithParameter(with_parameter_built), context);
        Ok(())
    }

    /// Semantic action for production 276:
    ///
    /// WithParameterOpt /* Option<T>::Some */: WithParameterList;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_opt_0(
        &mut self,
        _with_parameter_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let with_parameter_list = pop_item!(self, with_parameter_list, WithParameterList, context);
        let with_parameter_opt_0_built = WithParameterOptBuilder::default()
            .with_parameter_list(Box::new(with_parameter_list))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::WithParameterOpt(Some(Box::new(with_parameter_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 277:
    ///
    /// WithParameterOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::WithParameterOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 278:
    ///
    /// WithParameterList: WithParameterItem WithParameterListList /* Vec */ WithParameterListOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_list(
        &mut self,
        _with_parameter_item: &ParseTreeStackEntry<'t>,
        _with_parameter_list_list: &ParseTreeStackEntry<'t>,
        _with_parameter_list_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let with_parameter_list_opt =
            pop_item!(self, with_parameter_list_opt, WithParameterListOpt, context);
        let with_parameter_list_list = pop_and_reverse_item!(
            self,
            with_parameter_list_list,
            WithParameterListList,
            context
        );
        let with_parameter_item = pop_item!(self, with_parameter_item, WithParameterItem, context);
        let with_parameter_list_built = WithParameterListBuilder::default()
            .with_parameter_item(Box::new(with_parameter_item))
            .with_parameter_list_list(with_parameter_list_list)
            .with_parameter_list_opt(with_parameter_list_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .with_parameter_list(&with_parameter_list_built)?;
        self.push(
            ASTType::WithParameterList(with_parameter_list_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 279:
    ///
    /// WithParameterListList /* Vec<T>::Push */: Comma WithParameterItem WithParameterListList;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_list_list_0(
        &mut self,
        _comma: &ParseTreeStackEntry<'t>,
        _with_parameter_item: &ParseTreeStackEntry<'t>,
        _with_parameter_list_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut with_parameter_list_list = pop_item!(
            self,
            with_parameter_list_list,
            WithParameterListList,
            context
        );
        let with_parameter_item = pop_item!(self, with_parameter_item, WithParameterItem, context);
        let comma = pop_item!(self, comma, Comma, context);
        let with_parameter_list_list_0_built = WithParameterListListBuilder::default()
            .with_parameter_item(Box::new(with_parameter_item))
            .comma(Box::new(comma))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        with_parameter_list_list.push(with_parameter_list_list_0_built);
        self.push(
            ASTType::WithParameterListList(with_parameter_list_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 280:
    ///
    /// WithParameterListList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_list_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let with_parameter_list_list_1_built = Vec::new();
        self.push(
            ASTType::WithParameterListList(with_parameter_list_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 281:
    ///
    /// WithParameterListOpt /* Option<T>::Some */: Comma;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_list_opt_0(
        &mut self,
        _comma: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = pop_item!(self, comma, Comma, context);
        let with_parameter_list_opt_0_built = WithParameterListOptBuilder::default()
            .comma(Box::new(comma))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::WithParameterListOpt(Some(Box::new(with_parameter_list_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 282:
    ///
    /// WithParameterListOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_list_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::WithParameterListOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 283:
    ///
    /// WithParameterItem: WithParameterItemGroup Identifier Colon Type Equ Expression;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_item(
        &mut self,
        _with_parameter_item_group: &ParseTreeStackEntry<'t>,
        _identifier: &ParseTreeStackEntry<'t>,
        _colon: &ParseTreeStackEntry<'t>,
        _type: &ParseTreeStackEntry<'t>,
        _equ: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = pop_item!(self, expression, Expression, context);
        let equ = pop_item!(self, equ, Equ, context);
        let r#type = pop_item!(self, r#type, Type, context);
        let colon = pop_item!(self, colon, Colon, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let with_parameter_item_group = pop_item!(
            self,
            with_parameter_item_group,
            WithParameterItemGroup,
            context
        );
        let with_parameter_item_built = WithParameterItemBuilder::default()
            .with_parameter_item_group(Box::new(with_parameter_item_group))
            .identifier(Box::new(identifier))
            .colon(Box::new(colon))
            .r#type(Box::new(r#type))
            .equ(Box::new(equ))
            .expression(Box::new(expression))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .with_parameter_item(&with_parameter_item_built)?;
        self.push(
            ASTType::WithParameterItem(with_parameter_item_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 284:
    ///
    /// WithParameterItemGroup: Parameter;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_item_group_0(
        &mut self,
        _parameter: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let parameter = pop_item!(self, parameter, Parameter, context);
        let with_parameter_item_group_0_built = WithParameterItemGroup0Builder::default()
            .parameter(Box::new(parameter))
            .build()
            .into_diagnostic()?;
        let with_parameter_item_group_0_built =
            WithParameterItemGroup::WithParameterItemGroup0(with_parameter_item_group_0_built);
        self.push(
            ASTType::WithParameterItemGroup(with_parameter_item_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 285:
    ///
    /// WithParameterItemGroup: Localparam;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_item_group_1(
        &mut self,
        _localparam: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let localparam = pop_item!(self, localparam, Localparam, context);
        let with_parameter_item_group_1_built = WithParameterItemGroup1Builder::default()
            .localparam(Box::new(localparam))
            .build()
            .into_diagnostic()?;
        let with_parameter_item_group_1_built =
            WithParameterItemGroup::WithParameterItemGroup1(with_parameter_item_group_1_built);
        self.push(
            ASTType::WithParameterItemGroup(with_parameter_item_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 286:
    ///
    /// ModuleDeclaration: Module Identifier ModuleDeclarationOpt /* Option */ ModuleDeclarationOpt0 /* Option */ LBrace ModuleDeclarationList /* Vec */ RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn module_declaration(
        &mut self,
        _module: &ParseTreeStackEntry<'t>,
        _identifier: &ParseTreeStackEntry<'t>,
        _module_declaration_opt: &ParseTreeStackEntry<'t>,
        _module_declaration_opt0: &ParseTreeStackEntry<'t>,
        _l_brace: &ParseTreeStackEntry<'t>,
        _module_declaration_list: &ParseTreeStackEntry<'t>,
        _r_brace: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let module_declaration_list = pop_and_reverse_item!(
            self,
            module_declaration_list,
            ModuleDeclarationList,
            context
        );
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let module_declaration_opt0 = pop_item!(
            self,
            module_declaration_opt0,
            ModuleDeclarationOpt0,
            context
        );
        let module_declaration_opt =
            pop_item!(self, module_declaration_opt, ModuleDeclarationOpt, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let module = pop_item!(self, module, Module, context);
        let module_declaration_built = ModuleDeclarationBuilder::default()
            .module(Box::new(module))
            .identifier(Box::new(identifier))
            .module_declaration_opt(module_declaration_opt)
            .module_declaration_opt0(module_declaration_opt0)
            .l_brace(Box::new(l_brace))
            .module_declaration_list(module_declaration_list)
            .r_brace(Box::new(r_brace))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .module_declaration(&module_declaration_built)?;
        self.push(
            ASTType::ModuleDeclaration(module_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 287:
    ///
    /// ModuleDeclarationList /* Vec<T>::Push */: ModuleItem ModuleDeclarationList;
    ///
    #[parol_runtime::function_name::named]
    fn module_declaration_list_0(
        &mut self,
        _module_item: &ParseTreeStackEntry<'t>,
        _module_declaration_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut module_declaration_list = pop_item!(
            self,
            module_declaration_list,
            ModuleDeclarationList,
            context
        );
        let module_item = pop_item!(self, module_item, ModuleItem, context);
        let module_declaration_list_0_built = ModuleDeclarationListBuilder::default()
            .module_item(Box::new(module_item))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        module_declaration_list.push(module_declaration_list_0_built);
        self.push(
            ASTType::ModuleDeclarationList(module_declaration_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 288:
    ///
    /// ModuleDeclarationList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn module_declaration_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module_declaration_list_1_built = Vec::new();
        self.push(
            ASTType::ModuleDeclarationList(module_declaration_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 289:
    ///
    /// ModuleDeclarationOpt0 /* Option<T>::Some */: ModulePort;
    ///
    #[parol_runtime::function_name::named]
    fn module_declaration_opt0_0(
        &mut self,
        _module_port: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module_port = pop_item!(self, module_port, ModulePort, context);
        let module_declaration_opt0_0_built = ModuleDeclarationOpt0Builder::default()
            .module_port(Box::new(module_port))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::ModuleDeclarationOpt0(Some(Box::new(module_declaration_opt0_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 290:
    ///
    /// ModuleDeclarationOpt0 /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn module_declaration_opt0_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ModuleDeclarationOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 291:
    ///
    /// ModuleDeclarationOpt /* Option<T>::Some */: WithParameter;
    ///
    #[parol_runtime::function_name::named]
    fn module_declaration_opt_0(
        &mut self,
        _with_parameter: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let with_parameter = pop_item!(self, with_parameter, WithParameter, context);
        let module_declaration_opt_0_built = ModuleDeclarationOptBuilder::default()
            .with_parameter(Box::new(with_parameter))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::ModuleDeclarationOpt(Some(Box::new(module_declaration_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 292:
    ///
    /// ModuleDeclarationOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn module_declaration_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ModuleDeclarationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 293:
    ///
    /// ModulePort: LParen ModulePortOpt /* Option */ RParen;
    ///
    #[parol_runtime::function_name::named]
    fn module_port(
        &mut self,
        _l_paren: &ParseTreeStackEntry<'t>,
        _module_port_opt: &ParseTreeStackEntry<'t>,
        _r_paren: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren = pop_item!(self, r_paren, RParen, context);
        let module_port_opt = pop_item!(self, module_port_opt, ModulePortOpt, context);
        let l_paren = pop_item!(self, l_paren, LParen, context);
        let module_port_built = ModulePortBuilder::default()
            .l_paren(Box::new(l_paren))
            .module_port_opt(module_port_opt)
            .r_paren(Box::new(r_paren))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.module_port(&module_port_built)?;
        self.push(ASTType::ModulePort(module_port_built), context);
        Ok(())
    }

    /// Semantic action for production 294:
    ///
    /// ModulePortOpt /* Option<T>::Some */: ModulePortList;
    ///
    #[parol_runtime::function_name::named]
    fn module_port_opt_0(
        &mut self,
        _module_port_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module_port_list = pop_item!(self, module_port_list, ModulePortList, context);
        let module_port_opt_0_built = ModulePortOptBuilder::default()
            .module_port_list(Box::new(module_port_list))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::ModulePortOpt(Some(Box::new(module_port_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 295:
    ///
    /// ModulePortOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn module_port_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ModulePortOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 296:
    ///
    /// ModulePortList: ModulePortItem ModulePortListList /* Vec */ ModulePortListOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn module_port_list(
        &mut self,
        _module_port_item: &ParseTreeStackEntry<'t>,
        _module_port_list_list: &ParseTreeStackEntry<'t>,
        _module_port_list_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module_port_list_opt =
            pop_item!(self, module_port_list_opt, ModulePortListOpt, context);
        let module_port_list_list =
            pop_and_reverse_item!(self, module_port_list_list, ModulePortListList, context);
        let module_port_item = pop_item!(self, module_port_item, ModulePortItem, context);
        let module_port_list_built = ModulePortListBuilder::default()
            .module_port_item(Box::new(module_port_item))
            .module_port_list_list(module_port_list_list)
            .module_port_list_opt(module_port_list_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .module_port_list(&module_port_list_built)?;
        self.push(ASTType::ModulePortList(module_port_list_built), context);
        Ok(())
    }

    /// Semantic action for production 297:
    ///
    /// ModulePortListList /* Vec<T>::Push */: Comma ModulePortItem ModulePortListList;
    ///
    #[parol_runtime::function_name::named]
    fn module_port_list_list_0(
        &mut self,
        _comma: &ParseTreeStackEntry<'t>,
        _module_port_item: &ParseTreeStackEntry<'t>,
        _module_port_list_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut module_port_list_list =
            pop_item!(self, module_port_list_list, ModulePortListList, context);
        let module_port_item = pop_item!(self, module_port_item, ModulePortItem, context);
        let comma = pop_item!(self, comma, Comma, context);
        let module_port_list_list_0_built = ModulePortListListBuilder::default()
            .module_port_item(Box::new(module_port_item))
            .comma(Box::new(comma))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        module_port_list_list.push(module_port_list_list_0_built);
        self.push(ASTType::ModulePortListList(module_port_list_list), context);
        Ok(())
    }

    /// Semantic action for production 298:
    ///
    /// ModulePortListList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn module_port_list_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module_port_list_list_1_built = Vec::new();
        self.push(
            ASTType::ModulePortListList(module_port_list_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 299:
    ///
    /// ModulePortListOpt /* Option<T>::Some */: Comma;
    ///
    #[parol_runtime::function_name::named]
    fn module_port_list_opt_0(
        &mut self,
        _comma: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = pop_item!(self, comma, Comma, context);
        let module_port_list_opt_0_built = ModulePortListOptBuilder::default()
            .comma(Box::new(comma))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::ModulePortListOpt(Some(Box::new(module_port_list_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 300:
    ///
    /// ModulePortListOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn module_port_list_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ModulePortListOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 301:
    ///
    /// ModulePortItem: Identifier Colon Direction Type;
    ///
    #[parol_runtime::function_name::named]
    fn module_port_item(
        &mut self,
        _identifier: &ParseTreeStackEntry<'t>,
        _colon: &ParseTreeStackEntry<'t>,
        _direction: &ParseTreeStackEntry<'t>,
        _type: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#type = pop_item!(self, r#type, Type, context);
        let direction = pop_item!(self, direction, Direction, context);
        let colon = pop_item!(self, colon, Colon, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let module_port_item_built = ModulePortItemBuilder::default()
            .identifier(Box::new(identifier))
            .colon(Box::new(colon))
            .direction(Box::new(direction))
            .r#type(Box::new(r#type))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .module_port_item(&module_port_item_built)?;
        self.push(ASTType::ModulePortItem(module_port_item_built), context);
        Ok(())
    }

    /// Semantic action for production 302:
    ///
    /// Direction: Input;
    ///
    #[parol_runtime::function_name::named]
    fn direction_0(
        &mut self,
        _input: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let input = pop_item!(self, input, Input, context);
        let direction_0_built = Direction0Builder::default()
            .input(Box::new(input))
            .build()
            .into_diagnostic()?;
        let direction_0_built = Direction::Direction0(direction_0_built);
        // Calling user action here
        self.user_grammar.direction(&direction_0_built)?;
        self.push(ASTType::Direction(direction_0_built), context);
        Ok(())
    }

    /// Semantic action for production 303:
    ///
    /// Direction: Output;
    ///
    #[parol_runtime::function_name::named]
    fn direction_1(
        &mut self,
        _output: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let output = pop_item!(self, output, Output, context);
        let direction_1_built = Direction1Builder::default()
            .output(Box::new(output))
            .build()
            .into_diagnostic()?;
        let direction_1_built = Direction::Direction1(direction_1_built);
        // Calling user action here
        self.user_grammar.direction(&direction_1_built)?;
        self.push(ASTType::Direction(direction_1_built), context);
        Ok(())
    }

    /// Semantic action for production 304:
    ///
    /// Direction: Inout;
    ///
    #[parol_runtime::function_name::named]
    fn direction_2(
        &mut self,
        _inout: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inout = pop_item!(self, inout, Inout, context);
        let direction_2_built = Direction2Builder::default()
            .inout(Box::new(inout))
            .build()
            .into_diagnostic()?;
        let direction_2_built = Direction::Direction2(direction_2_built);
        // Calling user action here
        self.user_grammar.direction(&direction_2_built)?;
        self.push(ASTType::Direction(direction_2_built), context);
        Ok(())
    }

    /// Semantic action for production 305:
    ///
    /// ModuleItem: VariableDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn module_item_0(
        &mut self,
        _variable_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let variable_declaration =
            pop_item!(self, variable_declaration, VariableDeclaration, context);
        let module_item_0_built = ModuleItem0Builder::default()
            .variable_declaration(Box::new(variable_declaration))
            .build()
            .into_diagnostic()?;
        let module_item_0_built = ModuleItem::ModuleItem0(module_item_0_built);
        // Calling user action here
        self.user_grammar.module_item(&module_item_0_built)?;
        self.push(ASTType::ModuleItem(module_item_0_built), context);
        Ok(())
    }

    /// Semantic action for production 306:
    ///
    /// ModuleItem: ParameterDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn module_item_1(
        &mut self,
        _parameter_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let parameter_declaration =
            pop_item!(self, parameter_declaration, ParameterDeclaration, context);
        let module_item_1_built = ModuleItem1Builder::default()
            .parameter_declaration(Box::new(parameter_declaration))
            .build()
            .into_diagnostic()?;
        let module_item_1_built = ModuleItem::ModuleItem1(module_item_1_built);
        // Calling user action here
        self.user_grammar.module_item(&module_item_1_built)?;
        self.push(ASTType::ModuleItem(module_item_1_built), context);
        Ok(())
    }

    /// Semantic action for production 307:
    ///
    /// ModuleItem: LocalparamDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn module_item_2(
        &mut self,
        _localparam_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let localparam_declaration =
            pop_item!(self, localparam_declaration, LocalparamDeclaration, context);
        let module_item_2_built = ModuleItem2Builder::default()
            .localparam_declaration(Box::new(localparam_declaration))
            .build()
            .into_diagnostic()?;
        let module_item_2_built = ModuleItem::ModuleItem2(module_item_2_built);
        // Calling user action here
        self.user_grammar.module_item(&module_item_2_built)?;
        self.push(ASTType::ModuleItem(module_item_2_built), context);
        Ok(())
    }

    /// Semantic action for production 308:
    ///
    /// ModuleItem: AlwaysFfDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn module_item_3(
        &mut self,
        _always_ff_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let always_ff_declaration =
            pop_item!(self, always_ff_declaration, AlwaysFfDeclaration, context);
        let module_item_3_built = ModuleItem3Builder::default()
            .always_ff_declaration(Box::new(always_ff_declaration))
            .build()
            .into_diagnostic()?;
        let module_item_3_built = ModuleItem::ModuleItem3(module_item_3_built);
        // Calling user action here
        self.user_grammar.module_item(&module_item_3_built)?;
        self.push(ASTType::ModuleItem(module_item_3_built), context);
        Ok(())
    }

    /// Semantic action for production 309:
    ///
    /// ModuleItem: AlwaysCombDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn module_item_4(
        &mut self,
        _always_comb_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let always_comb_declaration = pop_item!(
            self,
            always_comb_declaration,
            AlwaysCombDeclaration,
            context
        );
        let module_item_4_built = ModuleItem4Builder::default()
            .always_comb_declaration(Box::new(always_comb_declaration))
            .build()
            .into_diagnostic()?;
        let module_item_4_built = ModuleItem::ModuleItem4(module_item_4_built);
        // Calling user action here
        self.user_grammar.module_item(&module_item_4_built)?;
        self.push(ASTType::ModuleItem(module_item_4_built), context);
        Ok(())
    }

    /// Semantic action for production 310:
    ///
    /// ModuleItem: AssignDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn module_item_5(
        &mut self,
        _assign_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let assign_declaration = pop_item!(self, assign_declaration, AssignDeclaration, context);
        let module_item_5_built = ModuleItem5Builder::default()
            .assign_declaration(Box::new(assign_declaration))
            .build()
            .into_diagnostic()?;
        let module_item_5_built = ModuleItem::ModuleItem5(module_item_5_built);
        // Calling user action here
        self.user_grammar.module_item(&module_item_5_built)?;
        self.push(ASTType::ModuleItem(module_item_5_built), context);
        Ok(())
    }

    /// Semantic action for production 311:
    ///
    /// InterfaceDeclaration: Interface Identifier InterfaceDeclarationOpt /* Option */ LBrace InterfaceDeclarationList /* Vec */ RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn interface_declaration(
        &mut self,
        _interface: &ParseTreeStackEntry<'t>,
        _identifier: &ParseTreeStackEntry<'t>,
        _interface_declaration_opt: &ParseTreeStackEntry<'t>,
        _l_brace: &ParseTreeStackEntry<'t>,
        _interface_declaration_list: &ParseTreeStackEntry<'t>,
        _r_brace: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let interface_declaration_list = pop_and_reverse_item!(
            self,
            interface_declaration_list,
            InterfaceDeclarationList,
            context
        );
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let interface_declaration_opt = pop_item!(
            self,
            interface_declaration_opt,
            InterfaceDeclarationOpt,
            context
        );
        let identifier = pop_item!(self, identifier, Identifier, context);
        let interface = pop_item!(self, interface, Interface, context);
        let interface_declaration_built = InterfaceDeclarationBuilder::default()
            .interface(Box::new(interface))
            .identifier(Box::new(identifier))
            .interface_declaration_opt(interface_declaration_opt)
            .l_brace(Box::new(l_brace))
            .interface_declaration_list(interface_declaration_list)
            .r_brace(Box::new(r_brace))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .interface_declaration(&interface_declaration_built)?;
        self.push(
            ASTType::InterfaceDeclaration(interface_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 312:
    ///
    /// InterfaceDeclarationList /* Vec<T>::Push */: InterfaceItem InterfaceDeclarationList;
    ///
    #[parol_runtime::function_name::named]
    fn interface_declaration_list_0(
        &mut self,
        _interface_item: &ParseTreeStackEntry<'t>,
        _interface_declaration_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut interface_declaration_list = pop_item!(
            self,
            interface_declaration_list,
            InterfaceDeclarationList,
            context
        );
        let interface_item = pop_item!(self, interface_item, InterfaceItem, context);
        let interface_declaration_list_0_built = InterfaceDeclarationListBuilder::default()
            .interface_item(Box::new(interface_item))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        interface_declaration_list.push(interface_declaration_list_0_built);
        self.push(
            ASTType::InterfaceDeclarationList(interface_declaration_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 313:
    ///
    /// InterfaceDeclarationList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn interface_declaration_list_1(
        &mut self,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let interface_declaration_list_1_built = Vec::new();
        self.push(
            ASTType::InterfaceDeclarationList(interface_declaration_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 314:
    ///
    /// InterfaceDeclarationOpt /* Option<T>::Some */: WithParameter;
    ///
    #[parol_runtime::function_name::named]
    fn interface_declaration_opt_0(
        &mut self,
        _with_parameter: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let with_parameter = pop_item!(self, with_parameter, WithParameter, context);
        let interface_declaration_opt_0_built = InterfaceDeclarationOptBuilder::default()
            .with_parameter(Box::new(with_parameter))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::InterfaceDeclarationOpt(Some(Box::new(interface_declaration_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 315:
    ///
    /// InterfaceDeclarationOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn interface_declaration_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::InterfaceDeclarationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 316:
    ///
    /// InterfaceItem: VariableDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn interface_item_0(
        &mut self,
        _variable_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let variable_declaration =
            pop_item!(self, variable_declaration, VariableDeclaration, context);
        let interface_item_0_built = InterfaceItem0Builder::default()
            .variable_declaration(Box::new(variable_declaration))
            .build()
            .into_diagnostic()?;
        let interface_item_0_built = InterfaceItem::InterfaceItem0(interface_item_0_built);
        // Calling user action here
        self.user_grammar.interface_item(&interface_item_0_built)?;
        self.push(ASTType::InterfaceItem(interface_item_0_built), context);
        Ok(())
    }

    /// Semantic action for production 317:
    ///
    /// InterfaceItem: ParameterDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn interface_item_1(
        &mut self,
        _parameter_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let parameter_declaration =
            pop_item!(self, parameter_declaration, ParameterDeclaration, context);
        let interface_item_1_built = InterfaceItem1Builder::default()
            .parameter_declaration(Box::new(parameter_declaration))
            .build()
            .into_diagnostic()?;
        let interface_item_1_built = InterfaceItem::InterfaceItem1(interface_item_1_built);
        // Calling user action here
        self.user_grammar.interface_item(&interface_item_1_built)?;
        self.push(ASTType::InterfaceItem(interface_item_1_built), context);
        Ok(())
    }

    /// Semantic action for production 318:
    ///
    /// InterfaceItem: LocalparamDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn interface_item_2(
        &mut self,
        _localparam_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let localparam_declaration =
            pop_item!(self, localparam_declaration, LocalparamDeclaration, context);
        let interface_item_2_built = InterfaceItem2Builder::default()
            .localparam_declaration(Box::new(localparam_declaration))
            .build()
            .into_diagnostic()?;
        let interface_item_2_built = InterfaceItem::InterfaceItem2(interface_item_2_built);
        // Calling user action here
        self.user_grammar.interface_item(&interface_item_2_built)?;
        self.push(ASTType::InterfaceItem(interface_item_2_built), context);
        Ok(())
    }

    /// Semantic action for production 319:
    ///
    /// InterfaceItem: ModportDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn interface_item_3(
        &mut self,
        _modport_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let modport_declaration = pop_item!(self, modport_declaration, ModportDeclaration, context);
        let interface_item_3_built = InterfaceItem3Builder::default()
            .modport_declaration(Box::new(modport_declaration))
            .build()
            .into_diagnostic()?;
        let interface_item_3_built = InterfaceItem::InterfaceItem3(interface_item_3_built);
        // Calling user action here
        self.user_grammar.interface_item(&interface_item_3_built)?;
        self.push(ASTType::InterfaceItem(interface_item_3_built), context);
        Ok(())
    }

    /// Semantic action for production 320:
    ///
    /// VariableDeclaration: Identifier Colon Type Semicolon;
    ///
    #[parol_runtime::function_name::named]
    fn variable_declaration(
        &mut self,
        _identifier: &ParseTreeStackEntry<'t>,
        _colon: &ParseTreeStackEntry<'t>,
        _type: &ParseTreeStackEntry<'t>,
        _semicolon: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon = pop_item!(self, semicolon, Semicolon, context);
        let r#type = pop_item!(self, r#type, Type, context);
        let colon = pop_item!(self, colon, Colon, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let variable_declaration_built = VariableDeclarationBuilder::default()
            .identifier(Box::new(identifier))
            .colon(Box::new(colon))
            .r#type(Box::new(r#type))
            .semicolon(Box::new(semicolon))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .variable_declaration(&variable_declaration_built)?;
        self.push(
            ASTType::VariableDeclaration(variable_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 321:
    ///
    /// ParameterDeclaration: Parameter Identifier Colon Type Equ Expression Semicolon;
    ///
    #[parol_runtime::function_name::named]
    fn parameter_declaration(
        &mut self,
        _parameter: &ParseTreeStackEntry<'t>,
        _identifier: &ParseTreeStackEntry<'t>,
        _colon: &ParseTreeStackEntry<'t>,
        _type: &ParseTreeStackEntry<'t>,
        _equ: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _semicolon: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon = pop_item!(self, semicolon, Semicolon, context);
        let expression = pop_item!(self, expression, Expression, context);
        let equ = pop_item!(self, equ, Equ, context);
        let r#type = pop_item!(self, r#type, Type, context);
        let colon = pop_item!(self, colon, Colon, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let parameter = pop_item!(self, parameter, Parameter, context);
        let parameter_declaration_built = ParameterDeclarationBuilder::default()
            .parameter(Box::new(parameter))
            .identifier(Box::new(identifier))
            .colon(Box::new(colon))
            .r#type(Box::new(r#type))
            .equ(Box::new(equ))
            .expression(Box::new(expression))
            .semicolon(Box::new(semicolon))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .parameter_declaration(&parameter_declaration_built)?;
        self.push(
            ASTType::ParameterDeclaration(parameter_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 322:
    ///
    /// LocalparamDeclaration: Localparam Identifier Colon Type Equ Expression Semicolon;
    ///
    #[parol_runtime::function_name::named]
    fn localparam_declaration(
        &mut self,
        _localparam: &ParseTreeStackEntry<'t>,
        _identifier: &ParseTreeStackEntry<'t>,
        _colon: &ParseTreeStackEntry<'t>,
        _type: &ParseTreeStackEntry<'t>,
        _equ: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _semicolon: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon = pop_item!(self, semicolon, Semicolon, context);
        let expression = pop_item!(self, expression, Expression, context);
        let equ = pop_item!(self, equ, Equ, context);
        let r#type = pop_item!(self, r#type, Type, context);
        let colon = pop_item!(self, colon, Colon, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let localparam = pop_item!(self, localparam, Localparam, context);
        let localparam_declaration_built = LocalparamDeclarationBuilder::default()
            .localparam(Box::new(localparam))
            .identifier(Box::new(identifier))
            .colon(Box::new(colon))
            .r#type(Box::new(r#type))
            .equ(Box::new(equ))
            .expression(Box::new(expression))
            .semicolon(Box::new(semicolon))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .localparam_declaration(&localparam_declaration_built)?;
        self.push(
            ASTType::LocalparamDeclaration(localparam_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 323:
    ///
    /// AlwaysFfDeclaration: AlwaysFf LParen AlwaysFfConditions RParen LBrace AlwaysFfDeclarationList /* Vec */ RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_declaration(
        &mut self,
        _always_ff: &ParseTreeStackEntry<'t>,
        _l_paren: &ParseTreeStackEntry<'t>,
        _always_ff_conditions: &ParseTreeStackEntry<'t>,
        _r_paren: &ParseTreeStackEntry<'t>,
        _l_brace: &ParseTreeStackEntry<'t>,
        _always_ff_declaration_list: &ParseTreeStackEntry<'t>,
        _r_brace: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let always_ff_declaration_list = pop_and_reverse_item!(
            self,
            always_ff_declaration_list,
            AlwaysFfDeclarationList,
            context
        );
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let r_paren = pop_item!(self, r_paren, RParen, context);
        let always_ff_conditions =
            pop_item!(self, always_ff_conditions, AlwaysFfConditions, context);
        let l_paren = pop_item!(self, l_paren, LParen, context);
        let always_ff = pop_item!(self, always_ff, AlwaysFf, context);
        let always_ff_declaration_built = AlwaysFfDeclarationBuilder::default()
            .always_ff(Box::new(always_ff))
            .l_paren(Box::new(l_paren))
            .always_ff_conditions(Box::new(always_ff_conditions))
            .r_paren(Box::new(r_paren))
            .l_brace(Box::new(l_brace))
            .always_ff_declaration_list(always_ff_declaration_list)
            .r_brace(Box::new(r_brace))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .always_ff_declaration(&always_ff_declaration_built)?;
        self.push(
            ASTType::AlwaysFfDeclaration(always_ff_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 324:
    ///
    /// AlwaysFfDeclarationList /* Vec<T>::Push */: Statement AlwaysFfDeclarationList;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_declaration_list_0(
        &mut self,
        _statement: &ParseTreeStackEntry<'t>,
        _always_ff_declaration_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut always_ff_declaration_list = pop_item!(
            self,
            always_ff_declaration_list,
            AlwaysFfDeclarationList,
            context
        );
        let statement = pop_item!(self, statement, Statement, context);
        let always_ff_declaration_list_0_built = AlwaysFfDeclarationListBuilder::default()
            .statement(Box::new(statement))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        always_ff_declaration_list.push(always_ff_declaration_list_0_built);
        self.push(
            ASTType::AlwaysFfDeclarationList(always_ff_declaration_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 325:
    ///
    /// AlwaysFfDeclarationList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_declaration_list_1(
        &mut self,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let always_ff_declaration_list_1_built = Vec::new();
        self.push(
            ASTType::AlwaysFfDeclarationList(always_ff_declaration_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 326:
    ///
    /// AlwaysFfConditions: AlwaysFfCondition AlwaysFfConditionsList /* Vec */ AlwaysFfConditionsOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_conditions(
        &mut self,
        _always_ff_condition: &ParseTreeStackEntry<'t>,
        _always_ff_conditions_list: &ParseTreeStackEntry<'t>,
        _always_ff_conditions_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let always_ff_conditions_opt = pop_item!(
            self,
            always_ff_conditions_opt,
            AlwaysFfConditionsOpt,
            context
        );
        let always_ff_conditions_list = pop_and_reverse_item!(
            self,
            always_ff_conditions_list,
            AlwaysFfConditionsList,
            context
        );
        let always_ff_condition = pop_item!(self, always_ff_condition, AlwaysFfCondition, context);
        let always_ff_conditions_built = AlwaysFfConditionsBuilder::default()
            .always_ff_condition(Box::new(always_ff_condition))
            .always_ff_conditions_list(always_ff_conditions_list)
            .always_ff_conditions_opt(always_ff_conditions_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .always_ff_conditions(&always_ff_conditions_built)?;
        self.push(
            ASTType::AlwaysFfConditions(always_ff_conditions_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 327:
    ///
    /// AlwaysFfConditionsList /* Vec<T>::Push */: Comma AlwaysFfCondition AlwaysFfConditionsList;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_conditions_list_0(
        &mut self,
        _comma: &ParseTreeStackEntry<'t>,
        _always_ff_condition: &ParseTreeStackEntry<'t>,
        _always_ff_conditions_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut always_ff_conditions_list = pop_item!(
            self,
            always_ff_conditions_list,
            AlwaysFfConditionsList,
            context
        );
        let always_ff_condition = pop_item!(self, always_ff_condition, AlwaysFfCondition, context);
        let comma = pop_item!(self, comma, Comma, context);
        let always_ff_conditions_list_0_built = AlwaysFfConditionsListBuilder::default()
            .always_ff_condition(Box::new(always_ff_condition))
            .comma(Box::new(comma))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        always_ff_conditions_list.push(always_ff_conditions_list_0_built);
        self.push(
            ASTType::AlwaysFfConditionsList(always_ff_conditions_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 328:
    ///
    /// AlwaysFfConditionsList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_conditions_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let always_ff_conditions_list_1_built = Vec::new();
        self.push(
            ASTType::AlwaysFfConditionsList(always_ff_conditions_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 329:
    ///
    /// AlwaysFfConditionsOpt /* Option<T>::Some */: Comma;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_conditions_opt_0(
        &mut self,
        _comma: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = pop_item!(self, comma, Comma, context);
        let always_ff_conditions_opt_0_built = AlwaysFfConditionsOptBuilder::default()
            .comma(Box::new(comma))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::AlwaysFfConditionsOpt(Some(Box::new(always_ff_conditions_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 330:
    ///
    /// AlwaysFfConditionsOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_conditions_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::AlwaysFfConditionsOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 331:
    ///
    /// AlwaysFfCondition: AlwaysFfConditionGroup Identifier;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_condition(
        &mut self,
        _always_ff_condition_group: &ParseTreeStackEntry<'t>,
        _identifier: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let identifier = pop_item!(self, identifier, Identifier, context);
        let always_ff_condition_group = pop_item!(
            self,
            always_ff_condition_group,
            AlwaysFfConditionGroup,
            context
        );
        let always_ff_condition_built = AlwaysFfConditionBuilder::default()
            .always_ff_condition_group(Box::new(always_ff_condition_group))
            .identifier(Box::new(identifier))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .always_ff_condition(&always_ff_condition_built)?;
        self.push(
            ASTType::AlwaysFfCondition(always_ff_condition_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 332:
    ///
    /// AlwaysFfConditionGroup: Posedge;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_condition_group_0(
        &mut self,
        _posedge: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let posedge = pop_item!(self, posedge, Posedge, context);
        let always_ff_condition_group_0_built = AlwaysFfConditionGroup0Builder::default()
            .posedge(Box::new(posedge))
            .build()
            .into_diagnostic()?;
        let always_ff_condition_group_0_built =
            AlwaysFfConditionGroup::AlwaysFfConditionGroup0(always_ff_condition_group_0_built);
        self.push(
            ASTType::AlwaysFfConditionGroup(always_ff_condition_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 333:
    ///
    /// AlwaysFfConditionGroup: Negedge;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_condition_group_1(
        &mut self,
        _negedge: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let negedge = pop_item!(self, negedge, Negedge, context);
        let always_ff_condition_group_1_built = AlwaysFfConditionGroup1Builder::default()
            .negedge(Box::new(negedge))
            .build()
            .into_diagnostic()?;
        let always_ff_condition_group_1_built =
            AlwaysFfConditionGroup::AlwaysFfConditionGroup1(always_ff_condition_group_1_built);
        self.push(
            ASTType::AlwaysFfConditionGroup(always_ff_condition_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 334:
    ///
    /// AlwaysCombDeclaration: AlwaysComb LBrace AlwaysCombDeclarationList /* Vec */ RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn always_comb_declaration(
        &mut self,
        _always_comb: &ParseTreeStackEntry<'t>,
        _l_brace: &ParseTreeStackEntry<'t>,
        _always_comb_declaration_list: &ParseTreeStackEntry<'t>,
        _r_brace: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let always_comb_declaration_list = pop_and_reverse_item!(
            self,
            always_comb_declaration_list,
            AlwaysCombDeclarationList,
            context
        );
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let always_comb = pop_item!(self, always_comb, AlwaysComb, context);
        let always_comb_declaration_built = AlwaysCombDeclarationBuilder::default()
            .always_comb(Box::new(always_comb))
            .l_brace(Box::new(l_brace))
            .always_comb_declaration_list(always_comb_declaration_list)
            .r_brace(Box::new(r_brace))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .always_comb_declaration(&always_comb_declaration_built)?;
        self.push(
            ASTType::AlwaysCombDeclaration(always_comb_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 335:
    ///
    /// AlwaysCombDeclarationList /* Vec<T>::Push */: Statement AlwaysCombDeclarationList;
    ///
    #[parol_runtime::function_name::named]
    fn always_comb_declaration_list_0(
        &mut self,
        _statement: &ParseTreeStackEntry<'t>,
        _always_comb_declaration_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut always_comb_declaration_list = pop_item!(
            self,
            always_comb_declaration_list,
            AlwaysCombDeclarationList,
            context
        );
        let statement = pop_item!(self, statement, Statement, context);
        let always_comb_declaration_list_0_built = AlwaysCombDeclarationListBuilder::default()
            .statement(Box::new(statement))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        always_comb_declaration_list.push(always_comb_declaration_list_0_built);
        self.push(
            ASTType::AlwaysCombDeclarationList(always_comb_declaration_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 336:
    ///
    /// AlwaysCombDeclarationList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn always_comb_declaration_list_1(
        &mut self,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let always_comb_declaration_list_1_built = Vec::new();
        self.push(
            ASTType::AlwaysCombDeclarationList(always_comb_declaration_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 337:
    ///
    /// AssignDeclaration: Assign Identifier AssignDeclarationOpt /* Option */ Equ Expression Semicolon;
    ///
    #[parol_runtime::function_name::named]
    fn assign_declaration(
        &mut self,
        _assign: &ParseTreeStackEntry<'t>,
        _identifier: &ParseTreeStackEntry<'t>,
        _assign_declaration_opt: &ParseTreeStackEntry<'t>,
        _equ: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _semicolon: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon = pop_item!(self, semicolon, Semicolon, context);
        let expression = pop_item!(self, expression, Expression, context);
        let equ = pop_item!(self, equ, Equ, context);
        let assign_declaration_opt =
            pop_item!(self, assign_declaration_opt, AssignDeclarationOpt, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let assign = pop_item!(self, assign, Assign, context);
        let assign_declaration_built = AssignDeclarationBuilder::default()
            .assign(Box::new(assign))
            .identifier(Box::new(identifier))
            .assign_declaration_opt(assign_declaration_opt)
            .equ(Box::new(equ))
            .expression(Box::new(expression))
            .semicolon(Box::new(semicolon))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .assign_declaration(&assign_declaration_built)?;
        self.push(
            ASTType::AssignDeclaration(assign_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 338:
    ///
    /// AssignDeclarationOpt /* Option<T>::Some */: Colon Type;
    ///
    #[parol_runtime::function_name::named]
    fn assign_declaration_opt_0(
        &mut self,
        _colon: &ParseTreeStackEntry<'t>,
        _type: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#type = pop_item!(self, r#type, Type, context);
        let colon = pop_item!(self, colon, Colon, context);
        let assign_declaration_opt_0_built = AssignDeclarationOptBuilder::default()
            .colon(Box::new(colon))
            .r#type(Box::new(r#type))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::AssignDeclarationOpt(Some(Box::new(assign_declaration_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 339:
    ///
    /// AssignDeclarationOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn assign_declaration_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::AssignDeclarationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 340:
    ///
    /// ModportDeclaration: Modport Identifier LBrace ModportList RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn modport_declaration(
        &mut self,
        _modport: &ParseTreeStackEntry<'t>,
        _identifier: &ParseTreeStackEntry<'t>,
        _l_brace: &ParseTreeStackEntry<'t>,
        _modport_list: &ParseTreeStackEntry<'t>,
        _r_brace: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let modport_list = pop_item!(self, modport_list, ModportList, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let modport = pop_item!(self, modport, Modport, context);
        let modport_declaration_built = ModportDeclarationBuilder::default()
            .modport(Box::new(modport))
            .identifier(Box::new(identifier))
            .l_brace(Box::new(l_brace))
            .modport_list(Box::new(modport_list))
            .r_brace(Box::new(r_brace))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .modport_declaration(&modport_declaration_built)?;
        self.push(
            ASTType::ModportDeclaration(modport_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 341:
    ///
    /// ModportList: ModportItem ModportListList /* Vec */ ModportListOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn modport_list(
        &mut self,
        _modport_item: &ParseTreeStackEntry<'t>,
        _modport_list_list: &ParseTreeStackEntry<'t>,
        _modport_list_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let modport_list_opt = pop_item!(self, modport_list_opt, ModportListOpt, context);
        let modport_list_list =
            pop_and_reverse_item!(self, modport_list_list, ModportListList, context);
        let modport_item = pop_item!(self, modport_item, ModportItem, context);
        let modport_list_built = ModportListBuilder::default()
            .modport_item(Box::new(modport_item))
            .modport_list_list(modport_list_list)
            .modport_list_opt(modport_list_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.modport_list(&modport_list_built)?;
        self.push(ASTType::ModportList(modport_list_built), context);
        Ok(())
    }

    /// Semantic action for production 342:
    ///
    /// ModportListList /* Vec<T>::Push */: Comma ModportItem ModportListList;
    ///
    #[parol_runtime::function_name::named]
    fn modport_list_list_0(
        &mut self,
        _comma: &ParseTreeStackEntry<'t>,
        _modport_item: &ParseTreeStackEntry<'t>,
        _modport_list_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut modport_list_list = pop_item!(self, modport_list_list, ModportListList, context);
        let modport_item = pop_item!(self, modport_item, ModportItem, context);
        let comma = pop_item!(self, comma, Comma, context);
        let modport_list_list_0_built = ModportListListBuilder::default()
            .modport_item(Box::new(modport_item))
            .comma(Box::new(comma))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        modport_list_list.push(modport_list_list_0_built);
        self.push(ASTType::ModportListList(modport_list_list), context);
        Ok(())
    }

    /// Semantic action for production 343:
    ///
    /// ModportListList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn modport_list_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let modport_list_list_1_built = Vec::new();
        self.push(ASTType::ModportListList(modport_list_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 344:
    ///
    /// ModportListOpt /* Option<T>::Some */: Comma;
    ///
    #[parol_runtime::function_name::named]
    fn modport_list_opt_0(
        &mut self,
        _comma: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = pop_item!(self, comma, Comma, context);
        let modport_list_opt_0_built = ModportListOptBuilder::default()
            .comma(Box::new(comma))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::ModportListOpt(Some(Box::new(modport_list_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 345:
    ///
    /// ModportListOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn modport_list_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ModportListOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 346:
    ///
    /// ModportItem: Identifier Colon Direction;
    ///
    #[parol_runtime::function_name::named]
    fn modport_item(
        &mut self,
        _identifier: &ParseTreeStackEntry<'t>,
        _colon: &ParseTreeStackEntry<'t>,
        _direction: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let direction = pop_item!(self, direction, Direction, context);
        let colon = pop_item!(self, colon, Colon, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let modport_item_built = ModportItemBuilder::default()
            .identifier(Box::new(identifier))
            .colon(Box::new(colon))
            .direction(Box::new(direction))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.modport_item(&modport_item_built)?;
        self.push(ASTType::ModportItem(modport_item_built), context);
        Ok(())
    }
}

impl<'t> UserActionsTrait<'t> for VerylGrammarAuto<'t, '_> {
    ///
    /// This function is implemented automatically for the user's item VerylGrammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeStackEntry<'t>],
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        match prod_num {
            0 => self.multi_comment(&children[0], parse_tree),
            1 => self.comments(&children[0], parse_tree),
            2 => self.comments_opt_0(&children[0], parse_tree),
            3 => self.comments_opt_1(parse_tree),
            4 => self.start_token(&children[0], parse_tree),
            5 => self.start(&children[0], parse_tree),
            6 => self.exponent_token(&children[0], &children[1], parse_tree),
            7 => self.fixed_point_token(&children[0], &children[1], parse_tree),
            8 => self.based_binary_token(&children[0], &children[1], parse_tree),
            9 => self.based_octal_token(&children[0], &children[1], parse_tree),
            10 => self.based_decimal_token(&children[0], &children[1], parse_tree),
            11 => self.based_hex_token(&children[0], &children[1], parse_tree),
            12 => self.base_less_token(&children[0], &children[1], parse_tree),
            13 => self.all_bit_token(&children[0], &children[1], parse_tree),
            14 => self.exponent(&children[0], parse_tree),
            15 => self.fixed_point(&children[0], parse_tree),
            16 => self.based_binary(&children[0], parse_tree),
            17 => self.based_octal(&children[0], parse_tree),
            18 => self.based_decimal(&children[0], parse_tree),
            19 => self.based_hex(&children[0], parse_tree),
            20 => self.base_less(&children[0], parse_tree),
            21 => self.all_bit(&children[0], parse_tree),
            22 => self.bang_equ_equ_token(&children[0], &children[1], parse_tree),
            23 => self.bang_equ_quest_token(&children[0], &children[1], parse_tree),
            24 => self.equ_equ_equ_token(&children[0], &children[1], parse_tree),
            25 => self.equ_equ_quest_token(&children[0], &children[1], parse_tree),
            26 => self.g_t_g_t_g_t_token(&children[0], &children[1], parse_tree),
            27 => self.l_t_l_t_l_t_token(&children[0], &children[1], parse_tree),
            28 => self.bang_equ_equ(&children[0], parse_tree),
            29 => self.bang_equ_quest(&children[0], parse_tree),
            30 => self.equ_equ_equ(&children[0], parse_tree),
            31 => self.equ_equ_quest(&children[0], parse_tree),
            32 => self.g_t_g_t_g_t(&children[0], parse_tree),
            33 => self.l_t_l_t_l_t(&children[0], parse_tree),
            34 => self.amp_amp_token(&children[0], &children[1], parse_tree),
            35 => self.circumflex_tilde_token(&children[0], &children[1], parse_tree),
            36 => self.bang_equ_token(&children[0], &children[1], parse_tree),
            37 => self.equ_equ_token(&children[0], &children[1], parse_tree),
            38 => self.g_t_equ_token(&children[0], &children[1], parse_tree),
            39 => self.g_t_g_t_token(&children[0], &children[1], parse_tree),
            40 => self.l_t_equ_token(&children[0], &children[1], parse_tree),
            41 => self.l_t_l_t_token(&children[0], &children[1], parse_tree),
            42 => self.or_or_token(&children[0], &children[1], parse_tree),
            43 => self.star_star_token(&children[0], &children[1], parse_tree),
            44 => self.tilde_amp_token(&children[0], &children[1], parse_tree),
            45 => self.tilde_circumflex_token(&children[0], &children[1], parse_tree),
            46 => self.tilde_or_token(&children[0], &children[1], parse_tree),
            47 => self.amp_amp(&children[0], parse_tree),
            48 => self.circumflex_tilde(&children[0], parse_tree),
            49 => self.bang_equ(&children[0], parse_tree),
            50 => self.equ_equ(&children[0], parse_tree),
            51 => self.g_t_equ(&children[0], parse_tree),
            52 => self.g_t_g_t(&children[0], parse_tree),
            53 => self.l_t_equ(&children[0], parse_tree),
            54 => self.l_t_l_t(&children[0], parse_tree),
            55 => self.or_or(&children[0], parse_tree),
            56 => self.star_star(&children[0], parse_tree),
            57 => self.tilde_amp(&children[0], parse_tree),
            58 => self.tilde_circumflex(&children[0], parse_tree),
            59 => self.tilde_or(&children[0], parse_tree),
            60 => self.amp_token(&children[0], &children[1], parse_tree),
            61 => self.bang_token(&children[0], &children[1], parse_tree),
            62 => self.colon_token(&children[0], &children[1], parse_tree),
            63 => self.comma_token(&children[0], &children[1], parse_tree),
            64 => self.circumflex_token(&children[0], &children[1], parse_tree),
            65 => self.equ_token(&children[0], &children[1], parse_tree),
            66 => self.g_t_token(&children[0], &children[1], parse_tree),
            67 => self.hash_token(&children[0], &children[1], parse_tree),
            68 => self.l_brace_token(&children[0], &children[1], parse_tree),
            69 => self.l_bracket_token(&children[0], &children[1], parse_tree),
            70 => self.l_paren_token(&children[0], &children[1], parse_tree),
            71 => self.l_t_token(&children[0], &children[1], parse_tree),
            72 => self.minus_token(&children[0], &children[1], parse_tree),
            73 => self.or_token(&children[0], &children[1], parse_tree),
            74 => self.percent_token(&children[0], &children[1], parse_tree),
            75 => self.plus_token(&children[0], &children[1], parse_tree),
            76 => self.r_brace_token(&children[0], &children[1], parse_tree),
            77 => self.r_bracket_token(&children[0], &children[1], parse_tree),
            78 => self.r_paren_token(&children[0], &children[1], parse_tree),
            79 => self.semicolon_token(&children[0], &children[1], parse_tree),
            80 => self.slash_token(&children[0], &children[1], parse_tree),
            81 => self.star_token(&children[0], &children[1], parse_tree),
            82 => self.tilde_token(&children[0], &children[1], parse_tree),
            83 => self.amp(&children[0], parse_tree),
            84 => self.bang(&children[0], parse_tree),
            85 => self.circumflex(&children[0], parse_tree),
            86 => self.colon(&children[0], parse_tree),
            87 => self.comma(&children[0], parse_tree),
            88 => self.equ(&children[0], parse_tree),
            89 => self.g_t(&children[0], parse_tree),
            90 => self.hash(&children[0], parse_tree),
            91 => self.l_brace(&children[0], parse_tree),
            92 => self.l_bracket(&children[0], parse_tree),
            93 => self.l_paren(&children[0], parse_tree),
            94 => self.l_t(&children[0], parse_tree),
            95 => self.minus(&children[0], parse_tree),
            96 => self.or(&children[0], parse_tree),
            97 => self.percent(&children[0], parse_tree),
            98 => self.plus(&children[0], parse_tree),
            99 => self.r_brace(&children[0], parse_tree),
            100 => self.r_bracket(&children[0], parse_tree),
            101 => self.r_paren(&children[0], parse_tree),
            102 => self.semicolon(&children[0], parse_tree),
            103 => self.slash(&children[0], parse_tree),
            104 => self.star(&children[0], parse_tree),
            105 => self.tilde(&children[0], parse_tree),
            106 => self.always_comb_token(&children[0], &children[1], parse_tree),
            107 => self.always_ff_token(&children[0], &children[1], parse_tree),
            108 => self.assign_token(&children[0], &children[1], parse_tree),
            109 => self.bit_token(&children[0], &children[1], parse_tree),
            110 => self.else_token(&children[0], &children[1], parse_tree),
            111 => self.f32_token(&children[0], &children[1], parse_tree),
            112 => self.f64_token(&children[0], &children[1], parse_tree),
            113 => self.i32_token(&children[0], &children[1], parse_tree),
            114 => self.i64_token(&children[0], &children[1], parse_tree),
            115 => self.if_token(&children[0], &children[1], parse_tree),
            116 => self.inout_token(&children[0], &children[1], parse_tree),
            117 => self.input_token(&children[0], &children[1], parse_tree),
            118 => self.interface_token(&children[0], &children[1], parse_tree),
            119 => self.localparam_token(&children[0], &children[1], parse_tree),
            120 => self.logic_token(&children[0], &children[1], parse_tree),
            121 => self.modport_token(&children[0], &children[1], parse_tree),
            122 => self.module_token(&children[0], &children[1], parse_tree),
            123 => self.negedge_token(&children[0], &children[1], parse_tree),
            124 => self.output_token(&children[0], &children[1], parse_tree),
            125 => self.parameter_token(&children[0], &children[1], parse_tree),
            126 => self.posedge_token(&children[0], &children[1], parse_tree),
            127 => self.u32_token(&children[0], &children[1], parse_tree),
            128 => self.u64_token(&children[0], &children[1], parse_tree),
            129 => self.always_comb(&children[0], parse_tree),
            130 => self.always_ff(&children[0], parse_tree),
            131 => self.assign(&children[0], parse_tree),
            132 => self.bit(&children[0], parse_tree),
            133 => self.r#else(&children[0], parse_tree),
            134 => self.f32(&children[0], parse_tree),
            135 => self.f64(&children[0], parse_tree),
            136 => self.i32(&children[0], parse_tree),
            137 => self.i64(&children[0], parse_tree),
            138 => self.r#if(&children[0], parse_tree),
            139 => self.inout(&children[0], parse_tree),
            140 => self.input(&children[0], parse_tree),
            141 => self.interface(&children[0], parse_tree),
            142 => self.localparam(&children[0], parse_tree),
            143 => self.logic(&children[0], parse_tree),
            144 => self.modport(&children[0], parse_tree),
            145 => self.module(&children[0], parse_tree),
            146 => self.negedge(&children[0], parse_tree),
            147 => self.output(&children[0], parse_tree),
            148 => self.parameter(&children[0], parse_tree),
            149 => self.posedge(&children[0], parse_tree),
            150 => self.u32(&children[0], parse_tree),
            151 => self.u64(&children[0], parse_tree),
            152 => self.identifier_token(&children[0], &children[1], parse_tree),
            153 => self.identifier(&children[0], parse_tree),
            154 => self.veryl(&children[0], &children[1], parse_tree),
            155 => self.veryl_list_0(&children[0], &children[1], parse_tree),
            156 => self.veryl_list_1(parse_tree),
            157 => self.description_0(&children[0], parse_tree),
            158 => self.description_1(&children[0], parse_tree),
            159 => self.number_0(&children[0], parse_tree),
            160 => self.number_1(&children[0], parse_tree),
            161 => self.integral_number_0(&children[0], parse_tree),
            162 => self.integral_number_1(&children[0], parse_tree),
            163 => self.integral_number_2(&children[0], parse_tree),
            164 => self.integral_number_3(&children[0], parse_tree),
            165 => self.integral_number_4(&children[0], parse_tree),
            166 => self.integral_number_5(&children[0], parse_tree),
            167 => self.real_number_0(&children[0], parse_tree),
            168 => self.real_number_1(&children[0], parse_tree),
            169 => self.operator_precedence01(&children[0], parse_tree),
            170 => self.operator_precedence02(&children[0], parse_tree),
            171 => self.operator_precedence03(&children[0], parse_tree),
            172 => self.operator_precedence04_0(&children[0], parse_tree),
            173 => self.operator_precedence04_1(&children[0], parse_tree),
            174 => self.operator_precedence04_2(&children[0], parse_tree),
            175 => self.operator_precedence05(&children[0], parse_tree),
            176 => self.operator_precedence06_0(&children[0], parse_tree),
            177 => self.operator_precedence06_1(&children[0], parse_tree),
            178 => self.operator_precedence06_2(&children[0], parse_tree),
            179 => self.operator_precedence06_3(&children[0], parse_tree),
            180 => self.operator_precedence06_4(&children[0], parse_tree),
            181 => self.operator_precedence06_5(&children[0], parse_tree),
            182 => self.operator_precedence07_0(&children[0], parse_tree),
            183 => self.operator_precedence07_1(&children[0], parse_tree),
            184 => self.operator_precedence07_2(&children[0], parse_tree),
            185 => self.operator_precedence07_3(&children[0], parse_tree),
            186 => self.operator_precedence08_0(&children[0], parse_tree),
            187 => self.operator_precedence08_1(&children[0], parse_tree),
            188 => self.operator_precedence08_2(&children[0], parse_tree),
            189 => self.operator_precedence08_3(&children[0], parse_tree),
            190 => self.operator_precedence09_0(&children[0], parse_tree),
            191 => self.operator_precedence09_1(&children[0], parse_tree),
            192 => self.operator_precedence10_0(&children[0], parse_tree),
            193 => self.operator_precedence10_1(&children[0], parse_tree),
            194 => self.operator_precedence10_2(&children[0], parse_tree),
            195 => self.operator_precedence11(&children[0], parse_tree),
            196 => self.operator_precedence12_0(&children[0], parse_tree),
            197 => self.operator_precedence12_1(&children[0], parse_tree),
            198 => self.operator_precedence12_2(&children[0], parse_tree),
            199 => self.operator_precedence12_3(&children[0], parse_tree),
            200 => self.operator_precedence12_4(&children[0], parse_tree),
            201 => self.operator_precedence12_5(&children[0], parse_tree),
            202 => self.operator_precedence12_6(&children[0], parse_tree),
            203 => self.operator_precedence12_7(&children[0], parse_tree),
            204 => self.operator_precedence12_8(&children[0], parse_tree),
            205 => self.operator_precedence12_9(&children[0], parse_tree),
            206 => self.operator_precedence12_10(&children[0], parse_tree),
            207 => self.expression(&children[0], parse_tree),
            208 => self.expression00(&children[0], &children[1], parse_tree),
            209 => self.expression00_list_0(&children[0], &children[1], &children[2], parse_tree),
            210 => self.expression00_list_1(parse_tree),
            211 => self.expression01(&children[0], &children[1], parse_tree),
            212 => self.expression01_list_0(&children[0], &children[1], &children[2], parse_tree),
            213 => self.expression01_list_1(parse_tree),
            214 => self.expression02(&children[0], &children[1], parse_tree),
            215 => self.expression02_list_0(&children[0], &children[1], &children[2], parse_tree),
            216 => self.expression02_list_1(parse_tree),
            217 => self.expression03(&children[0], &children[1], parse_tree),
            218 => self.expression03_list_0(&children[0], &children[1], &children[2], parse_tree),
            219 => self.expression03_list_1(parse_tree),
            220 => self.expression04(&children[0], &children[1], parse_tree),
            221 => self.expression04_list_0(&children[0], &children[1], &children[2], parse_tree),
            222 => self.expression04_list_1(parse_tree),
            223 => self.expression05(&children[0], &children[1], parse_tree),
            224 => self.expression05_list_0(&children[0], &children[1], &children[2], parse_tree),
            225 => self.expression05_list_1(parse_tree),
            226 => self.expression06(&children[0], &children[1], parse_tree),
            227 => self.expression06_list_0(&children[0], &children[1], &children[2], parse_tree),
            228 => self.expression06_list_1(parse_tree),
            229 => self.expression07(&children[0], &children[1], parse_tree),
            230 => self.expression07_list_0(&children[0], &children[1], &children[2], parse_tree),
            231 => self.expression07_list_1(parse_tree),
            232 => self.expression08(&children[0], &children[1], parse_tree),
            233 => self.expression08_list_0(&children[0], &children[1], &children[2], parse_tree),
            234 => self.expression08_list_1(parse_tree),
            235 => self.expression09(&children[0], &children[1], parse_tree),
            236 => self.expression09_list_0(&children[0], &children[1], &children[2], parse_tree),
            237 => self.expression09_list_1(parse_tree),
            238 => self.expression10(&children[0], &children[1], parse_tree),
            239 => self.expression10_list_0(&children[0], &children[1], &children[2], parse_tree),
            240 => self.expression10_list_1(parse_tree),
            241 => self.expression11(&children[0], &children[1], parse_tree),
            242 => self.expression11_opt_0(&children[0], parse_tree),
            243 => self.expression11_opt_1(parse_tree),
            244 => self.expression12(&children[0], parse_tree),
            245 => self.factor_0(&children[0], parse_tree),
            246 => self.factor_1(&children[0], &children[1], parse_tree),
            247 => self.factor_list_0(&children[0], &children[1], parse_tree),
            248 => self.factor_list_1(parse_tree),
            249 => self.factor_2(&children[0], &children[1], &children[2], parse_tree),
            250 => self.statement_0(&children[0], parse_tree),
            251 => self.statement_1(&children[0], parse_tree),
            252 => self.assignment_statement(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            253 => self.if_statement(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
                parse_tree,
            ),
            254 => self.if_statement_list_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
                parse_tree,
            ),
            255 => self.if_statement_list_1(parse_tree),
            256 => self.if_statement_opt_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            257 => self.if_statement_opt_1(parse_tree),
            258 => self.range(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            259 => self.range_opt_0(&children[0], &children[1], parse_tree),
            260 => self.range_opt_1(parse_tree),
            261 => self.width(&children[0], &children[1], &children[2], parse_tree),
            262 => self.builtin_type_0(&children[0], parse_tree),
            263 => self.builtin_type_1(&children[0], parse_tree),
            264 => self.builtin_type_2(&children[0], parse_tree),
            265 => self.builtin_type_3(&children[0], parse_tree),
            266 => self.builtin_type_4(&children[0], parse_tree),
            267 => self.builtin_type_5(&children[0], parse_tree),
            268 => self.builtin_type_6(&children[0], parse_tree),
            269 => self.builtin_type_7(&children[0], parse_tree),
            270 => self.r#type(&children[0], &children[1], parse_tree),
            271 => self.type_group_0(&children[0], parse_tree),
            272 => self.type_group_1(&children[0], parse_tree),
            273 => self.type_list_0(&children[0], &children[1], parse_tree),
            274 => self.type_list_1(parse_tree),
            275 => self.with_parameter(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            276 => self.with_parameter_opt_0(&children[0], parse_tree),
            277 => self.with_parameter_opt_1(parse_tree),
            278 => self.with_parameter_list(&children[0], &children[1], &children[2], parse_tree),
            279 => self.with_parameter_list_list_0(
                &children[0],
                &children[1],
                &children[2],
                parse_tree,
            ),
            280 => self.with_parameter_list_list_1(parse_tree),
            281 => self.with_parameter_list_opt_0(&children[0], parse_tree),
            282 => self.with_parameter_list_opt_1(parse_tree),
            283 => self.with_parameter_item(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                parse_tree,
            ),
            284 => self.with_parameter_item_group_0(&children[0], parse_tree),
            285 => self.with_parameter_item_group_1(&children[0], parse_tree),
            286 => self.module_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
                parse_tree,
            ),
            287 => self.module_declaration_list_0(&children[0], &children[1], parse_tree),
            288 => self.module_declaration_list_1(parse_tree),
            289 => self.module_declaration_opt0_0(&children[0], parse_tree),
            290 => self.module_declaration_opt0_1(parse_tree),
            291 => self.module_declaration_opt_0(&children[0], parse_tree),
            292 => self.module_declaration_opt_1(parse_tree),
            293 => self.module_port(&children[0], &children[1], &children[2], parse_tree),
            294 => self.module_port_opt_0(&children[0], parse_tree),
            295 => self.module_port_opt_1(parse_tree),
            296 => self.module_port_list(&children[0], &children[1], &children[2], parse_tree),
            297 => {
                self.module_port_list_list_0(&children[0], &children[1], &children[2], parse_tree)
            }
            298 => self.module_port_list_list_1(parse_tree),
            299 => self.module_port_list_opt_0(&children[0], parse_tree),
            300 => self.module_port_list_opt_1(parse_tree),
            301 => self.module_port_item(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            302 => self.direction_0(&children[0], parse_tree),
            303 => self.direction_1(&children[0], parse_tree),
            304 => self.direction_2(&children[0], parse_tree),
            305 => self.module_item_0(&children[0], parse_tree),
            306 => self.module_item_1(&children[0], parse_tree),
            307 => self.module_item_2(&children[0], parse_tree),
            308 => self.module_item_3(&children[0], parse_tree),
            309 => self.module_item_4(&children[0], parse_tree),
            310 => self.module_item_5(&children[0], parse_tree),
            311 => self.interface_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                parse_tree,
            ),
            312 => self.interface_declaration_list_0(&children[0], &children[1], parse_tree),
            313 => self.interface_declaration_list_1(parse_tree),
            314 => self.interface_declaration_opt_0(&children[0], parse_tree),
            315 => self.interface_declaration_opt_1(parse_tree),
            316 => self.interface_item_0(&children[0], parse_tree),
            317 => self.interface_item_1(&children[0], parse_tree),
            318 => self.interface_item_2(&children[0], parse_tree),
            319 => self.interface_item_3(&children[0], parse_tree),
            320 => self.variable_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            321 => self.parameter_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
                parse_tree,
            ),
            322 => self.localparam_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
                parse_tree,
            ),
            323 => self.always_ff_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
                parse_tree,
            ),
            324 => self.always_ff_declaration_list_0(&children[0], &children[1], parse_tree),
            325 => self.always_ff_declaration_list_1(parse_tree),
            326 => self.always_ff_conditions(&children[0], &children[1], &children[2], parse_tree),
            327 => self.always_ff_conditions_list_0(
                &children[0],
                &children[1],
                &children[2],
                parse_tree,
            ),
            328 => self.always_ff_conditions_list_1(parse_tree),
            329 => self.always_ff_conditions_opt_0(&children[0], parse_tree),
            330 => self.always_ff_conditions_opt_1(parse_tree),
            331 => self.always_ff_condition(&children[0], &children[1], parse_tree),
            332 => self.always_ff_condition_group_0(&children[0], parse_tree),
            333 => self.always_ff_condition_group_1(&children[0], parse_tree),
            334 => self.always_comb_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            335 => self.always_comb_declaration_list_0(&children[0], &children[1], parse_tree),
            336 => self.always_comb_declaration_list_1(parse_tree),
            337 => self.assign_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                parse_tree,
            ),
            338 => self.assign_declaration_opt_0(&children[0], &children[1], parse_tree),
            339 => self.assign_declaration_opt_1(parse_tree),
            340 => self.modport_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                parse_tree,
            ),
            341 => self.modport_list(&children[0], &children[1], &children[2], parse_tree),
            342 => self.modport_list_list_0(&children[0], &children[1], &children[2], parse_tree),
            343 => self.modport_list_list_1(parse_tree),
            344 => self.modport_list_opt_0(&children[0], parse_tree),
            345 => self.modport_list_opt_1(parse_tree),
            346 => self.modport_item(&children[0], &children[1], &children[2], parse_tree),
            _ => Err(miette!("Unhandled production number: {}", prod_num)),
        }
    }
}
