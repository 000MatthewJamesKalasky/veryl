// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

// Disable clippy warnings that can result in the way how parol generates code.
#![allow(clippy::enum_variant_names)]
#![allow(clippy::large_enum_variant)]
#![allow(clippy::upper_case_acronyms)]

use parol_runtime::derive_builder::Builder;
use parol_runtime::id_tree::Tree;
use parol_runtime::log::trace;
#[allow(unused_imports)]
use parol_runtime::miette::{bail, miette, IntoDiagnostic, Result};
#[allow(unused_imports)]
use parol_runtime::parol_macros::{pop_and_reverse_item, pop_item};
use parol_runtime::parser::{ParseTreeStackEntry, ParseTreeType, UserActionsTrait};
use std::marker::PhantomData;

/// Semantic actions trait generated for the user grammar
/// All functions have default implementations.
pub trait VerylGrammarTrait {
    /// Semantic action for non-terminal 'CommentsTerm'
    fn comments_term(&mut self, _arg: &CommentsTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ExponentTerm'
    fn exponent_term(&mut self, _arg: &ExponentTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'FixedPointTerm'
    fn fixed_point_term(&mut self, _arg: &FixedPointTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BasedTerm'
    fn based_term(&mut self, _arg: &BasedTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BaseLessTerm'
    fn base_less_term(&mut self, _arg: &BaseLessTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AllBitTerm'
    fn all_bit_term(&mut self, _arg: &AllBitTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MinusColonTerm'
    fn minus_colon_term(&mut self, _arg: &MinusColonTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MinusGTTerm'
    fn minus_g_t_term(&mut self, _arg: &MinusGTTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PlusColonTerm'
    fn plus_colon_term(&mut self, _arg: &PlusColonTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AssignmentOperatorTerm'
    fn assignment_operator_term(&mut self, _arg: &AssignmentOperatorTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator11Term'
    fn operator11_term(&mut self, _arg: &Operator11Term) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator10Term'
    fn operator10_term(&mut self, _arg: &Operator10Term) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator09Term'
    fn operator09_term(&mut self, _arg: &Operator09Term) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator08Term'
    fn operator08_term(&mut self, _arg: &Operator08Term) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator07Term'
    fn operator07_term(&mut self, _arg: &Operator07Term) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator06Term'
    fn operator06_term(&mut self, _arg: &Operator06Term) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator02Term'
    fn operator02_term(&mut self, _arg: &Operator02Term) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator01Term'
    fn operator01_term(&mut self, _arg: &Operator01Term) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator05Term'
    fn operator05_term(&mut self, _arg: &Operator05Term) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator04Term'
    fn operator04_term(&mut self, _arg: &Operator04Term) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator03Term'
    fn operator03_term(&mut self, _arg: &Operator03Term) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'UnaryOperatorTerm'
    fn unary_operator_term(&mut self, _arg: &UnaryOperatorTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ColonColonTerm'
    fn colon_colon_term(&mut self, _arg: &ColonColonTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ColonTerm'
    fn colon_term(&mut self, _arg: &ColonTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'CommaTerm'
    fn comma_term(&mut self, _arg: &CommaTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DollarTerm'
    fn dollar_term(&mut self, _arg: &DollarTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DotDotTerm'
    fn dot_dot_term(&mut self, _arg: &DotDotTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DotTerm'
    fn dot_term(&mut self, _arg: &DotTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EquTerm'
    fn equ_term(&mut self, _arg: &EquTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'HashTerm'
    fn hash_term(&mut self, _arg: &HashTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LBraceTerm'
    fn l_brace_term(&mut self, _arg: &LBraceTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LBracketTerm'
    fn l_bracket_term(&mut self, _arg: &LBracketTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LParenTerm'
    fn l_paren_term(&mut self, _arg: &LParenTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RBraceTerm'
    fn r_brace_term(&mut self, _arg: &RBraceTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RBracketTerm'
    fn r_bracket_term(&mut self, _arg: &RBracketTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RParenTerm'
    fn r_paren_term(&mut self, _arg: &RParenTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'SemicolonTerm'
    fn semicolon_term(&mut self, _arg: &SemicolonTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AlwaysCombTerm'
    fn always_comb_term(&mut self, _arg: &AlwaysCombTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AlwaysFfTerm'
    fn always_ff_term(&mut self, _arg: &AlwaysFfTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AssignTerm'
    fn assign_term(&mut self, _arg: &AssignTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AsyncHighTerm'
    fn async_high_term(&mut self, _arg: &AsyncHighTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AsyncLowTerm'
    fn async_low_term(&mut self, _arg: &AsyncLowTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BitTerm'
    fn bit_term(&mut self, _arg: &BitTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'CaseTerm'
    fn case_term(&mut self, _arg: &CaseTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DefaultTerm'
    fn default_term(&mut self, _arg: &DefaultTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ElseTerm'
    fn else_term(&mut self, _arg: &ElseTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EnumTerm'
    fn enum_term(&mut self, _arg: &EnumTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'F32Term'
    fn f32_term(&mut self, _arg: &F32Term) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'F64Term'
    fn f64_term(&mut self, _arg: &F64Term) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ForTerm'
    fn for_term(&mut self, _arg: &ForTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'FunctionTerm'
    fn function_term(&mut self, _arg: &FunctionTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'I32Term'
    fn i32_term(&mut self, _arg: &I32Term) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'I64Term'
    fn i64_term(&mut self, _arg: &I64Term) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IfResetTerm'
    fn if_reset_term(&mut self, _arg: &IfResetTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IfTerm'
    fn if_term(&mut self, _arg: &IfTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InoutTerm'
    fn inout_term(&mut self, _arg: &InoutTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InputTerm'
    fn input_term(&mut self, _arg: &InputTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InstTerm'
    fn inst_term(&mut self, _arg: &InstTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InterfaceTerm'
    fn interface_term(&mut self, _arg: &InterfaceTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InTerm'
    fn in_term(&mut self, _arg: &InTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LocalparamTerm'
    fn localparam_term(&mut self, _arg: &LocalparamTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LogicTerm'
    fn logic_term(&mut self, _arg: &LogicTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModportTerm'
    fn modport_term(&mut self, _arg: &ModportTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModuleTerm'
    fn module_term(&mut self, _arg: &ModuleTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'NegedgeTerm'
    fn negedge_term(&mut self, _arg: &NegedgeTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'OutputTerm'
    fn output_term(&mut self, _arg: &OutputTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PackageTerm'
    fn package_term(&mut self, _arg: &PackageTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ParameterTerm'
    fn parameter_term(&mut self, _arg: &ParameterTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PosedgeTerm'
    fn posedge_term(&mut self, _arg: &PosedgeTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RefTerm'
    fn ref_term(&mut self, _arg: &RefTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ReturnTerm'
    fn return_term(&mut self, _arg: &ReturnTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StepTerm'
    fn step_term(&mut self, _arg: &StepTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StructTerm'
    fn struct_term(&mut self, _arg: &StructTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'SyncHighTerm'
    fn sync_high_term(&mut self, _arg: &SyncHighTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'SyncLowTerm'
    fn sync_low_term(&mut self, _arg: &SyncLowTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'U32Term'
    fn u32_term(&mut self, _arg: &U32Term) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'U64Term'
    fn u64_term(&mut self, _arg: &U64Term) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'VarTerm'
    fn var_term(&mut self, _arg: &VarTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IdentifierTerm'
    fn identifier_term(&mut self, _arg: &IdentifierTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Comments'
    fn comments(&mut self, _arg: &Comments) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StartToken'
    fn start_token(&mut self, _arg: &StartToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ExponentToken'
    fn exponent_token(&mut self, _arg: &ExponentToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'FixedPointToken'
    fn fixed_point_token(&mut self, _arg: &FixedPointToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BasedToken'
    fn based_token(&mut self, _arg: &BasedToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BaseLessToken'
    fn base_less_token(&mut self, _arg: &BaseLessToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AllBitToken'
    fn all_bit_token(&mut self, _arg: &AllBitToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AssignmentOperatorToken'
    fn assignment_operator_token(&mut self, _arg: &AssignmentOperatorToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator01Token'
    fn operator01_token(&mut self, _arg: &Operator01Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator02Token'
    fn operator02_token(&mut self, _arg: &Operator02Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator03Token'
    fn operator03_token(&mut self, _arg: &Operator03Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator04Token'
    fn operator04_token(&mut self, _arg: &Operator04Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator05Token'
    fn operator05_token(&mut self, _arg: &Operator05Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator06Token'
    fn operator06_token(&mut self, _arg: &Operator06Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator07Token'
    fn operator07_token(&mut self, _arg: &Operator07Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator08Token'
    fn operator08_token(&mut self, _arg: &Operator08Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator09Token'
    fn operator09_token(&mut self, _arg: &Operator09Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator10Token'
    fn operator10_token(&mut self, _arg: &Operator10Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator11Token'
    fn operator11_token(&mut self, _arg: &Operator11Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'UnaryOperatorToken'
    fn unary_operator_token(&mut self, _arg: &UnaryOperatorToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ColonToken'
    fn colon_token(&mut self, _arg: &ColonToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ColonColonToken'
    fn colon_colon_token(&mut self, _arg: &ColonColonToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'CommaToken'
    fn comma_token(&mut self, _arg: &CommaToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DollarToken'
    fn dollar_token(&mut self, _arg: &DollarToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DotDotToken'
    fn dot_dot_token(&mut self, _arg: &DotDotToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DotToken'
    fn dot_token(&mut self, _arg: &DotToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EquToken'
    fn equ_token(&mut self, _arg: &EquToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'HashToken'
    fn hash_token(&mut self, _arg: &HashToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LBraceToken'
    fn l_brace_token(&mut self, _arg: &LBraceToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LBracketToken'
    fn l_bracket_token(&mut self, _arg: &LBracketToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LParenToken'
    fn l_paren_token(&mut self, _arg: &LParenToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MinusColonToken'
    fn minus_colon_token(&mut self, _arg: &MinusColonToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MinusGTToken'
    fn minus_g_t_token(&mut self, _arg: &MinusGTToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PlusColonToken'
    fn plus_colon_token(&mut self, _arg: &PlusColonToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RBraceToken'
    fn r_brace_token(&mut self, _arg: &RBraceToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RBracketToken'
    fn r_bracket_token(&mut self, _arg: &RBracketToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RParenToken'
    fn r_paren_token(&mut self, _arg: &RParenToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'SemicolonToken'
    fn semicolon_token(&mut self, _arg: &SemicolonToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AlwaysCombToken'
    fn always_comb_token(&mut self, _arg: &AlwaysCombToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AlwaysFfToken'
    fn always_ff_token(&mut self, _arg: &AlwaysFfToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AssignToken'
    fn assign_token(&mut self, _arg: &AssignToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AsyncHighToken'
    fn async_high_token(&mut self, _arg: &AsyncHighToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AsyncLowToken'
    fn async_low_token(&mut self, _arg: &AsyncLowToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BitToken'
    fn bit_token(&mut self, _arg: &BitToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'CaseToken'
    fn case_token(&mut self, _arg: &CaseToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DefaultToken'
    fn default_token(&mut self, _arg: &DefaultToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ElseToken'
    fn else_token(&mut self, _arg: &ElseToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EnumToken'
    fn enum_token(&mut self, _arg: &EnumToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'F32Token'
    fn f32_token(&mut self, _arg: &F32Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'F64Token'
    fn f64_token(&mut self, _arg: &F64Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ForToken'
    fn for_token(&mut self, _arg: &ForToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'FunctionToken'
    fn function_token(&mut self, _arg: &FunctionToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'I32Token'
    fn i32_token(&mut self, _arg: &I32Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'I64Token'
    fn i64_token(&mut self, _arg: &I64Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IfResetToken'
    fn if_reset_token(&mut self, _arg: &IfResetToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IfToken'
    fn if_token(&mut self, _arg: &IfToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InoutToken'
    fn inout_token(&mut self, _arg: &InoutToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InputToken'
    fn input_token(&mut self, _arg: &InputToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InstToken'
    fn inst_token(&mut self, _arg: &InstToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InterfaceToken'
    fn interface_token(&mut self, _arg: &InterfaceToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InToken'
    fn in_token(&mut self, _arg: &InToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LocalparamToken'
    fn localparam_token(&mut self, _arg: &LocalparamToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LogicToken'
    fn logic_token(&mut self, _arg: &LogicToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModportToken'
    fn modport_token(&mut self, _arg: &ModportToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModuleToken'
    fn module_token(&mut self, _arg: &ModuleToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'NegedgeToken'
    fn negedge_token(&mut self, _arg: &NegedgeToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'OutputToken'
    fn output_token(&mut self, _arg: &OutputToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PackageToken'
    fn package_token(&mut self, _arg: &PackageToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ParameterToken'
    fn parameter_token(&mut self, _arg: &ParameterToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PosedgeToken'
    fn posedge_token(&mut self, _arg: &PosedgeToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RefToken'
    fn ref_token(&mut self, _arg: &RefToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ReturnToken'
    fn return_token(&mut self, _arg: &ReturnToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StepToken'
    fn step_token(&mut self, _arg: &StepToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StructToken'
    fn struct_token(&mut self, _arg: &StructToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'SyncHighToken'
    fn sync_high_token(&mut self, _arg: &SyncHighToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'SyncLowToken'
    fn sync_low_token(&mut self, _arg: &SyncLowToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'U32Token'
    fn u32_token(&mut self, _arg: &U32Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'U64Token'
    fn u64_token(&mut self, _arg: &U64Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'VarToken'
    fn var_token(&mut self, _arg: &VarToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IdentifierToken'
    fn identifier_token(&mut self, _arg: &IdentifierToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Start'
    fn start(&mut self, _arg: &Start) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Exponent'
    fn exponent(&mut self, _arg: &Exponent) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'FixedPoint'
    fn fixed_point(&mut self, _arg: &FixedPoint) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Based'
    fn based(&mut self, _arg: &Based) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BaseLess'
    fn base_less(&mut self, _arg: &BaseLess) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AllBit'
    fn all_bit(&mut self, _arg: &AllBit) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AssignmentOperator'
    fn assignment_operator(&mut self, _arg: &AssignmentOperator) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator01'
    fn operator01(&mut self, _arg: &Operator01) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator02'
    fn operator02(&mut self, _arg: &Operator02) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator03'
    fn operator03(&mut self, _arg: &Operator03) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator04'
    fn operator04(&mut self, _arg: &Operator04) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator05'
    fn operator05(&mut self, _arg: &Operator05) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator06'
    fn operator06(&mut self, _arg: &Operator06) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator07'
    fn operator07(&mut self, _arg: &Operator07) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator08'
    fn operator08(&mut self, _arg: &Operator08) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator09'
    fn operator09(&mut self, _arg: &Operator09) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator10'
    fn operator10(&mut self, _arg: &Operator10) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator11'
    fn operator11(&mut self, _arg: &Operator11) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'UnaryOperator'
    fn unary_operator(&mut self, _arg: &UnaryOperator) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Colon'
    fn colon(&mut self, _arg: &Colon) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ColonColon'
    fn colon_colon(&mut self, _arg: &ColonColon) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Comma'
    fn comma(&mut self, _arg: &Comma) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Dollar'
    fn dollar(&mut self, _arg: &Dollar) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DotDot'
    fn dot_dot(&mut self, _arg: &DotDot) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Dot'
    fn dot(&mut self, _arg: &Dot) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Equ'
    fn equ(&mut self, _arg: &Equ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Hash'
    fn hash(&mut self, _arg: &Hash) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LBrace'
    fn l_brace(&mut self, _arg: &LBrace) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LBracket'
    fn l_bracket(&mut self, _arg: &LBracket) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LParen'
    fn l_paren(&mut self, _arg: &LParen) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MinusColon'
    fn minus_colon(&mut self, _arg: &MinusColon) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MinusGT'
    fn minus_g_t(&mut self, _arg: &MinusGT) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PlusColon'
    fn plus_colon(&mut self, _arg: &PlusColon) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RBrace'
    fn r_brace(&mut self, _arg: &RBrace) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RBracket'
    fn r_bracket(&mut self, _arg: &RBracket) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RParen'
    fn r_paren(&mut self, _arg: &RParen) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Semicolon'
    fn semicolon(&mut self, _arg: &Semicolon) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AlwaysComb'
    fn always_comb(&mut self, _arg: &AlwaysComb) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AlwaysFf'
    fn always_ff(&mut self, _arg: &AlwaysFf) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Assign'
    fn assign(&mut self, _arg: &Assign) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AsyncHigh'
    fn async_high(&mut self, _arg: &AsyncHigh) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AsyncLow'
    fn async_low(&mut self, _arg: &AsyncLow) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Bit'
    fn bit(&mut self, _arg: &Bit) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Case'
    fn case(&mut self, _arg: &Case) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Defaul'
    fn defaul(&mut self, _arg: &Defaul) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Else'
    fn r#else(&mut self, _arg: &Else) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Enum'
    fn r#enum(&mut self, _arg: &Enum) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'F32'
    fn f32(&mut self, _arg: &F32) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'F64'
    fn f64(&mut self, _arg: &F64) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'For'
    fn r#for(&mut self, _arg: &For) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Function'
    fn function(&mut self, _arg: &Function) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'I32'
    fn i32(&mut self, _arg: &I32) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'I64'
    fn i64(&mut self, _arg: &I64) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'If'
    fn r#if(&mut self, _arg: &If) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IfReset'
    fn if_reset(&mut self, _arg: &IfReset) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'In'
    fn r#in(&mut self, _arg: &In) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Inout'
    fn inout(&mut self, _arg: &Inout) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Input'
    fn input(&mut self, _arg: &Input) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Inst'
    fn inst(&mut self, _arg: &Inst) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Interface'
    fn interface(&mut self, _arg: &Interface) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Localparam'
    fn localparam(&mut self, _arg: &Localparam) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Logic'
    fn logic(&mut self, _arg: &Logic) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Modport'
    fn modport(&mut self, _arg: &Modport) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Module'
    fn module(&mut self, _arg: &Module) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Negedge'
    fn negedge(&mut self, _arg: &Negedge) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Output'
    fn output(&mut self, _arg: &Output) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Package'
    fn package(&mut self, _arg: &Package) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Parameter'
    fn parameter(&mut self, _arg: &Parameter) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Posedge'
    fn posedge(&mut self, _arg: &Posedge) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Ref'
    fn r#ref(&mut self, _arg: &Ref) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Return'
    fn r#return(&mut self, _arg: &Return) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Step'
    fn step(&mut self, _arg: &Step) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Struct'
    fn r#struct(&mut self, _arg: &Struct) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'SyncHigh'
    fn sync_high(&mut self, _arg: &SyncHigh) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'SyncLow'
    fn sync_low(&mut self, _arg: &SyncLow) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'U32'
    fn u32(&mut self, _arg: &U32) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'U64'
    fn u64(&mut self, _arg: &U64) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Var'
    fn var(&mut self, _arg: &Var) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Identifier'
    fn identifier(&mut self, _arg: &Identifier) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Number'
    fn number(&mut self, _arg: &Number) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IntegralNumber'
    fn integral_number(&mut self, _arg: &IntegralNumber) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RealNumber'
    fn real_number(&mut self, _arg: &RealNumber) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'HierarchicalIdentifier'
    fn hierarchical_identifier(&mut self, _arg: &HierarchicalIdentifier) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ScopedIdentifier'
    fn scoped_identifier(&mut self, _arg: &ScopedIdentifier) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ScopedOrHierIdentifier'
    fn scoped_or_hier_identifier(&mut self, _arg: &ScopedOrHierIdentifier) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression'
    fn expression(&mut self, _arg: &Expression) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression01'
    fn expression01(&mut self, _arg: &Expression01) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression02'
    fn expression02(&mut self, _arg: &Expression02) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression03'
    fn expression03(&mut self, _arg: &Expression03) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression04'
    fn expression04(&mut self, _arg: &Expression04) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression05'
    fn expression05(&mut self, _arg: &Expression05) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression06'
    fn expression06(&mut self, _arg: &Expression06) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression07'
    fn expression07(&mut self, _arg: &Expression07) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression08'
    fn expression08(&mut self, _arg: &Expression08) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression09'
    fn expression09(&mut self, _arg: &Expression09) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression10'
    fn expression10(&mut self, _arg: &Expression10) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression11'
    fn expression11(&mut self, _arg: &Expression11) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Factor'
    fn factor(&mut self, _arg: &Factor) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'FunctionCallArg'
    fn function_call_arg(&mut self, _arg: &FunctionCallArg) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Range'
    fn range(&mut self, _arg: &Range) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RangeOperator'
    fn range_operator(&mut self, _arg: &RangeOperator) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Width'
    fn width(&mut self, _arg: &Width) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BuiltinType'
    fn builtin_type(&mut self, _arg: &BuiltinType) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Type'
    fn r#type(&mut self, _arg: &Type) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Statement'
    fn statement(&mut self, _arg: &Statement) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AssignmentStatement'
    fn assignment_statement(&mut self, _arg: &AssignmentStatement) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IfStatement'
    fn if_statement(&mut self, _arg: &IfStatement) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IfResetStatement'
    fn if_reset_statement(&mut self, _arg: &IfResetStatement) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ReturnStatement'
    fn return_statement(&mut self, _arg: &ReturnStatement) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ForStatement'
    fn for_statement(&mut self, _arg: &ForStatement) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'CaseStatement'
    fn case_statement(&mut self, _arg: &CaseStatement) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'CaseItem'
    fn case_item(&mut self, _arg: &CaseItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'VarDeclaration'
    fn var_declaration(&mut self, _arg: &VarDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LocalparamDeclaration'
    fn localparam_declaration(&mut self, _arg: &LocalparamDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AlwaysFfDeclaration'
    fn always_ff_declaration(&mut self, _arg: &AlwaysFfDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AlwaysFfClock'
    fn always_ff_clock(&mut self, _arg: &AlwaysFfClock) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AlwaysFfReset'
    fn always_ff_reset(&mut self, _arg: &AlwaysFfReset) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AlwaysCombDeclaration'
    fn always_comb_declaration(&mut self, _arg: &AlwaysCombDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AssignDeclaration'
    fn assign_declaration(&mut self, _arg: &AssignDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModportDeclaration'
    fn modport_declaration(&mut self, _arg: &ModportDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModportList'
    fn modport_list(&mut self, _arg: &ModportList) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModportItem'
    fn modport_item(&mut self, _arg: &ModportItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EnumDeclaration'
    fn enum_declaration(&mut self, _arg: &EnumDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EnumList'
    fn enum_list(&mut self, _arg: &EnumList) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EnumItem'
    fn enum_item(&mut self, _arg: &EnumItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StructDeclaration'
    fn struct_declaration(&mut self, _arg: &StructDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StructList'
    fn struct_list(&mut self, _arg: &StructList) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StructItem'
    fn struct_item(&mut self, _arg: &StructItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InstDeclaration'
    fn inst_declaration(&mut self, _arg: &InstDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InstParameter'
    fn inst_parameter(&mut self, _arg: &InstParameter) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InstParameterList'
    fn inst_parameter_list(&mut self, _arg: &InstParameterList) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InstParameterItem'
    fn inst_parameter_item(&mut self, _arg: &InstParameterItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InstPortList'
    fn inst_port_list(&mut self, _arg: &InstPortList) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InstPortItem'
    fn inst_port_item(&mut self, _arg: &InstPortItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WithParameter'
    fn with_parameter(&mut self, _arg: &WithParameter) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WithParameterList'
    fn with_parameter_list(&mut self, _arg: &WithParameterList) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WithParameterItem'
    fn with_parameter_item(&mut self, _arg: &WithParameterItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PortDeclaration'
    fn port_declaration(&mut self, _arg: &PortDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PortDeclarationList'
    fn port_declaration_list(&mut self, _arg: &PortDeclarationList) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PortDeclarationItem'
    fn port_declaration_item(&mut self, _arg: &PortDeclarationItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Direction'
    fn direction(&mut self, _arg: &Direction) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'FunctionDeclaration'
    fn function_declaration(&mut self, _arg: &FunctionDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'FunctionItem'
    fn function_item(&mut self, _arg: &FunctionItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModuleDeclaration'
    fn module_declaration(&mut self, _arg: &ModuleDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModuleIfDeclaration'
    fn module_if_declaration(&mut self, _arg: &ModuleIfDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModuleForDeclaration'
    fn module_for_declaration(&mut self, _arg: &ModuleForDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModuleNamedBlock'
    fn module_named_block(&mut self, _arg: &ModuleNamedBlock) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModuleOptionalNamedBlock'
    fn module_optional_named_block(&mut self, _arg: &ModuleOptionalNamedBlock) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModuleItem'
    fn module_item(&mut self, _arg: &ModuleItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InterfaceDeclaration'
    fn interface_declaration(&mut self, _arg: &InterfaceDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InterfaceIfDeclaration'
    fn interface_if_declaration(&mut self, _arg: &InterfaceIfDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InterfaceForDeclaration'
    fn interface_for_declaration(&mut self, _arg: &InterfaceForDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InterfaceNamedBlock'
    fn interface_named_block(&mut self, _arg: &InterfaceNamedBlock) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InterfaceOptionalNamedBlock'
    fn interface_optional_named_block(&mut self, _arg: &InterfaceOptionalNamedBlock) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InterfaceItem'
    fn interface_item(&mut self, _arg: &InterfaceItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PackageDeclaration'
    fn package_declaration(&mut self, _arg: &PackageDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PackageItem'
    fn package_item(&mut self, _arg: &PackageItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Description'
    fn description(&mut self, _arg: &Description) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Veryl'
    fn veryl(&mut self, _arg: &Veryl) -> Result<()> {
        Ok(())
    }
}

// -------------------------------------------------------------------------------------------------
//
// Output Types of productions deduced from the structure of the transformed grammar
//

///
/// Type derived for production 240
///
/// Number: IntegralNumber;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct NumberIntegralNumber {
    pub integral_number: Box<IntegralNumber>,
}

///
/// Type derived for production 241
///
/// Number: RealNumber;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct NumberRealNumber {
    pub real_number: Box<RealNumber>,
}

///
/// Type derived for production 242
///
/// IntegralNumber: Based;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IntegralNumberBased {
    pub based: Box<Based>,
}

///
/// Type derived for production 243
///
/// IntegralNumber: BaseLess;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IntegralNumberBaseLess {
    pub base_less: Box<BaseLess>,
}

///
/// Type derived for production 244
///
/// IntegralNumber: AllBit;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IntegralNumberAllBit {
    pub all_bit: Box<AllBit>,
}

///
/// Type derived for production 245
///
/// RealNumber: FixedPoint;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RealNumberFixedPoint {
    pub fixed_point: Box<FixedPoint>,
}

///
/// Type derived for production 246
///
/// RealNumber: Exponent;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RealNumberExponent {
    pub exponent: Box<Exponent>,
}

///
/// Type derived for production 258
///
/// ScopedOrHierIdentifierGroup: ColonColon Identifier ScopedOrHierIdentifierGroupList /* Vec */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ScopedOrHierIdentifierGroupColonColonIdentifierScopedOrHierIdentifierGroupList {
    pub colon_colon: Box<ColonColon>,
    pub identifier: Box<Identifier>,
    pub scoped_or_hier_identifier_group_list: Vec<ScopedOrHierIdentifierGroupList>,
}

///
/// Type derived for production 261
///
/// ScopedOrHierIdentifierGroup: ScopedOrHierIdentifierGroupList0 /* Vec */ ScopedOrHierIdentifierGroupList1 /* Vec */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ScopedOrHierIdentifierGroupScopedOrHierIdentifierGroupList0ScopedOrHierIdentifierGroupList1
{
    pub scoped_or_hier_identifier_group_list0: Vec<ScopedOrHierIdentifierGroupList0>,
    pub scoped_or_hier_identifier_group_list1: Vec<ScopedOrHierIdentifierGroupList1>,
}

///
/// Type derived for production 303
///
/// Expression11ListGroup: UnaryOperator;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression11ListGroupUnaryOperator {
    pub unary_operator: Box<UnaryOperator>,
}

///
/// Type derived for production 304
///
/// Expression11ListGroup: Operator09;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression11ListGroupOperator09 {
    pub operator09: Box<Operator09>,
}

///
/// Type derived for production 305
///
/// Expression11ListGroup: Operator05;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression11ListGroupOperator05 {
    pub operator05: Box<Operator05>,
}

///
/// Type derived for production 306
///
/// Expression11ListGroup: Operator03;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression11ListGroupOperator03 {
    pub operator03: Box<Operator03>,
}

///
/// Type derived for production 307
///
/// Expression11ListGroup: Operator04;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression11ListGroupOperator04 {
    pub operator04: Box<Operator04>,
}

///
/// Type derived for production 309
///
/// Factor: Number;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FactorNumber {
    pub number: Box<Number>,
}

///
/// Type derived for production 310
///
/// Factor: FactorOpt /* Option */ ScopedOrHierIdentifier FactorOpt0 /* Option */;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FactorFactorOptScopedOrHierIdentifierFactorOpt0 {
    pub factor_opt: Option<Box<FactorOpt>>,
    pub scoped_or_hier_identifier: Box<ScopedOrHierIdentifier>,
    pub factor_opt0: Option<Box<FactorOpt0>>,
}

///
/// Type derived for production 311
///
/// Factor: LParen Expression RParen;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FactorLParenExpressionRParen {
    pub l_paren: Box<LParen>,
    pub expression: Box<Expression>,
    pub r_paren: Box<RParen>,
}

///
/// Type derived for production 326
///
/// RangeOperator: Colon;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RangeOperatorColon {
    pub colon: Box<Colon>,
}

///
/// Type derived for production 327
///
/// RangeOperator: PlusColon;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RangeOperatorPlusColon {
    pub plus_colon: Box<PlusColon>,
}

///
/// Type derived for production 328
///
/// RangeOperator: MinusColon;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RangeOperatorMinusColon {
    pub minus_colon: Box<MinusColon>,
}

///
/// Type derived for production 329
///
/// RangeOperator: Step;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RangeOperatorStep {
    pub step: Box<Step>,
}

///
/// Type derived for production 331
///
/// BuiltinType: Logic;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BuiltinTypeLogic {
    pub logic: Box<Logic>,
}

///
/// Type derived for production 332
///
/// BuiltinType: Bit;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BuiltinTypeBit {
    pub bit: Box<Bit>,
}

///
/// Type derived for production 333
///
/// BuiltinType: U32;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BuiltinTypeU32 {
    pub u32: Box<U32>,
}

///
/// Type derived for production 334
///
/// BuiltinType: U64;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BuiltinTypeU64 {
    pub u64: Box<U64>,
}

///
/// Type derived for production 335
///
/// BuiltinType: I32;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BuiltinTypeI32 {
    pub i32: Box<I32>,
}

///
/// Type derived for production 336
///
/// BuiltinType: I64;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BuiltinTypeI64 {
    pub i64: Box<I64>,
}

///
/// Type derived for production 337
///
/// BuiltinType: F32;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BuiltinTypeF32 {
    pub f32: Box<F32>,
}

///
/// Type derived for production 338
///
/// BuiltinType: F64;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BuiltinTypeF64 {
    pub f64: Box<F64>,
}

///
/// Type derived for production 340
///
/// TypeGroup: BuiltinType;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TypeGroupBuiltinType {
    pub builtin_type: Box<BuiltinType>,
}

///
/// Type derived for production 341
///
/// TypeGroup: ScopedIdentifier;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TypeGroupScopedIdentifier {
    pub scoped_identifier: Box<ScopedIdentifier>,
}

///
/// Type derived for production 344
///
/// Statement: AssignmentStatement;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StatementAssignmentStatement {
    pub assignment_statement: Box<AssignmentStatement>,
}

///
/// Type derived for production 345
///
/// Statement: IfStatement;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StatementIfStatement {
    pub if_statement: Box<IfStatement>,
}

///
/// Type derived for production 346
///
/// Statement: IfResetStatement;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StatementIfResetStatement {
    pub if_reset_statement: Box<IfResetStatement>,
}

///
/// Type derived for production 347
///
/// Statement: ReturnStatement;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StatementReturnStatement {
    pub return_statement: Box<ReturnStatement>,
}

///
/// Type derived for production 348
///
/// Statement: ForStatement;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StatementForStatement {
    pub for_statement: Box<ForStatement>,
}

///
/// Type derived for production 349
///
/// Statement: CaseStatement;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StatementCaseStatement {
    pub case_statement: Box<CaseStatement>,
}

///
/// Type derived for production 351
///
/// AssignmentStatementGroup: Equ;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AssignmentStatementGroupEqu {
    pub equ: Box<Equ>,
}

///
/// Type derived for production 352
///
/// AssignmentStatementGroup: AssignmentOperator;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AssignmentStatementGroupAssignmentOperator {
    pub assignment_operator: Box<AssignmentOperator>,
}

///
/// Type derived for production 385
///
/// CaseItemGroup0: Statement;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CaseItemGroup0Statement {
    pub statement: Box<Statement>,
}

///
/// Type derived for production 386
///
/// CaseItemGroup0: LBrace CaseItemGroup0List /* Vec */ RBrace;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CaseItemGroup0LBraceCaseItemGroup0ListRBrace {
    pub l_brace: Box<LBrace>,
    pub case_item_group0_list: Vec<CaseItemGroup0List>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for production 389
///
/// CaseItemGroup: Expression;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CaseItemGroupExpression {
    pub expression: Box<Expression>,
}

///
/// Type derived for production 390
///
/// CaseItemGroup: Defaul;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CaseItemGroupDefaul {
    pub defaul: Box<Defaul>,
}

///
/// Type derived for production 402
///
/// AlwaysFfClockOptGroup: Posedge;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AlwaysFfClockOptGroupPosedge {
    pub posedge: Box<Posedge>,
}

///
/// Type derived for production 403
///
/// AlwaysFfClockOptGroup: Negedge;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AlwaysFfClockOptGroupNegedge {
    pub negedge: Box<Negedge>,
}

///
/// Type derived for production 407
///
/// AlwaysFfResetOptGroup: AsyncLow;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AlwaysFfResetOptGroupAsyncLow {
    pub async_low: Box<AsyncLow>,
}

///
/// Type derived for production 408
///
/// AlwaysFfResetOptGroup: AsyncHigh;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AlwaysFfResetOptGroupAsyncHigh {
    pub async_high: Box<AsyncHigh>,
}

///
/// Type derived for production 409
///
/// AlwaysFfResetOptGroup: SyncLow;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AlwaysFfResetOptGroupSyncLow {
    pub sync_low: Box<SyncLow>,
}

///
/// Type derived for production 410
///
/// AlwaysFfResetOptGroup: SyncHigh;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AlwaysFfResetOptGroupSyncHigh {
    pub sync_high: Box<SyncHigh>,
}

///
/// Type derived for production 476
///
/// WithParameterItemGroup: Parameter;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct WithParameterItemGroupParameter {
    pub parameter: Box<Parameter>,
}

///
/// Type derived for production 477
///
/// WithParameterItemGroup: Localparam;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct WithParameterItemGroupLocalparam {
    pub localparam: Box<Localparam>,
}

///
/// Type derived for production 487
///
/// Direction: Input;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DirectionInput {
    pub input: Box<Input>,
}

///
/// Type derived for production 488
///
/// Direction: Output;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DirectionOutput {
    pub output: Box<Output>,
}

///
/// Type derived for production 489
///
/// Direction: Inout;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DirectionInout {
    pub inout: Box<Inout>,
}

///
/// Type derived for production 490
///
/// Direction: Ref;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DirectionRef {
    pub r#ref: Box<Ref>,
}

///
/// Type derived for production 498
///
/// FunctionItem: VarDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FunctionItemVarDeclaration {
    pub var_declaration: Box<VarDeclaration>,
}

///
/// Type derived for production 499
///
/// FunctionItem: Statement;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FunctionItemStatement {
    pub statement: Box<Statement>,
}

///
/// Type derived for production 523
///
/// ModuleItem: VarDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleItemVarDeclaration {
    pub var_declaration: Box<VarDeclaration>,
}

///
/// Type derived for production 524
///
/// ModuleItem: InstDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleItemInstDeclaration {
    pub inst_declaration: Box<InstDeclaration>,
}

///
/// Type derived for production 525
///
/// ModuleItem: LocalparamDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleItemLocalparamDeclaration {
    pub localparam_declaration: Box<LocalparamDeclaration>,
}

///
/// Type derived for production 526
///
/// ModuleItem: AlwaysFfDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleItemAlwaysFfDeclaration {
    pub always_ff_declaration: Box<AlwaysFfDeclaration>,
}

///
/// Type derived for production 527
///
/// ModuleItem: AlwaysCombDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleItemAlwaysCombDeclaration {
    pub always_comb_declaration: Box<AlwaysCombDeclaration>,
}

///
/// Type derived for production 528
///
/// ModuleItem: AssignDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleItemAssignDeclaration {
    pub assign_declaration: Box<AssignDeclaration>,
}

///
/// Type derived for production 529
///
/// ModuleItem: FunctionDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleItemFunctionDeclaration {
    pub function_declaration: Box<FunctionDeclaration>,
}

///
/// Type derived for production 530
///
/// ModuleItem: ModuleIfDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleItemModuleIfDeclaration {
    pub module_if_declaration: Box<ModuleIfDeclaration>,
}

///
/// Type derived for production 531
///
/// ModuleItem: ModuleForDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleItemModuleForDeclaration {
    pub module_for_declaration: Box<ModuleForDeclaration>,
}

///
/// Type derived for production 532
///
/// ModuleItem: EnumDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleItemEnumDeclaration {
    pub enum_declaration: Box<EnumDeclaration>,
}

///
/// Type derived for production 533
///
/// ModuleItem: StructDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleItemStructDeclaration {
    pub struct_declaration: Box<StructDeclaration>,
}

///
/// Type derived for production 534
///
/// ModuleItem: ModuleNamedBlock;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleItemModuleNamedBlock {
    pub module_named_block: Box<ModuleNamedBlock>,
}

///
/// Type derived for production 556
///
/// InterfaceItem: VarDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InterfaceItemVarDeclaration {
    pub var_declaration: Box<VarDeclaration>,
}

///
/// Type derived for production 557
///
/// InterfaceItem: LocalparamDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InterfaceItemLocalparamDeclaration {
    pub localparam_declaration: Box<LocalparamDeclaration>,
}

///
/// Type derived for production 558
///
/// InterfaceItem: ModportDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InterfaceItemModportDeclaration {
    pub modport_declaration: Box<ModportDeclaration>,
}

///
/// Type derived for production 559
///
/// InterfaceItem: InterfaceIfDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InterfaceItemInterfaceIfDeclaration {
    pub interface_if_declaration: Box<InterfaceIfDeclaration>,
}

///
/// Type derived for production 560
///
/// InterfaceItem: InterfaceForDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InterfaceItemInterfaceForDeclaration {
    pub interface_for_declaration: Box<InterfaceForDeclaration>,
}

///
/// Type derived for production 561
///
/// InterfaceItem: EnumDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InterfaceItemEnumDeclaration {
    pub enum_declaration: Box<EnumDeclaration>,
}

///
/// Type derived for production 562
///
/// InterfaceItem: StructDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InterfaceItemStructDeclaration {
    pub struct_declaration: Box<StructDeclaration>,
}

///
/// Type derived for production 563
///
/// InterfaceItem: InterfaceNamedBlock;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InterfaceItemInterfaceNamedBlock {
    pub interface_named_block: Box<InterfaceNamedBlock>,
}

///
/// Type derived for production 564
///
/// InterfaceItem: FunctionDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InterfaceItemFunctionDeclaration {
    pub function_declaration: Box<FunctionDeclaration>,
}

///
/// Type derived for production 568
///
/// PackageItem: VarDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PackageItemVarDeclaration {
    pub var_declaration: Box<VarDeclaration>,
}

///
/// Type derived for production 569
///
/// PackageItem: LocalparamDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PackageItemLocalparamDeclaration {
    pub localparam_declaration: Box<LocalparamDeclaration>,
}

///
/// Type derived for production 570
///
/// PackageItem: EnumDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PackageItemEnumDeclaration {
    pub enum_declaration: Box<EnumDeclaration>,
}

///
/// Type derived for production 571
///
/// PackageItem: StructDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PackageItemStructDeclaration {
    pub struct_declaration: Box<StructDeclaration>,
}

///
/// Type derived for production 572
///
/// PackageItem: FunctionDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PackageItemFunctionDeclaration {
    pub function_declaration: Box<FunctionDeclaration>,
}

///
/// Type derived for production 573
///
/// Description: ModuleDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DescriptionModuleDeclaration {
    pub module_declaration: Box<ModuleDeclaration>,
}

///
/// Type derived for production 574
///
/// Description: InterfaceDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DescriptionInterfaceDeclaration {
    pub interface_declaration: Box<InterfaceDeclaration>,
}

///
/// Type derived for production 575
///
/// Description: PackageDeclaration;
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DescriptionPackageDeclaration {
    pub package_declaration: Box<PackageDeclaration>,
}

// -------------------------------------------------------------------------------------------------
//
// Types of non-terminals deduced from the structure of the transformed grammar
//

///
/// Type derived for non-terminal AllBit
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AllBit {
    pub all_bit_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal AllBitTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AllBitTerm {
    pub all_bit_term: crate::veryl_token::Token, /* '[01] */
}

///
/// Type derived for non-terminal AllBitToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AllBitToken {
    pub all_bit_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal AlwaysComb
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AlwaysComb {
    pub always_comb_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal AlwaysCombDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AlwaysCombDeclaration {
    pub always_comb: Box<AlwaysComb>,
    pub l_brace: Box<LBrace>,
    pub always_comb_declaration_list: Vec<AlwaysCombDeclarationList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal AlwaysCombDeclarationList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AlwaysCombDeclarationList {
    pub statement: Box<Statement>,
}

///
/// Type derived for non-terminal AlwaysCombTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AlwaysCombTerm {
    pub always_comb_term: crate::veryl_token::Token, /* \balways_comb\b */
}

///
/// Type derived for non-terminal AlwaysCombToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AlwaysCombToken {
    pub always_comb_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal AlwaysFf
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AlwaysFf {
    pub always_ff_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal AlwaysFfClock
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AlwaysFfClock {
    pub always_ff_clock_opt: Option<Box<AlwaysFfClockOpt>>,
    pub hierarchical_identifier: Box<HierarchicalIdentifier>,
}

///
/// Type derived for non-terminal AlwaysFfClockOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AlwaysFfClockOpt {
    pub always_ff_clock_opt_group: Box<AlwaysFfClockOptGroup>,
}

///
/// Type derived for non-terminal AlwaysFfClockOptGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum AlwaysFfClockOptGroup {
    Posedge(AlwaysFfClockOptGroupPosedge),
    Negedge(AlwaysFfClockOptGroupNegedge),
}

///
/// Type derived for non-terminal AlwaysFfDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AlwaysFfDeclaration {
    pub always_ff: Box<AlwaysFf>,
    pub l_paren: Box<LParen>,
    pub always_ff_clock: Box<AlwaysFfClock>,
    pub always_ff_declaration_opt: Option<Box<AlwaysFfDeclarationOpt>>,
    pub r_paren: Box<RParen>,
    pub l_brace: Box<LBrace>,
    pub always_ff_declaration_list: Vec<AlwaysFfDeclarationList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal AlwaysFfDeclarationList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AlwaysFfDeclarationList {
    pub statement: Box<Statement>,
}

///
/// Type derived for non-terminal AlwaysFfDeclarationOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AlwaysFfDeclarationOpt {
    pub comma: Box<Comma>,
    pub always_ff_reset: Box<AlwaysFfReset>,
}

///
/// Type derived for non-terminal AlwaysFfReset
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AlwaysFfReset {
    pub always_ff_reset_opt: Option<Box<AlwaysFfResetOpt>>,
    pub hierarchical_identifier: Box<HierarchicalIdentifier>,
}

///
/// Type derived for non-terminal AlwaysFfResetOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AlwaysFfResetOpt {
    pub always_ff_reset_opt_group: Box<AlwaysFfResetOptGroup>,
}

///
/// Type derived for non-terminal AlwaysFfResetOptGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum AlwaysFfResetOptGroup {
    AsyncLow(AlwaysFfResetOptGroupAsyncLow),
    AsyncHigh(AlwaysFfResetOptGroupAsyncHigh),
    SyncLow(AlwaysFfResetOptGroupSyncLow),
    SyncHigh(AlwaysFfResetOptGroupSyncHigh),
}

///
/// Type derived for non-terminal AlwaysFfTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AlwaysFfTerm {
    pub always_ff_term: crate::veryl_token::Token, /* \balways_ff\b */
}

///
/// Type derived for non-terminal AlwaysFfToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AlwaysFfToken {
    pub always_ff_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Assign
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Assign {
    pub assign_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal AssignDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AssignDeclaration {
    pub assign: Box<Assign>,
    pub hierarchical_identifier: Box<HierarchicalIdentifier>,
    pub equ: Box<Equ>,
    pub expression: Box<Expression>,
    pub semicolon: Box<Semicolon>,
}

///
/// Type derived for non-terminal AssignTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AssignTerm {
    pub assign_term: crate::veryl_token::Token, /* \bassign\b */
}

///
/// Type derived for non-terminal AssignToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AssignToken {
    pub assign_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal AssignmentOperator
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AssignmentOperator {
    pub assignment_operator_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal AssignmentOperatorTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AssignmentOperatorTerm {
    pub assignment_operator_term: crate::veryl_token::Token, /* \+=|-=|\*=|/=|%=|&=|\|=|\^=|<<=|>>=|<<<=|>>>= */
}

///
/// Type derived for non-terminal AssignmentOperatorToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AssignmentOperatorToken {
    pub assignment_operator_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal AssignmentStatement
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AssignmentStatement {
    pub hierarchical_identifier: Box<HierarchicalIdentifier>,
    pub assignment_statement_group: Box<AssignmentStatementGroup>,
    pub expression: Box<Expression>,
    pub semicolon: Box<Semicolon>,
}

///
/// Type derived for non-terminal AssignmentStatementGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum AssignmentStatementGroup {
    Equ(AssignmentStatementGroupEqu),
    AssignmentOperator(AssignmentStatementGroupAssignmentOperator),
}

///
/// Type derived for non-terminal AsyncHigh
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AsyncHigh {
    pub async_high_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal AsyncHighTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AsyncHighTerm {
    pub async_high_term: crate::veryl_token::Token, /* \basync_high\b */
}

///
/// Type derived for non-terminal AsyncHighToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AsyncHighToken {
    pub async_high_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal AsyncLow
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AsyncLow {
    pub async_low_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal AsyncLowTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AsyncLowTerm {
    pub async_low_term: crate::veryl_token::Token, /* \basync_low\b */
}

///
/// Type derived for non-terminal AsyncLowToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct AsyncLowToken {
    pub async_low_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal BaseLess
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BaseLess {
    pub base_less_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal BaseLessTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BaseLessTerm {
    pub base_less_term: crate::veryl_token::Token, /* [0-9]+(?:_[0-9]+)* */
}

///
/// Type derived for non-terminal BaseLessToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BaseLessToken {
    pub base_less_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Based
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Based {
    pub based_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal BasedTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BasedTerm {
    pub based_term: crate::veryl_token::Token, /* [0-9]+(?:_[0-9]+)*'[bodh][0-9a-fA-FxzXZ]+(?:_[0-9a-fA-FxzXZ]+)* */
}

///
/// Type derived for non-terminal BasedToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BasedToken {
    pub based_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Bit
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Bit {
    pub bit_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal BitTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BitTerm {
    pub bit_term: crate::veryl_token::Token, /* \bbit\b */
}

///
/// Type derived for non-terminal BitToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct BitToken {
    pub bit_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal BuiltinType
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum BuiltinType {
    Logic(BuiltinTypeLogic),
    Bit(BuiltinTypeBit),
    U32(BuiltinTypeU32),
    U64(BuiltinTypeU64),
    I32(BuiltinTypeI32),
    I64(BuiltinTypeI64),
    F32(BuiltinTypeF32),
    F64(BuiltinTypeF64),
}

///
/// Type derived for non-terminal Case
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Case {
    pub case_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal CaseItem
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CaseItem {
    pub case_item_group: Box<CaseItemGroup>,
    pub colon: Box<Colon>,
    pub case_item_group0: Box<CaseItemGroup0>,
}

///
/// Type derived for non-terminal CaseItemGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum CaseItemGroup {
    Expression(CaseItemGroupExpression),
    Defaul(CaseItemGroupDefaul),
}

///
/// Type derived for non-terminal CaseItemGroup0
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum CaseItemGroup0 {
    Statement(CaseItemGroup0Statement),
    LBraceCaseItemGroup0ListRBrace(CaseItemGroup0LBraceCaseItemGroup0ListRBrace),
}

///
/// Type derived for non-terminal CaseItemGroup0List
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CaseItemGroup0List {
    pub statement: Box<Statement>,
}

///
/// Type derived for non-terminal CaseStatement
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CaseStatement {
    pub case: Box<Case>,
    pub expression: Box<Expression>,
    pub l_brace: Box<LBrace>,
    pub case_statement_list: Vec<CaseStatementList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal CaseStatementList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CaseStatementList {
    pub case_item: Box<CaseItem>,
}

///
/// Type derived for non-terminal CaseTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CaseTerm {
    pub case_term: crate::veryl_token::Token, /* \bcase\b */
}

///
/// Type derived for non-terminal CaseToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CaseToken {
    pub case_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Colon
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Colon {
    pub colon_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal ColonColon
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ColonColon {
    pub colon_colon_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal ColonColonTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ColonColonTerm {
    pub colon_colon_term: crate::veryl_token::Token, /* :: */
}

///
/// Type derived for non-terminal ColonColonToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ColonColonToken {
    pub colon_colon_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal ColonTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ColonTerm {
    pub colon_term: crate::veryl_token::Token, /* : */
}

///
/// Type derived for non-terminal ColonToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ColonToken {
    pub colon_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Comma
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Comma {
    pub comma_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal CommaTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CommaTerm {
    pub comma_term: crate::veryl_token::Token, /* , */
}

///
/// Type derived for non-terminal CommaToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CommaToken {
    pub comma_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Comments
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Comments {
    pub comments_opt: Option<Box<CommentsOpt>>,
}

///
/// Type derived for non-terminal CommentsOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CommentsOpt {
    pub comments_term: Box<CommentsTerm>,
}

///
/// Type derived for non-terminal CommentsTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct CommentsTerm {
    pub comments_term: crate::veryl_token::Token, /* (?:(?:(?://.*(?:\r\n|\r|\n|$))|(?:(?ms)/\u{2a}.*?\u{2a}/))\s*)+ */
}

///
/// Type derived for non-terminal Defaul
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Defaul {
    pub default_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal DefaultTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DefaultTerm {
    pub default_term: crate::veryl_token::Token, /* \bdefault\b */
}

///
/// Type derived for non-terminal DefaultToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DefaultToken {
    pub default_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Description
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Description {
    ModuleDeclaration(DescriptionModuleDeclaration),
    InterfaceDeclaration(DescriptionInterfaceDeclaration),
    PackageDeclaration(DescriptionPackageDeclaration),
}

///
/// Type derived for non-terminal Direction
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Direction {
    Input(DirectionInput),
    Output(DirectionOutput),
    Inout(DirectionInout),
    Ref(DirectionRef),
}

///
/// Type derived for non-terminal Dollar
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Dollar {
    pub dollar_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal DollarTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DollarTerm {
    pub dollar_term: crate::veryl_token::Token, /* $ */
}

///
/// Type derived for non-terminal DollarToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DollarToken {
    pub dollar_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Dot
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Dot {
    pub dot_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal DotDot
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DotDot {
    pub dot_dot_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal DotDotTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DotDotTerm {
    pub dot_dot_term: crate::veryl_token::Token, /* .. */
}

///
/// Type derived for non-terminal DotDotToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DotDotToken {
    pub dot_dot_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal DotTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DotTerm {
    pub dot_term: crate::veryl_token::Token, /* . */
}

///
/// Type derived for non-terminal DotToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct DotToken {
    pub dot_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Else
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Else {
    pub else_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal ElseTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElseTerm {
    pub else_term: crate::veryl_token::Token, /* \belse\b */
}

///
/// Type derived for non-terminal ElseToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ElseToken {
    pub else_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Enum
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Enum {
    pub enum_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal EnumDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EnumDeclaration {
    pub r#enum: Box<Enum>,
    pub identifier: Box<Identifier>,
    pub colon: Box<Colon>,
    pub r#type: Box<Type>,
    pub l_brace: Box<LBrace>,
    pub enum_list: Box<EnumList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal EnumItem
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EnumItem {
    pub identifier: Box<Identifier>,
    pub enum_item_opt: Option<Box<EnumItemOpt>>,
}

///
/// Type derived for non-terminal EnumItemOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EnumItemOpt {
    pub equ: Box<Equ>,
    pub expression: Box<Expression>,
}

///
/// Type derived for non-terminal EnumList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EnumList {
    pub enum_item: Box<EnumItem>,
    pub enum_list_list: Vec<EnumListList>,
    pub enum_list_opt: Option<Box<EnumListOpt>>,
}

///
/// Type derived for non-terminal EnumListList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EnumListList {
    pub comma: Box<Comma>,
    pub enum_item: Box<EnumItem>,
}

///
/// Type derived for non-terminal EnumListOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EnumListOpt {
    pub comma: Box<Comma>,
}

///
/// Type derived for non-terminal EnumTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EnumTerm {
    pub enum_term: crate::veryl_token::Token, /* \benum\b */
}

///
/// Type derived for non-terminal EnumToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EnumToken {
    pub enum_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Equ
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Equ {
    pub equ_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal EquTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EquTerm {
    pub equ_term: crate::veryl_token::Token, /* = */
}

///
/// Type derived for non-terminal EquToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct EquToken {
    pub equ_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Exponent
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Exponent {
    pub exponent_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal ExponentTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ExponentTerm {
    pub exponent_term: crate::veryl_token::Token, /* [0-9]+(?:_[0-9]+)*\.[0-9]+(?:_[0-9]+)*[eE][+-]?[0-9]+(?:_[0-9]+)* */
}

///
/// Type derived for non-terminal ExponentToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ExponentToken {
    pub exponent_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Expression
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression {
    pub expression01: Box<Expression01>,
    pub expression_list: Vec<ExpressionList>,
}

///
/// Type derived for non-terminal Expression01
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression01 {
    pub expression02: Box<Expression02>,
    pub expression01_list: Vec<Expression01List>,
}

///
/// Type derived for non-terminal Expression01List
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression01List {
    pub operator02: Box<Operator02>,
    pub expression02: Box<Expression02>,
}

///
/// Type derived for non-terminal Expression02
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression02 {
    pub expression03: Box<Expression03>,
    pub expression02_list: Vec<Expression02List>,
}

///
/// Type derived for non-terminal Expression02List
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression02List {
    pub operator03: Box<Operator03>,
    pub expression03: Box<Expression03>,
}

///
/// Type derived for non-terminal Expression03
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression03 {
    pub expression04: Box<Expression04>,
    pub expression03_list: Vec<Expression03List>,
}

///
/// Type derived for non-terminal Expression03List
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression03List {
    pub operator04: Box<Operator04>,
    pub expression04: Box<Expression04>,
}

///
/// Type derived for non-terminal Expression04
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression04 {
    pub expression05: Box<Expression05>,
    pub expression04_list: Vec<Expression04List>,
}

///
/// Type derived for non-terminal Expression04List
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression04List {
    pub operator05: Box<Operator05>,
    pub expression05: Box<Expression05>,
}

///
/// Type derived for non-terminal Expression05
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression05 {
    pub expression06: Box<Expression06>,
    pub expression05_list: Vec<Expression05List>,
}

///
/// Type derived for non-terminal Expression05List
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression05List {
    pub operator06: Box<Operator06>,
    pub expression06: Box<Expression06>,
}

///
/// Type derived for non-terminal Expression06
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression06 {
    pub expression07: Box<Expression07>,
    pub expression06_list: Vec<Expression06List>,
}

///
/// Type derived for non-terminal Expression06List
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression06List {
    pub operator07: Box<Operator07>,
    pub expression07: Box<Expression07>,
}

///
/// Type derived for non-terminal Expression07
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression07 {
    pub expression08: Box<Expression08>,
    pub expression07_list: Vec<Expression07List>,
}

///
/// Type derived for non-terminal Expression07List
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression07List {
    pub operator08: Box<Operator08>,
    pub expression08: Box<Expression08>,
}

///
/// Type derived for non-terminal Expression08
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression08 {
    pub expression09: Box<Expression09>,
    pub expression08_list: Vec<Expression08List>,
}

///
/// Type derived for non-terminal Expression08List
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression08List {
    pub operator09: Box<Operator09>,
    pub expression09: Box<Expression09>,
}

///
/// Type derived for non-terminal Expression09
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression09 {
    pub expression10: Box<Expression10>,
    pub expression09_list: Vec<Expression09List>,
}

///
/// Type derived for non-terminal Expression09List
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression09List {
    pub operator10: Box<Operator10>,
    pub expression10: Box<Expression10>,
}

///
/// Type derived for non-terminal Expression10
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression10 {
    pub expression11: Box<Expression11>,
    pub expression10_list: Vec<Expression10List>,
}

///
/// Type derived for non-terminal Expression10List
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression10List {
    pub operator11: Box<Operator11>,
    pub expression11: Box<Expression11>,
}

///
/// Type derived for non-terminal Expression11
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression11 {
    pub expression11_list: Vec<Expression11List>,
    pub factor: Box<Factor>,
}

///
/// Type derived for non-terminal Expression11List
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Expression11List {
    pub expression11_list_group: Box<Expression11ListGroup>,
}

///
/// Type derived for non-terminal Expression11ListGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Expression11ListGroup {
    UnaryOperator(Expression11ListGroupUnaryOperator),
    Operator09(Expression11ListGroupOperator09),
    Operator05(Expression11ListGroupOperator05),
    Operator03(Expression11ListGroupOperator03),
    Operator04(Expression11ListGroupOperator04),
}

///
/// Type derived for non-terminal ExpressionList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ExpressionList {
    pub operator01: Box<Operator01>,
    pub expression01: Box<Expression01>,
}

///
/// Type derived for non-terminal F32
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct F32 {
    pub f32_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal F32Term
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct F32Term {
    pub f32_term: crate::veryl_token::Token, /* \bf32\b */
}

///
/// Type derived for non-terminal F32Token
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct F32Token {
    pub f32_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal F64
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct F64 {
    pub f64_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal F64Term
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct F64Term {
    pub f64_term: crate::veryl_token::Token, /* \bf64\b */
}

///
/// Type derived for non-terminal F64Token
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct F64Token {
    pub f64_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Factor
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Factor {
    Number(FactorNumber),
    FactorOptScopedOrHierIdentifierFactorOpt0(FactorFactorOptScopedOrHierIdentifierFactorOpt0),
    LParenExpressionRParen(FactorLParenExpressionRParen),
}

///
/// Type derived for non-terminal FactorOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FactorOpt {
    pub dollar: Box<Dollar>,
}

///
/// Type derived for non-terminal FactorOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FactorOpt0 {
    pub l_paren: Box<LParen>,
    pub factor_opt1: Option<Box<FactorOpt1>>,
    pub r_paren: Box<RParen>,
}

///
/// Type derived for non-terminal FactorOpt1
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FactorOpt1 {
    pub function_call_arg: Box<FunctionCallArg>,
}

///
/// Type derived for non-terminal FixedPoint
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FixedPoint {
    pub fixed_point_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal FixedPointTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FixedPointTerm {
    pub fixed_point_term: crate::veryl_token::Token, /* [0-9]+(?:_[0-9]+)*\.[0-9]+(?:_[0-9]+)* */
}

///
/// Type derived for non-terminal FixedPointToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FixedPointToken {
    pub fixed_point_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal For
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct For {
    pub for_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal ForStatement
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ForStatement {
    pub r#for: Box<For>,
    pub identifier: Box<Identifier>,
    pub colon: Box<Colon>,
    pub r#type: Box<Type>,
    pub r#in: Box<In>,
    pub expression: Box<Expression>,
    pub dot_dot: Box<DotDot>,
    pub expression0: Box<Expression>,
    pub for_statement_opt: Option<Box<ForStatementOpt>>,
    pub l_brace: Box<LBrace>,
    pub for_statement_list: Vec<ForStatementList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal ForStatementList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ForStatementList {
    pub statement: Box<Statement>,
}

///
/// Type derived for non-terminal ForStatementOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ForStatementOpt {
    pub step: Box<Step>,
    pub assignment_operator: Box<AssignmentOperator>,
    pub expression: Box<Expression>,
}

///
/// Type derived for non-terminal ForTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ForTerm {
    pub for_term: crate::veryl_token::Token, /* \bfor\b */
}

///
/// Type derived for non-terminal ForToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ForToken {
    pub for_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Function
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Function {
    pub function_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal FunctionCallArg
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FunctionCallArg {
    pub expression: Box<Expression>,
    pub function_call_arg_list: Vec<FunctionCallArgList>,
    pub function_call_arg_opt: Option<Box<FunctionCallArgOpt>>,
}

///
/// Type derived for non-terminal FunctionCallArgList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FunctionCallArgList {
    pub comma: Box<Comma>,
    pub expression: Box<Expression>,
}

///
/// Type derived for non-terminal FunctionCallArgOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FunctionCallArgOpt {
    pub comma: Box<Comma>,
}

///
/// Type derived for non-terminal FunctionDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FunctionDeclaration {
    pub function: Box<Function>,
    pub identifier: Box<Identifier>,
    pub function_declaration_opt: Option<Box<FunctionDeclarationOpt>>,
    pub function_declaration_opt0: Option<Box<FunctionDeclarationOpt0>>,
    pub minus_g_t: Box<MinusGT>,
    pub r#type: Box<Type>,
    pub l_brace: Box<LBrace>,
    pub function_declaration_list: Vec<FunctionDeclarationList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal FunctionDeclarationList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FunctionDeclarationList {
    pub function_item: Box<FunctionItem>,
}

///
/// Type derived for non-terminal FunctionDeclarationOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FunctionDeclarationOpt {
    pub with_parameter: Box<WithParameter>,
}

///
/// Type derived for non-terminal FunctionDeclarationOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FunctionDeclarationOpt0 {
    pub port_declaration: Box<PortDeclaration>,
}

///
/// Type derived for non-terminal FunctionItem
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum FunctionItem {
    VarDeclaration(FunctionItemVarDeclaration),
    Statement(FunctionItemStatement),
}

///
/// Type derived for non-terminal FunctionTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FunctionTerm {
    pub function_term: crate::veryl_token::Token, /* \bfunction\b */
}

///
/// Type derived for non-terminal FunctionToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct FunctionToken {
    pub function_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Hash
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Hash {
    pub hash_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal HashTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct HashTerm {
    pub hash_term: crate::veryl_token::Token, /* # */
}

///
/// Type derived for non-terminal HashToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct HashToken {
    pub hash_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal HierarchicalIdentifier
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct HierarchicalIdentifier {
    pub identifier: Box<Identifier>,
    pub hierarchical_identifier_list: Vec<HierarchicalIdentifierList>,
    pub hierarchical_identifier_list0: Vec<HierarchicalIdentifierList0>,
}

///
/// Type derived for non-terminal HierarchicalIdentifierList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct HierarchicalIdentifierList {
    pub range: Box<Range>,
}

///
/// Type derived for non-terminal HierarchicalIdentifierList0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct HierarchicalIdentifierList0 {
    pub dot: Box<Dot>,
    pub identifier: Box<Identifier>,
    pub hierarchical_identifier_list0_list: Vec<HierarchicalIdentifierList0List>,
}

///
/// Type derived for non-terminal HierarchicalIdentifierList0List
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct HierarchicalIdentifierList0List {
    pub range: Box<Range>,
}

///
/// Type derived for non-terminal I32
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct I32 {
    pub i32_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal I32Term
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct I32Term {
    pub i32_term: crate::veryl_token::Token, /* \bi32\b */
}

///
/// Type derived for non-terminal I32Token
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct I32Token {
    pub i32_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal I64
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct I64 {
    pub i64_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal I64Term
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct I64Term {
    pub i64_term: crate::veryl_token::Token, /* \bi64\b */
}

///
/// Type derived for non-terminal I64Token
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct I64Token {
    pub i64_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Identifier
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Identifier {
    pub identifier_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal IdentifierTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IdentifierTerm {
    pub identifier_term: crate::veryl_token::Token, /* [a-zA-Z_][0-9a-zA-Z_]* */
}

///
/// Type derived for non-terminal IdentifierToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IdentifierToken {
    pub identifier_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal If
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct If {
    pub if_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal IfReset
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IfReset {
    pub if_reset_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal IfResetStatement
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IfResetStatement {
    pub if_reset: Box<IfReset>,
    pub l_brace: Box<LBrace>,
    pub if_reset_statement_list: Vec<IfResetStatementList>,
    pub r_brace: Box<RBrace>,
    pub if_reset_statement_list0: Vec<IfResetStatementList0>,
    pub if_reset_statement_opt: Option<Box<IfResetStatementOpt>>,
}

///
/// Type derived for non-terminal IfResetStatementList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IfResetStatementList {
    pub statement: Box<Statement>,
}

///
/// Type derived for non-terminal IfResetStatementList0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IfResetStatementList0 {
    pub r#else: Box<Else>,
    pub r#if: Box<If>,
    pub expression: Box<Expression>,
    pub l_brace: Box<LBrace>,
    pub if_reset_statement_list0_list: Vec<IfResetStatementList0List>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal IfResetStatementList0List
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IfResetStatementList0List {
    pub statement: Box<Statement>,
}

///
/// Type derived for non-terminal IfResetStatementOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IfResetStatementOpt {
    pub r#else: Box<Else>,
    pub l_brace: Box<LBrace>,
    pub if_reset_statement_opt_list: Vec<IfResetStatementOptList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal IfResetStatementOptList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IfResetStatementOptList {
    pub statement: Box<Statement>,
}

///
/// Type derived for non-terminal IfResetTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IfResetTerm {
    pub if_reset_term: crate::veryl_token::Token, /* \bif_reset\b */
}

///
/// Type derived for non-terminal IfResetToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IfResetToken {
    pub if_reset_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal IfStatement
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IfStatement {
    pub r#if: Box<If>,
    pub expression: Box<Expression>,
    pub l_brace: Box<LBrace>,
    pub if_statement_list: Vec<IfStatementList>,
    pub r_brace: Box<RBrace>,
    pub if_statement_list0: Vec<IfStatementList0>,
    pub if_statement_opt: Option<Box<IfStatementOpt>>,
}

///
/// Type derived for non-terminal IfStatementList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IfStatementList {
    pub statement: Box<Statement>,
}

///
/// Type derived for non-terminal IfStatementList0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IfStatementList0 {
    pub r#else: Box<Else>,
    pub r#if: Box<If>,
    pub expression: Box<Expression>,
    pub l_brace: Box<LBrace>,
    pub if_statement_list0_list: Vec<IfStatementList0List>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal IfStatementList0List
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IfStatementList0List {
    pub statement: Box<Statement>,
}

///
/// Type derived for non-terminal IfStatementOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IfStatementOpt {
    pub r#else: Box<Else>,
    pub l_brace: Box<LBrace>,
    pub if_statement_opt_list: Vec<IfStatementOptList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal IfStatementOptList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IfStatementOptList {
    pub statement: Box<Statement>,
}

///
/// Type derived for non-terminal IfTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IfTerm {
    pub if_term: crate::veryl_token::Token, /* \bif\b */
}

///
/// Type derived for non-terminal IfToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct IfToken {
    pub if_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal In
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct In {
    pub in_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal InTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InTerm {
    pub in_term: crate::veryl_token::Token, /* \bin\b */
}

///
/// Type derived for non-terminal InToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InToken {
    pub in_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Inout
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Inout {
    pub inout_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal InoutTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InoutTerm {
    pub inout_term: crate::veryl_token::Token, /* \binout\b */
}

///
/// Type derived for non-terminal InoutToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InoutToken {
    pub inout_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Input
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Input {
    pub input_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal InputTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InputTerm {
    pub input_term: crate::veryl_token::Token, /* \binput\b */
}

///
/// Type derived for non-terminal InputToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InputToken {
    pub input_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Inst
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Inst {
    pub inst_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal InstDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InstDeclaration {
    pub inst: Box<Inst>,
    pub identifier: Box<Identifier>,
    pub colon: Box<Colon>,
    pub identifier0: Box<Identifier>,
    pub inst_declaration_opt: Option<Box<InstDeclarationOpt>>,
    pub inst_declaration_opt0: Option<Box<InstDeclarationOpt0>>,
    pub inst_declaration_opt1: Option<Box<InstDeclarationOpt1>>,
    pub semicolon: Box<Semicolon>,
}

///
/// Type derived for non-terminal InstDeclarationOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InstDeclarationOpt {
    pub width: Box<Width>,
}

///
/// Type derived for non-terminal InstDeclarationOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InstDeclarationOpt0 {
    pub inst_parameter: Box<InstParameter>,
}

///
/// Type derived for non-terminal InstDeclarationOpt1
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InstDeclarationOpt1 {
    pub l_brace: Box<LBrace>,
    pub inst_declaration_opt2: Option<Box<InstDeclarationOpt2>>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal InstDeclarationOpt2
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InstDeclarationOpt2 {
    pub inst_port_list: Box<InstPortList>,
}

///
/// Type derived for non-terminal InstParameter
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InstParameter {
    pub hash: Box<Hash>,
    pub l_paren: Box<LParen>,
    pub inst_parameter_opt: Option<Box<InstParameterOpt>>,
    pub r_paren: Box<RParen>,
}

///
/// Type derived for non-terminal InstParameterItem
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InstParameterItem {
    pub identifier: Box<Identifier>,
    pub inst_parameter_item_opt: Option<Box<InstParameterItemOpt>>,
}

///
/// Type derived for non-terminal InstParameterItemOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InstParameterItemOpt {
    pub colon: Box<Colon>,
    pub expression: Box<Expression>,
}

///
/// Type derived for non-terminal InstParameterList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InstParameterList {
    pub inst_parameter_item: Box<InstParameterItem>,
    pub inst_parameter_list_list: Vec<InstParameterListList>,
    pub inst_parameter_list_opt: Option<Box<InstParameterListOpt>>,
}

///
/// Type derived for non-terminal InstParameterListList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InstParameterListList {
    pub comma: Box<Comma>,
    pub inst_parameter_item: Box<InstParameterItem>,
}

///
/// Type derived for non-terminal InstParameterListOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InstParameterListOpt {
    pub comma: Box<Comma>,
}

///
/// Type derived for non-terminal InstParameterOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InstParameterOpt {
    pub inst_parameter_list: Box<InstParameterList>,
}

///
/// Type derived for non-terminal InstPortItem
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InstPortItem {
    pub identifier: Box<Identifier>,
    pub inst_port_item_opt: Option<Box<InstPortItemOpt>>,
}

///
/// Type derived for non-terminal InstPortItemOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InstPortItemOpt {
    pub colon: Box<Colon>,
    pub expression: Box<Expression>,
}

///
/// Type derived for non-terminal InstPortList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InstPortList {
    pub inst_port_item: Box<InstPortItem>,
    pub inst_port_list_list: Vec<InstPortListList>,
    pub inst_port_list_opt: Option<Box<InstPortListOpt>>,
}

///
/// Type derived for non-terminal InstPortListList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InstPortListList {
    pub comma: Box<Comma>,
    pub inst_port_item: Box<InstPortItem>,
}

///
/// Type derived for non-terminal InstPortListOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InstPortListOpt {
    pub comma: Box<Comma>,
}

///
/// Type derived for non-terminal InstTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InstTerm {
    pub inst_term: crate::veryl_token::Token, /* \binst\b */
}

///
/// Type derived for non-terminal InstToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InstToken {
    pub inst_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal IntegralNumber
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum IntegralNumber {
    Based(IntegralNumberBased),
    BaseLess(IntegralNumberBaseLess),
    AllBit(IntegralNumberAllBit),
}

///
/// Type derived for non-terminal Interface
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Interface {
    pub interface_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal InterfaceDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InterfaceDeclaration {
    pub interface: Box<Interface>,
    pub identifier: Box<Identifier>,
    pub interface_declaration_opt: Option<Box<InterfaceDeclarationOpt>>,
    pub l_brace: Box<LBrace>,
    pub interface_declaration_list: Vec<InterfaceDeclarationList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal InterfaceDeclarationList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InterfaceDeclarationList {
    pub interface_item: Box<InterfaceItem>,
}

///
/// Type derived for non-terminal InterfaceDeclarationOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InterfaceDeclarationOpt {
    pub with_parameter: Box<WithParameter>,
}

///
/// Type derived for non-terminal InterfaceForDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InterfaceForDeclaration {
    pub r#for: Box<For>,
    pub identifier: Box<Identifier>,
    pub r#in: Box<In>,
    pub expression: Box<Expression>,
    pub dot_dot: Box<DotDot>,
    pub expression0: Box<Expression>,
    pub interface_for_declaration_opt: Option<Box<InterfaceForDeclarationOpt>>,
    pub interface_named_block: Box<InterfaceNamedBlock>,
}

///
/// Type derived for non-terminal InterfaceForDeclarationOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InterfaceForDeclarationOpt {
    pub step: Box<Step>,
    pub assignment_operator: Box<AssignmentOperator>,
    pub expression: Box<Expression>,
}

///
/// Type derived for non-terminal InterfaceIfDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InterfaceIfDeclaration {
    pub r#if: Box<If>,
    pub expression: Box<Expression>,
    pub interface_named_block: Box<InterfaceNamedBlock>,
    pub interface_if_declaration_list: Vec<InterfaceIfDeclarationList>,
    pub interface_if_declaration_opt: Option<Box<InterfaceIfDeclarationOpt>>,
}

///
/// Type derived for non-terminal InterfaceIfDeclarationList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InterfaceIfDeclarationList {
    pub r#else: Box<Else>,
    pub r#if: Box<If>,
    pub expression: Box<Expression>,
    pub interface_optional_named_block: Box<InterfaceOptionalNamedBlock>,
}

///
/// Type derived for non-terminal InterfaceIfDeclarationOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InterfaceIfDeclarationOpt {
    pub r#else: Box<Else>,
    pub interface_optional_named_block: Box<InterfaceOptionalNamedBlock>,
}

///
/// Type derived for non-terminal InterfaceItem
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum InterfaceItem {
    VarDeclaration(InterfaceItemVarDeclaration),
    LocalparamDeclaration(InterfaceItemLocalparamDeclaration),
    ModportDeclaration(InterfaceItemModportDeclaration),
    InterfaceIfDeclaration(InterfaceItemInterfaceIfDeclaration),
    InterfaceForDeclaration(InterfaceItemInterfaceForDeclaration),
    EnumDeclaration(InterfaceItemEnumDeclaration),
    StructDeclaration(InterfaceItemStructDeclaration),
    InterfaceNamedBlock(InterfaceItemInterfaceNamedBlock),
    FunctionDeclaration(InterfaceItemFunctionDeclaration),
}

///
/// Type derived for non-terminal InterfaceNamedBlock
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InterfaceNamedBlock {
    pub colon: Box<Colon>,
    pub identifier: Box<Identifier>,
    pub l_brace: Box<LBrace>,
    pub interface_named_block_list: Vec<InterfaceNamedBlockList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal InterfaceNamedBlockList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InterfaceNamedBlockList {
    pub interface_item: Box<InterfaceItem>,
}

///
/// Type derived for non-terminal InterfaceOptionalNamedBlock
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InterfaceOptionalNamedBlock {
    pub interface_optional_named_block_opt: Option<Box<InterfaceOptionalNamedBlockOpt>>,
    pub l_brace: Box<LBrace>,
    pub interface_optional_named_block_list: Vec<InterfaceOptionalNamedBlockList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal InterfaceOptionalNamedBlockList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InterfaceOptionalNamedBlockList {
    pub interface_item: Box<InterfaceItem>,
}

///
/// Type derived for non-terminal InterfaceOptionalNamedBlockOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InterfaceOptionalNamedBlockOpt {
    pub colon: Box<Colon>,
    pub identifier: Box<Identifier>,
}

///
/// Type derived for non-terminal InterfaceTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InterfaceTerm {
    pub interface_term: crate::veryl_token::Token, /* \binterface\b */
}

///
/// Type derived for non-terminal InterfaceToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct InterfaceToken {
    pub interface_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal LBrace
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LBrace {
    pub l_brace_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal LBraceTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LBraceTerm {
    pub l_brace_term: crate::veryl_token::Token, /* { */
}

///
/// Type derived for non-terminal LBraceToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LBraceToken {
    pub l_brace_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal LBracket
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LBracket {
    pub l_bracket_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal LBracketTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LBracketTerm {
    pub l_bracket_term: crate::veryl_token::Token, /* [ */
}

///
/// Type derived for non-terminal LBracketToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LBracketToken {
    pub l_bracket_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal LParen
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LParen {
    pub l_paren_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal LParenTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LParenTerm {
    pub l_paren_term: crate::veryl_token::Token, /* ( */
}

///
/// Type derived for non-terminal LParenToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LParenToken {
    pub l_paren_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Localparam
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Localparam {
    pub localparam_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal LocalparamDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LocalparamDeclaration {
    pub localparam: Box<Localparam>,
    pub identifier: Box<Identifier>,
    pub colon: Box<Colon>,
    pub r#type: Box<Type>,
    pub equ: Box<Equ>,
    pub expression: Box<Expression>,
    pub semicolon: Box<Semicolon>,
}

///
/// Type derived for non-terminal LocalparamTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LocalparamTerm {
    pub localparam_term: crate::veryl_token::Token, /* \blocalparam\b */
}

///
/// Type derived for non-terminal LocalparamToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LocalparamToken {
    pub localparam_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Logic
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Logic {
    pub logic_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal LogicTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LogicTerm {
    pub logic_term: crate::veryl_token::Token, /* \blogic\b */
}

///
/// Type derived for non-terminal LogicToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct LogicToken {
    pub logic_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal MinusColon
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MinusColon {
    pub minus_colon_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal MinusColonTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MinusColonTerm {
    pub minus_colon_term: crate::veryl_token::Token, /* -: */
}

///
/// Type derived for non-terminal MinusColonToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MinusColonToken {
    pub minus_colon_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal MinusGT
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MinusGT {
    pub minus_g_t_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal MinusGTTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MinusGTTerm {
    pub minus_g_t_term: crate::veryl_token::Token, /* -> */
}

///
/// Type derived for non-terminal MinusGTToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct MinusGTToken {
    pub minus_g_t_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Modport
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Modport {
    pub modport_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal ModportDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModportDeclaration {
    pub modport: Box<Modport>,
    pub identifier: Box<Identifier>,
    pub l_brace: Box<LBrace>,
    pub modport_list: Box<ModportList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal ModportItem
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModportItem {
    pub identifier: Box<Identifier>,
    pub colon: Box<Colon>,
    pub direction: Box<Direction>,
}

///
/// Type derived for non-terminal ModportList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModportList {
    pub modport_item: Box<ModportItem>,
    pub modport_list_list: Vec<ModportListList>,
    pub modport_list_opt: Option<Box<ModportListOpt>>,
}

///
/// Type derived for non-terminal ModportListList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModportListList {
    pub comma: Box<Comma>,
    pub modport_item: Box<ModportItem>,
}

///
/// Type derived for non-terminal ModportListOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModportListOpt {
    pub comma: Box<Comma>,
}

///
/// Type derived for non-terminal ModportTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModportTerm {
    pub modport_term: crate::veryl_token::Token, /* \bmodport\b */
}

///
/// Type derived for non-terminal ModportToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModportToken {
    pub modport_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Module
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Module {
    pub module_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal ModuleDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleDeclaration {
    pub module: Box<Module>,
    pub identifier: Box<Identifier>,
    pub module_declaration_opt: Option<Box<ModuleDeclarationOpt>>,
    pub module_declaration_opt0: Option<Box<ModuleDeclarationOpt0>>,
    pub l_brace: Box<LBrace>,
    pub module_declaration_list: Vec<ModuleDeclarationList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal ModuleDeclarationList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleDeclarationList {
    pub module_item: Box<ModuleItem>,
}

///
/// Type derived for non-terminal ModuleDeclarationOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleDeclarationOpt {
    pub with_parameter: Box<WithParameter>,
}

///
/// Type derived for non-terminal ModuleDeclarationOpt0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleDeclarationOpt0 {
    pub port_declaration: Box<PortDeclaration>,
}

///
/// Type derived for non-terminal ModuleForDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleForDeclaration {
    pub r#for: Box<For>,
    pub identifier: Box<Identifier>,
    pub r#in: Box<In>,
    pub expression: Box<Expression>,
    pub dot_dot: Box<DotDot>,
    pub expression0: Box<Expression>,
    pub module_for_declaration_opt: Option<Box<ModuleForDeclarationOpt>>,
    pub module_named_block: Box<ModuleNamedBlock>,
}

///
/// Type derived for non-terminal ModuleForDeclarationOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleForDeclarationOpt {
    pub step: Box<Step>,
    pub assignment_operator: Box<AssignmentOperator>,
    pub expression: Box<Expression>,
}

///
/// Type derived for non-terminal ModuleIfDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleIfDeclaration {
    pub r#if: Box<If>,
    pub expression: Box<Expression>,
    pub module_named_block: Box<ModuleNamedBlock>,
    pub module_if_declaration_list: Vec<ModuleIfDeclarationList>,
    pub module_if_declaration_opt: Option<Box<ModuleIfDeclarationOpt>>,
}

///
/// Type derived for non-terminal ModuleIfDeclarationList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleIfDeclarationList {
    pub r#else: Box<Else>,
    pub r#if: Box<If>,
    pub expression: Box<Expression>,
    pub module_optional_named_block: Box<ModuleOptionalNamedBlock>,
}

///
/// Type derived for non-terminal ModuleIfDeclarationOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleIfDeclarationOpt {
    pub r#else: Box<Else>,
    pub module_optional_named_block: Box<ModuleOptionalNamedBlock>,
}

///
/// Type derived for non-terminal ModuleItem
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ModuleItem {
    VarDeclaration(ModuleItemVarDeclaration),
    InstDeclaration(ModuleItemInstDeclaration),
    LocalparamDeclaration(ModuleItemLocalparamDeclaration),
    AlwaysFfDeclaration(ModuleItemAlwaysFfDeclaration),
    AlwaysCombDeclaration(ModuleItemAlwaysCombDeclaration),
    AssignDeclaration(ModuleItemAssignDeclaration),
    FunctionDeclaration(ModuleItemFunctionDeclaration),
    ModuleIfDeclaration(ModuleItemModuleIfDeclaration),
    ModuleForDeclaration(ModuleItemModuleForDeclaration),
    EnumDeclaration(ModuleItemEnumDeclaration),
    StructDeclaration(ModuleItemStructDeclaration),
    ModuleNamedBlock(ModuleItemModuleNamedBlock),
}

///
/// Type derived for non-terminal ModuleNamedBlock
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleNamedBlock {
    pub colon: Box<Colon>,
    pub identifier: Box<Identifier>,
    pub l_brace: Box<LBrace>,
    pub module_named_block_list: Vec<ModuleNamedBlockList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal ModuleNamedBlockList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleNamedBlockList {
    pub module_item: Box<ModuleItem>,
}

///
/// Type derived for non-terminal ModuleOptionalNamedBlock
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleOptionalNamedBlock {
    pub module_optional_named_block_opt: Option<Box<ModuleOptionalNamedBlockOpt>>,
    pub l_brace: Box<LBrace>,
    pub module_optional_named_block_list: Vec<ModuleOptionalNamedBlockList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal ModuleOptionalNamedBlockList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleOptionalNamedBlockList {
    pub module_item: Box<ModuleItem>,
}

///
/// Type derived for non-terminal ModuleOptionalNamedBlockOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleOptionalNamedBlockOpt {
    pub colon: Box<Colon>,
    pub identifier: Box<Identifier>,
}

///
/// Type derived for non-terminal ModuleTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleTerm {
    pub module_term: crate::veryl_token::Token, /* \bmodule\b */
}

///
/// Type derived for non-terminal ModuleToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ModuleToken {
    pub module_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Negedge
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Negedge {
    pub negedge_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal NegedgeTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct NegedgeTerm {
    pub negedge_term: crate::veryl_token::Token, /* \bnegedge\b */
}

///
/// Type derived for non-terminal NegedgeToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct NegedgeToken {
    pub negedge_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Number
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Number {
    IntegralNumber(NumberIntegralNumber),
    RealNumber(NumberRealNumber),
}

///
/// Type derived for non-terminal Operator01
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator01 {
    pub operator01_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal Operator01Term
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator01Term {
    pub operator01_term: crate::veryl_token::Token, /* \|\| */
}

///
/// Type derived for non-terminal Operator01Token
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator01Token {
    pub operator01_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Operator02
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator02 {
    pub operator02_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal Operator02Term
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator02Term {
    pub operator02_term: crate::veryl_token::Token, /* && */
}

///
/// Type derived for non-terminal Operator02Token
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator02Token {
    pub operator02_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Operator03
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator03 {
    pub operator03_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal Operator03Term
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator03Term {
    pub operator03_term: crate::veryl_token::Token, /* \| */
}

///
/// Type derived for non-terminal Operator03Token
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator03Token {
    pub operator03_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Operator04
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator04 {
    pub operator04_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal Operator04Term
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator04Term {
    pub operator04_term: crate::veryl_token::Token, /* \^~|\^|~\^ */
}

///
/// Type derived for non-terminal Operator04Token
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator04Token {
    pub operator04_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Operator05
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator05 {
    pub operator05_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal Operator05Term
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator05Term {
    pub operator05_term: crate::veryl_token::Token, /* & */
}

///
/// Type derived for non-terminal Operator05Token
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator05Token {
    pub operator05_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Operator06
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator06 {
    pub operator06_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal Operator06Term
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator06Term {
    pub operator06_term: crate::veryl_token::Token, /* ===|==\?|!==|!=\?|==|!= */
}

///
/// Type derived for non-terminal Operator06Token
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator06Token {
    pub operator06_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Operator07
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator07 {
    pub operator07_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal Operator07Term
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator07Term {
    pub operator07_term: crate::veryl_token::Token, /* <=|>=|<|> */
}

///
/// Type derived for non-terminal Operator07Token
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator07Token {
    pub operator07_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Operator08
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator08 {
    pub operator08_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal Operator08Term
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator08Term {
    pub operator08_term: crate::veryl_token::Token, /* <<<|>>>|<<|>> */
}

///
/// Type derived for non-terminal Operator08Token
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator08Token {
    pub operator08_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Operator09
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator09 {
    pub operator09_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal Operator09Term
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator09Term {
    pub operator09_term: crate::veryl_token::Token, /* \+|- */
}

///
/// Type derived for non-terminal Operator09Token
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator09Token {
    pub operator09_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Operator10
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator10 {
    pub operator10_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal Operator10Term
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator10Term {
    pub operator10_term: crate::veryl_token::Token, /* \*|/|% */
}

///
/// Type derived for non-terminal Operator10Token
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator10Token {
    pub operator10_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Operator11
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator11 {
    pub operator11_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal Operator11Term
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator11Term {
    pub operator11_term: crate::veryl_token::Token, /* \*\* */
}

///
/// Type derived for non-terminal Operator11Token
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Operator11Token {
    pub operator11_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Output
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Output {
    pub output_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal OutputTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct OutputTerm {
    pub output_term: crate::veryl_token::Token, /* \boutput\b */
}

///
/// Type derived for non-terminal OutputToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct OutputToken {
    pub output_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Package
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Package {
    pub package_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal PackageDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PackageDeclaration {
    pub package: Box<Package>,
    pub identifier: Box<Identifier>,
    pub l_brace: Box<LBrace>,
    pub package_declaration_list: Vec<PackageDeclarationList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal PackageDeclarationList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PackageDeclarationList {
    pub package_item: Box<PackageItem>,
}

///
/// Type derived for non-terminal PackageItem
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum PackageItem {
    VarDeclaration(PackageItemVarDeclaration),
    LocalparamDeclaration(PackageItemLocalparamDeclaration),
    EnumDeclaration(PackageItemEnumDeclaration),
    StructDeclaration(PackageItemStructDeclaration),
    FunctionDeclaration(PackageItemFunctionDeclaration),
}

///
/// Type derived for non-terminal PackageTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PackageTerm {
    pub package_term: crate::veryl_token::Token, /* \bpackage\b */
}

///
/// Type derived for non-terminal PackageToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PackageToken {
    pub package_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Parameter
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Parameter {
    pub parameter_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal ParameterTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ParameterTerm {
    pub parameter_term: crate::veryl_token::Token, /* \bparameter\b */
}

///
/// Type derived for non-terminal ParameterToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ParameterToken {
    pub parameter_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal PlusColon
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PlusColon {
    pub plus_colon_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal PlusColonTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PlusColonTerm {
    pub plus_colon_term: crate::veryl_token::Token, /* +: */
}

///
/// Type derived for non-terminal PlusColonToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PlusColonToken {
    pub plus_colon_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal PortDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PortDeclaration {
    pub l_paren: Box<LParen>,
    pub port_declaration_opt: Option<Box<PortDeclarationOpt>>,
    pub r_paren: Box<RParen>,
}

///
/// Type derived for non-terminal PortDeclarationItem
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PortDeclarationItem {
    pub identifier: Box<Identifier>,
    pub colon: Box<Colon>,
    pub direction: Box<Direction>,
    pub r#type: Box<Type>,
}

///
/// Type derived for non-terminal PortDeclarationList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PortDeclarationList {
    pub port_declaration_item: Box<PortDeclarationItem>,
    pub port_declaration_list_list: Vec<PortDeclarationListList>,
    pub port_declaration_list_opt: Option<Box<PortDeclarationListOpt>>,
}

///
/// Type derived for non-terminal PortDeclarationListList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PortDeclarationListList {
    pub comma: Box<Comma>,
    pub port_declaration_item: Box<PortDeclarationItem>,
}

///
/// Type derived for non-terminal PortDeclarationListOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PortDeclarationListOpt {
    pub comma: Box<Comma>,
}

///
/// Type derived for non-terminal PortDeclarationOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PortDeclarationOpt {
    pub port_declaration_list: Box<PortDeclarationList>,
}

///
/// Type derived for non-terminal Posedge
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Posedge {
    pub posedge_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal PosedgeTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PosedgeTerm {
    pub posedge_term: crate::veryl_token::Token, /* \bposedge\b */
}

///
/// Type derived for non-terminal PosedgeToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct PosedgeToken {
    pub posedge_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal RBrace
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RBrace {
    pub r_brace_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal RBraceTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RBraceTerm {
    pub r_brace_term: crate::veryl_token::Token, /* } */
}

///
/// Type derived for non-terminal RBraceToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RBraceToken {
    pub r_brace_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal RBracket
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RBracket {
    pub r_bracket_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal RBracketTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RBracketTerm {
    pub r_bracket_term: crate::veryl_token::Token, /* ] */
}

///
/// Type derived for non-terminal RBracketToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RBracketToken {
    pub r_bracket_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal RParen
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RParen {
    pub r_paren_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal RParenTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RParenTerm {
    pub r_paren_term: crate::veryl_token::Token, /* ) */
}

///
/// Type derived for non-terminal RParenToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RParenToken {
    pub r_paren_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Range
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Range {
    pub l_bracket: Box<LBracket>,
    pub expression: Box<Expression>,
    pub range_opt: Option<Box<RangeOpt>>,
    pub r_bracket: Box<RBracket>,
}

///
/// Type derived for non-terminal RangeOperator
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum RangeOperator {
    Colon(RangeOperatorColon),
    PlusColon(RangeOperatorPlusColon),
    MinusColon(RangeOperatorMinusColon),
    Step(RangeOperatorStep),
}

///
/// Type derived for non-terminal RangeOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RangeOpt {
    pub range_operator: Box<RangeOperator>,
    pub expression: Box<Expression>,
}

///
/// Type derived for non-terminal RealNumber
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum RealNumber {
    FixedPoint(RealNumberFixedPoint),
    Exponent(RealNumberExponent),
}

///
/// Type derived for non-terminal Ref
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Ref {
    pub ref_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal RefTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RefTerm {
    pub ref_term: crate::veryl_token::Token, /* \bref\b */
}

///
/// Type derived for non-terminal RefToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct RefToken {
    pub ref_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Return
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Return {
    pub return_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal ReturnStatement
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ReturnStatement {
    pub r#return: Box<Return>,
    pub expression: Box<Expression>,
    pub semicolon: Box<Semicolon>,
}

///
/// Type derived for non-terminal ReturnTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ReturnTerm {
    pub return_term: crate::veryl_token::Token, /* \breturn\b */
}

///
/// Type derived for non-terminal ReturnToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ReturnToken {
    pub return_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal ScopedIdentifier
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ScopedIdentifier {
    pub identifier: Box<Identifier>,
    pub scoped_identifier_list: Vec<ScopedIdentifierList>,
}

///
/// Type derived for non-terminal ScopedIdentifierList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ScopedIdentifierList {
    pub colon_colon: Box<ColonColon>,
    pub identifier: Box<Identifier>,
}

///
/// Type derived for non-terminal ScopedOrHierIdentifier
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ScopedOrHierIdentifier {
    pub identifier: Box<Identifier>,
    pub scoped_or_hier_identifier_group: Box<ScopedOrHierIdentifierGroup>,
}

///
/// Type derived for non-terminal ScopedOrHierIdentifierGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ScopedOrHierIdentifierGroup {
    ColonColonIdentifierScopedOrHierIdentifierGroupList(
        ScopedOrHierIdentifierGroupColonColonIdentifierScopedOrHierIdentifierGroupList,
    ),
    ScopedOrHierIdentifierGroupList0ScopedOrHierIdentifierGroupList1(
        ScopedOrHierIdentifierGroupScopedOrHierIdentifierGroupList0ScopedOrHierIdentifierGroupList1,
    ),
}

///
/// Type derived for non-terminal ScopedOrHierIdentifierGroupList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ScopedOrHierIdentifierGroupList {
    pub colon_colon: Box<ColonColon>,
    pub identifier: Box<Identifier>,
}

///
/// Type derived for non-terminal ScopedOrHierIdentifierGroupList0
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ScopedOrHierIdentifierGroupList0 {
    pub range: Box<Range>,
}

///
/// Type derived for non-terminal ScopedOrHierIdentifierGroupList1
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ScopedOrHierIdentifierGroupList1 {
    pub dot: Box<Dot>,
    pub identifier: Box<Identifier>,
    pub scoped_or_hier_identifier_group_list1_list: Vec<ScopedOrHierIdentifierGroupList1List>,
}

///
/// Type derived for non-terminal ScopedOrHierIdentifierGroupList1List
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct ScopedOrHierIdentifierGroupList1List {
    pub range: Box<Range>,
}

///
/// Type derived for non-terminal Semicolon
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Semicolon {
    pub semicolon_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal SemicolonTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SemicolonTerm {
    pub semicolon_term: crate::veryl_token::Token, /* ; */
}

///
/// Type derived for non-terminal SemicolonToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SemicolonToken {
    pub semicolon_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Start
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Start {
    pub start_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal StartToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StartToken {
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Statement
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Statement {
    AssignmentStatement(StatementAssignmentStatement),
    IfStatement(StatementIfStatement),
    IfResetStatement(StatementIfResetStatement),
    ReturnStatement(StatementReturnStatement),
    ForStatement(StatementForStatement),
    CaseStatement(StatementCaseStatement),
}

///
/// Type derived for non-terminal Step
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Step {
    pub step_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal StepTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StepTerm {
    pub step_term: crate::veryl_token::Token, /* \bstep\b */
}

///
/// Type derived for non-terminal StepToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StepToken {
    pub step_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Struct
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Struct {
    pub struct_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal StructDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StructDeclaration {
    pub r#struct: Box<Struct>,
    pub identifier: Box<Identifier>,
    pub l_brace: Box<LBrace>,
    pub struct_list: Box<StructList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal StructItem
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StructItem {
    pub identifier: Box<Identifier>,
    pub colon: Box<Colon>,
    pub r#type: Box<Type>,
}

///
/// Type derived for non-terminal StructList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StructList {
    pub struct_item: Box<StructItem>,
    pub struct_list_list: Vec<StructListList>,
    pub struct_list_opt: Option<Box<StructListOpt>>,
}

///
/// Type derived for non-terminal StructListList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StructListList {
    pub comma: Box<Comma>,
    pub struct_item: Box<StructItem>,
}

///
/// Type derived for non-terminal StructListOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StructListOpt {
    pub comma: Box<Comma>,
}

///
/// Type derived for non-terminal StructTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StructTerm {
    pub struct_term: crate::veryl_token::Token, /* \bstruct\b */
}

///
/// Type derived for non-terminal StructToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct StructToken {
    pub struct_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal SyncHigh
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SyncHigh {
    pub sync_high_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal SyncHighTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SyncHighTerm {
    pub sync_high_term: crate::veryl_token::Token, /* \bsync_high\b */
}

///
/// Type derived for non-terminal SyncHighToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SyncHighToken {
    pub sync_high_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal SyncLow
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SyncLow {
    pub sync_low_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal SyncLowTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SyncLowTerm {
    pub sync_low_term: crate::veryl_token::Token, /* \bsync_low\b */
}

///
/// Type derived for non-terminal SyncLowToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct SyncLowToken {
    pub sync_low_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Type
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Type {
    pub type_group: Box<TypeGroup>,
    pub type_list: Vec<TypeList>,
}

///
/// Type derived for non-terminal TypeGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum TypeGroup {
    BuiltinType(TypeGroupBuiltinType),
    ScopedIdentifier(TypeGroupScopedIdentifier),
}

///
/// Type derived for non-terminal TypeList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct TypeList {
    pub width: Box<Width>,
}

///
/// Type derived for non-terminal U32
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct U32 {
    pub u32_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal U32Term
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct U32Term {
    pub u32_term: crate::veryl_token::Token, /* \bu32\b */
}

///
/// Type derived for non-terminal U32Token
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct U32Token {
    pub u32_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal U64
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct U64 {
    pub u64_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal U64Term
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct U64Term {
    pub u64_term: crate::veryl_token::Token, /* \bu64\b */
}

///
/// Type derived for non-terminal U64Token
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct U64Token {
    pub u64_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal UnaryOperator
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct UnaryOperator {
    pub unary_operator_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal UnaryOperatorTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct UnaryOperatorTerm {
    pub unary_operator_term: crate::veryl_token::Token, /* ~&|~\||!|~ */
}

///
/// Type derived for non-terminal UnaryOperatorToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct UnaryOperatorToken {
    pub unary_operator_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Var
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Var {
    pub var_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal VarDeclaration
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct VarDeclaration {
    pub var: Box<Var>,
    pub identifier: Box<Identifier>,
    pub colon: Box<Colon>,
    pub r#type: Box<Type>,
    pub var_declaration_opt: Option<Box<VarDeclarationOpt>>,
    pub semicolon: Box<Semicolon>,
}

///
/// Type derived for non-terminal VarDeclarationOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct VarDeclarationOpt {
    pub equ: Box<Equ>,
    pub expression: Box<Expression>,
}

///
/// Type derived for non-terminal VarTerm
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct VarTerm {
    pub var_term: crate::veryl_token::Token, /* \bvar\b */
}

///
/// Type derived for non-terminal VarToken
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct VarToken {
    pub var_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Veryl
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Veryl {
    pub start: Box<Start>,
    pub veryl_list: Vec<VerylList>,
}

///
/// Type derived for non-terminal VerylList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct VerylList {
    pub description: Box<Description>,
}

///
/// Type derived for non-terminal Width
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct Width {
    pub l_bracket: Box<LBracket>,
    pub expression: Box<Expression>,
    pub r_bracket: Box<RBracket>,
}

///
/// Type derived for non-terminal WithParameter
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct WithParameter {
    pub hash: Box<Hash>,
    pub l_paren: Box<LParen>,
    pub with_parameter_opt: Option<Box<WithParameterOpt>>,
    pub r_paren: Box<RParen>,
}

///
/// Type derived for non-terminal WithParameterItem
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct WithParameterItem {
    pub with_parameter_item_group: Box<WithParameterItemGroup>,
    pub identifier: Box<Identifier>,
    pub colon: Box<Colon>,
    pub r#type: Box<Type>,
    pub equ: Box<Equ>,
    pub expression: Box<Expression>,
}

///
/// Type derived for non-terminal WithParameterItemGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum WithParameterItemGroup {
    Parameter(WithParameterItemGroupParameter),
    Localparam(WithParameterItemGroupLocalparam),
}

///
/// Type derived for non-terminal WithParameterList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct WithParameterList {
    pub with_parameter_item: Box<WithParameterItem>,
    pub with_parameter_list_list: Vec<WithParameterListList>,
    pub with_parameter_list_opt: Option<Box<WithParameterListOpt>>,
}

///
/// Type derived for non-terminal WithParameterListList
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct WithParameterListList {
    pub comma: Box<Comma>,
    pub with_parameter_item: Box<WithParameterItem>,
}

///
/// Type derived for non-terminal WithParameterListOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct WithParameterListOpt {
    pub comma: Box<Comma>,
}

///
/// Type derived for non-terminal WithParameterOpt
///
#[allow(dead_code)]
#[derive(Builder, Debug, Clone)]
#[builder(crate = "parol_runtime::derive_builder")]
pub struct WithParameterOpt {
    pub with_parameter_list: Box<WithParameterList>,
}

// -------------------------------------------------------------------------------------------------

///
/// Deduced ASTType of expanded grammar
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ASTType {
    AllBit(AllBit),
    AllBitTerm(AllBitTerm),
    AllBitToken(AllBitToken),
    AlwaysComb(AlwaysComb),
    AlwaysCombDeclaration(AlwaysCombDeclaration),
    AlwaysCombDeclarationList(Vec<AlwaysCombDeclarationList>),
    AlwaysCombTerm(AlwaysCombTerm),
    AlwaysCombToken(AlwaysCombToken),
    AlwaysFf(AlwaysFf),
    AlwaysFfClock(AlwaysFfClock),
    AlwaysFfClockOpt(Option<Box<AlwaysFfClockOpt>>),
    AlwaysFfClockOptGroup(AlwaysFfClockOptGroup),
    AlwaysFfDeclaration(AlwaysFfDeclaration),
    AlwaysFfDeclarationList(Vec<AlwaysFfDeclarationList>),
    AlwaysFfDeclarationOpt(Option<Box<AlwaysFfDeclarationOpt>>),
    AlwaysFfReset(AlwaysFfReset),
    AlwaysFfResetOpt(Option<Box<AlwaysFfResetOpt>>),
    AlwaysFfResetOptGroup(AlwaysFfResetOptGroup),
    AlwaysFfTerm(AlwaysFfTerm),
    AlwaysFfToken(AlwaysFfToken),
    Assign(Assign),
    AssignDeclaration(AssignDeclaration),
    AssignTerm(AssignTerm),
    AssignToken(AssignToken),
    AssignmentOperator(AssignmentOperator),
    AssignmentOperatorTerm(AssignmentOperatorTerm),
    AssignmentOperatorToken(AssignmentOperatorToken),
    AssignmentStatement(AssignmentStatement),
    AssignmentStatementGroup(AssignmentStatementGroup),
    AsyncHigh(AsyncHigh),
    AsyncHighTerm(AsyncHighTerm),
    AsyncHighToken(AsyncHighToken),
    AsyncLow(AsyncLow),
    AsyncLowTerm(AsyncLowTerm),
    AsyncLowToken(AsyncLowToken),
    BaseLess(BaseLess),
    BaseLessTerm(BaseLessTerm),
    BaseLessToken(BaseLessToken),
    Based(Based),
    BasedTerm(BasedTerm),
    BasedToken(BasedToken),
    Bit(Bit),
    BitTerm(BitTerm),
    BitToken(BitToken),
    BuiltinType(BuiltinType),
    Case(Case),
    CaseItem(CaseItem),
    CaseItemGroup(CaseItemGroup),
    CaseItemGroup0(CaseItemGroup0),
    CaseItemGroup0List(Vec<CaseItemGroup0List>),
    CaseStatement(CaseStatement),
    CaseStatementList(Vec<CaseStatementList>),
    CaseTerm(CaseTerm),
    CaseToken(CaseToken),
    Colon(Colon),
    ColonColon(ColonColon),
    ColonColonTerm(ColonColonTerm),
    ColonColonToken(ColonColonToken),
    ColonTerm(ColonTerm),
    ColonToken(ColonToken),
    Comma(Comma),
    CommaTerm(CommaTerm),
    CommaToken(CommaToken),
    Comments(Comments),
    CommentsOpt(Option<Box<CommentsOpt>>),
    CommentsTerm(CommentsTerm),
    Defaul(Defaul),
    DefaultTerm(DefaultTerm),
    DefaultToken(DefaultToken),
    Description(Description),
    Direction(Direction),
    Dollar(Dollar),
    DollarTerm(DollarTerm),
    DollarToken(DollarToken),
    Dot(Dot),
    DotDot(DotDot),
    DotDotTerm(DotDotTerm),
    DotDotToken(DotDotToken),
    DotTerm(DotTerm),
    DotToken(DotToken),
    Else(Else),
    ElseTerm(ElseTerm),
    ElseToken(ElseToken),
    Enum(Enum),
    EnumDeclaration(EnumDeclaration),
    EnumItem(EnumItem),
    EnumItemOpt(Option<Box<EnumItemOpt>>),
    EnumList(EnumList),
    EnumListList(Vec<EnumListList>),
    EnumListOpt(Option<Box<EnumListOpt>>),
    EnumTerm(EnumTerm),
    EnumToken(EnumToken),
    Equ(Equ),
    EquTerm(EquTerm),
    EquToken(EquToken),
    Exponent(Exponent),
    ExponentTerm(ExponentTerm),
    ExponentToken(ExponentToken),
    Expression(Expression),
    Expression01(Expression01),
    Expression01List(Vec<Expression01List>),
    Expression02(Expression02),
    Expression02List(Vec<Expression02List>),
    Expression03(Expression03),
    Expression03List(Vec<Expression03List>),
    Expression04(Expression04),
    Expression04List(Vec<Expression04List>),
    Expression05(Expression05),
    Expression05List(Vec<Expression05List>),
    Expression06(Expression06),
    Expression06List(Vec<Expression06List>),
    Expression07(Expression07),
    Expression07List(Vec<Expression07List>),
    Expression08(Expression08),
    Expression08List(Vec<Expression08List>),
    Expression09(Expression09),
    Expression09List(Vec<Expression09List>),
    Expression10(Expression10),
    Expression10List(Vec<Expression10List>),
    Expression11(Expression11),
    Expression11List(Vec<Expression11List>),
    Expression11ListGroup(Expression11ListGroup),
    ExpressionList(Vec<ExpressionList>),
    F32(F32),
    F32Term(F32Term),
    F32Token(F32Token),
    F64(F64),
    F64Term(F64Term),
    F64Token(F64Token),
    Factor(Factor),
    FactorOpt(Option<Box<FactorOpt>>),
    FactorOpt0(Option<Box<FactorOpt0>>),
    FactorOpt1(Option<Box<FactorOpt1>>),
    FixedPoint(FixedPoint),
    FixedPointTerm(FixedPointTerm),
    FixedPointToken(FixedPointToken),
    For(For),
    ForStatement(ForStatement),
    ForStatementList(Vec<ForStatementList>),
    ForStatementOpt(Option<Box<ForStatementOpt>>),
    ForTerm(ForTerm),
    ForToken(ForToken),
    Function(Function),
    FunctionCallArg(FunctionCallArg),
    FunctionCallArgList(Vec<FunctionCallArgList>),
    FunctionCallArgOpt(Option<Box<FunctionCallArgOpt>>),
    FunctionDeclaration(FunctionDeclaration),
    FunctionDeclarationList(Vec<FunctionDeclarationList>),
    FunctionDeclarationOpt(Option<Box<FunctionDeclarationOpt>>),
    FunctionDeclarationOpt0(Option<Box<FunctionDeclarationOpt0>>),
    FunctionItem(FunctionItem),
    FunctionTerm(FunctionTerm),
    FunctionToken(FunctionToken),
    Hash(Hash),
    HashTerm(HashTerm),
    HashToken(HashToken),
    HierarchicalIdentifier(HierarchicalIdentifier),
    HierarchicalIdentifierList(Vec<HierarchicalIdentifierList>),
    HierarchicalIdentifierList0(Vec<HierarchicalIdentifierList0>),
    HierarchicalIdentifierList0List(Vec<HierarchicalIdentifierList0List>),
    I32(I32),
    I32Term(I32Term),
    I32Token(I32Token),
    I64(I64),
    I64Term(I64Term),
    I64Token(I64Token),
    Identifier(Identifier),
    IdentifierTerm(IdentifierTerm),
    IdentifierToken(IdentifierToken),
    If(If),
    IfReset(IfReset),
    IfResetStatement(IfResetStatement),
    IfResetStatementList(Vec<IfResetStatementList>),
    IfResetStatementList0(Vec<IfResetStatementList0>),
    IfResetStatementList0List(Vec<IfResetStatementList0List>),
    IfResetStatementOpt(Option<Box<IfResetStatementOpt>>),
    IfResetStatementOptList(Vec<IfResetStatementOptList>),
    IfResetTerm(IfResetTerm),
    IfResetToken(IfResetToken),
    IfStatement(IfStatement),
    IfStatementList(Vec<IfStatementList>),
    IfStatementList0(Vec<IfStatementList0>),
    IfStatementList0List(Vec<IfStatementList0List>),
    IfStatementOpt(Option<Box<IfStatementOpt>>),
    IfStatementOptList(Vec<IfStatementOptList>),
    IfTerm(IfTerm),
    IfToken(IfToken),
    In(In),
    InTerm(InTerm),
    InToken(InToken),
    Inout(Inout),
    InoutTerm(InoutTerm),
    InoutToken(InoutToken),
    Input(Input),
    InputTerm(InputTerm),
    InputToken(InputToken),
    Inst(Inst),
    InstDeclaration(InstDeclaration),
    InstDeclarationOpt(Option<Box<InstDeclarationOpt>>),
    InstDeclarationOpt0(Option<Box<InstDeclarationOpt0>>),
    InstDeclarationOpt1(Option<Box<InstDeclarationOpt1>>),
    InstDeclarationOpt2(Option<Box<InstDeclarationOpt2>>),
    InstParameter(InstParameter),
    InstParameterItem(InstParameterItem),
    InstParameterItemOpt(Option<Box<InstParameterItemOpt>>),
    InstParameterList(InstParameterList),
    InstParameterListList(Vec<InstParameterListList>),
    InstParameterListOpt(Option<Box<InstParameterListOpt>>),
    InstParameterOpt(Option<Box<InstParameterOpt>>),
    InstPortItem(InstPortItem),
    InstPortItemOpt(Option<Box<InstPortItemOpt>>),
    InstPortList(InstPortList),
    InstPortListList(Vec<InstPortListList>),
    InstPortListOpt(Option<Box<InstPortListOpt>>),
    InstTerm(InstTerm),
    InstToken(InstToken),
    IntegralNumber(IntegralNumber),
    Interface(Interface),
    InterfaceDeclaration(InterfaceDeclaration),
    InterfaceDeclarationList(Vec<InterfaceDeclarationList>),
    InterfaceDeclarationOpt(Option<Box<InterfaceDeclarationOpt>>),
    InterfaceForDeclaration(InterfaceForDeclaration),
    InterfaceForDeclarationOpt(Option<Box<InterfaceForDeclarationOpt>>),
    InterfaceIfDeclaration(InterfaceIfDeclaration),
    InterfaceIfDeclarationList(Vec<InterfaceIfDeclarationList>),
    InterfaceIfDeclarationOpt(Option<Box<InterfaceIfDeclarationOpt>>),
    InterfaceItem(InterfaceItem),
    InterfaceNamedBlock(InterfaceNamedBlock),
    InterfaceNamedBlockList(Vec<InterfaceNamedBlockList>),
    InterfaceOptionalNamedBlock(InterfaceOptionalNamedBlock),
    InterfaceOptionalNamedBlockList(Vec<InterfaceOptionalNamedBlockList>),
    InterfaceOptionalNamedBlockOpt(Option<Box<InterfaceOptionalNamedBlockOpt>>),
    InterfaceTerm(InterfaceTerm),
    InterfaceToken(InterfaceToken),
    LBrace(LBrace),
    LBraceTerm(LBraceTerm),
    LBraceToken(LBraceToken),
    LBracket(LBracket),
    LBracketTerm(LBracketTerm),
    LBracketToken(LBracketToken),
    LParen(LParen),
    LParenTerm(LParenTerm),
    LParenToken(LParenToken),
    Localparam(Localparam),
    LocalparamDeclaration(LocalparamDeclaration),
    LocalparamTerm(LocalparamTerm),
    LocalparamToken(LocalparamToken),
    Logic(Logic),
    LogicTerm(LogicTerm),
    LogicToken(LogicToken),
    MinusColon(MinusColon),
    MinusColonTerm(MinusColonTerm),
    MinusColonToken(MinusColonToken),
    MinusGT(MinusGT),
    MinusGTTerm(MinusGTTerm),
    MinusGTToken(MinusGTToken),
    Modport(Modport),
    ModportDeclaration(ModportDeclaration),
    ModportItem(ModportItem),
    ModportList(ModportList),
    ModportListList(Vec<ModportListList>),
    ModportListOpt(Option<Box<ModportListOpt>>),
    ModportTerm(ModportTerm),
    ModportToken(ModportToken),
    Module(Module),
    ModuleDeclaration(ModuleDeclaration),
    ModuleDeclarationList(Vec<ModuleDeclarationList>),
    ModuleDeclarationOpt(Option<Box<ModuleDeclarationOpt>>),
    ModuleDeclarationOpt0(Option<Box<ModuleDeclarationOpt0>>),
    ModuleForDeclaration(ModuleForDeclaration),
    ModuleForDeclarationOpt(Option<Box<ModuleForDeclarationOpt>>),
    ModuleIfDeclaration(ModuleIfDeclaration),
    ModuleIfDeclarationList(Vec<ModuleIfDeclarationList>),
    ModuleIfDeclarationOpt(Option<Box<ModuleIfDeclarationOpt>>),
    ModuleItem(ModuleItem),
    ModuleNamedBlock(ModuleNamedBlock),
    ModuleNamedBlockList(Vec<ModuleNamedBlockList>),
    ModuleOptionalNamedBlock(ModuleOptionalNamedBlock),
    ModuleOptionalNamedBlockList(Vec<ModuleOptionalNamedBlockList>),
    ModuleOptionalNamedBlockOpt(Option<Box<ModuleOptionalNamedBlockOpt>>),
    ModuleTerm(ModuleTerm),
    ModuleToken(ModuleToken),
    Negedge(Negedge),
    NegedgeTerm(NegedgeTerm),
    NegedgeToken(NegedgeToken),
    Number(Number),
    Operator01(Operator01),
    Operator01Term(Operator01Term),
    Operator01Token(Operator01Token),
    Operator02(Operator02),
    Operator02Term(Operator02Term),
    Operator02Token(Operator02Token),
    Operator03(Operator03),
    Operator03Term(Operator03Term),
    Operator03Token(Operator03Token),
    Operator04(Operator04),
    Operator04Term(Operator04Term),
    Operator04Token(Operator04Token),
    Operator05(Operator05),
    Operator05Term(Operator05Term),
    Operator05Token(Operator05Token),
    Operator06(Operator06),
    Operator06Term(Operator06Term),
    Operator06Token(Operator06Token),
    Operator07(Operator07),
    Operator07Term(Operator07Term),
    Operator07Token(Operator07Token),
    Operator08(Operator08),
    Operator08Term(Operator08Term),
    Operator08Token(Operator08Token),
    Operator09(Operator09),
    Operator09Term(Operator09Term),
    Operator09Token(Operator09Token),
    Operator10(Operator10),
    Operator10Term(Operator10Term),
    Operator10Token(Operator10Token),
    Operator11(Operator11),
    Operator11Term(Operator11Term),
    Operator11Token(Operator11Token),
    Output(Output),
    OutputTerm(OutputTerm),
    OutputToken(OutputToken),
    Package(Package),
    PackageDeclaration(PackageDeclaration),
    PackageDeclarationList(Vec<PackageDeclarationList>),
    PackageItem(PackageItem),
    PackageTerm(PackageTerm),
    PackageToken(PackageToken),
    Parameter(Parameter),
    ParameterTerm(ParameterTerm),
    ParameterToken(ParameterToken),
    PlusColon(PlusColon),
    PlusColonTerm(PlusColonTerm),
    PlusColonToken(PlusColonToken),
    PortDeclaration(PortDeclaration),
    PortDeclarationItem(PortDeclarationItem),
    PortDeclarationList(PortDeclarationList),
    PortDeclarationListList(Vec<PortDeclarationListList>),
    PortDeclarationListOpt(Option<Box<PortDeclarationListOpt>>),
    PortDeclarationOpt(Option<Box<PortDeclarationOpt>>),
    Posedge(Posedge),
    PosedgeTerm(PosedgeTerm),
    PosedgeToken(PosedgeToken),
    RBrace(RBrace),
    RBraceTerm(RBraceTerm),
    RBraceToken(RBraceToken),
    RBracket(RBracket),
    RBracketTerm(RBracketTerm),
    RBracketToken(RBracketToken),
    RParen(RParen),
    RParenTerm(RParenTerm),
    RParenToken(RParenToken),
    Range(Range),
    RangeOperator(RangeOperator),
    RangeOpt(Option<Box<RangeOpt>>),
    RealNumber(RealNumber),
    Ref(Ref),
    RefTerm(RefTerm),
    RefToken(RefToken),
    Return(Return),
    ReturnStatement(ReturnStatement),
    ReturnTerm(ReturnTerm),
    ReturnToken(ReturnToken),
    ScopedIdentifier(ScopedIdentifier),
    ScopedIdentifierList(Vec<ScopedIdentifierList>),
    ScopedOrHierIdentifier(ScopedOrHierIdentifier),
    ScopedOrHierIdentifierGroup(ScopedOrHierIdentifierGroup),
    ScopedOrHierIdentifierGroupList(Vec<ScopedOrHierIdentifierGroupList>),
    ScopedOrHierIdentifierGroupList0(Vec<ScopedOrHierIdentifierGroupList0>),
    ScopedOrHierIdentifierGroupList1(Vec<ScopedOrHierIdentifierGroupList1>),
    ScopedOrHierIdentifierGroupList1List(Vec<ScopedOrHierIdentifierGroupList1List>),
    Semicolon(Semicolon),
    SemicolonTerm(SemicolonTerm),
    SemicolonToken(SemicolonToken),
    Start(Start),
    StartToken(StartToken),
    Statement(Statement),
    Step(Step),
    StepTerm(StepTerm),
    StepToken(StepToken),
    Struct(Struct),
    StructDeclaration(StructDeclaration),
    StructItem(StructItem),
    StructList(StructList),
    StructListList(Vec<StructListList>),
    StructListOpt(Option<Box<StructListOpt>>),
    StructTerm(StructTerm),
    StructToken(StructToken),
    SyncHigh(SyncHigh),
    SyncHighTerm(SyncHighTerm),
    SyncHighToken(SyncHighToken),
    SyncLow(SyncLow),
    SyncLowTerm(SyncLowTerm),
    SyncLowToken(SyncLowToken),
    Type(Type),
    TypeGroup(TypeGroup),
    TypeList(Vec<TypeList>),
    U32(U32),
    U32Term(U32Term),
    U32Token(U32Token),
    U64(U64),
    U64Term(U64Term),
    U64Token(U64Token),
    UnaryOperator(UnaryOperator),
    UnaryOperatorTerm(UnaryOperatorTerm),
    UnaryOperatorToken(UnaryOperatorToken),
    Var(Var),
    VarDeclaration(VarDeclaration),
    VarDeclarationOpt(Option<Box<VarDeclarationOpt>>),
    VarTerm(VarTerm),
    VarToken(VarToken),
    Veryl(Veryl),
    VerylList(Vec<VerylList>),
    Width(Width),
    WithParameter(WithParameter),
    WithParameterItem(WithParameterItem),
    WithParameterItemGroup(WithParameterItemGroup),
    WithParameterList(WithParameterList),
    WithParameterListList(Vec<WithParameterListList>),
    WithParameterListOpt(Option<Box<WithParameterListOpt>>),
    WithParameterOpt(Option<Box<WithParameterOpt>>),
}

/// Auto-implemented adapter grammar
///
/// The lifetime parameter `'t` refers to the lifetime of the scanned text.
/// The lifetime parameter `'u` refers to the lifetime of user grammar object.
///
#[allow(dead_code)]
pub struct VerylGrammarAuto<'t, 'u>
where
    't: 'u,
{
    // Mutable reference of the actual user grammar to be able to call the semantic actions on it
    user_grammar: &'u mut dyn VerylGrammarTrait,
    // Stack to construct the AST on it
    item_stack: Vec<ASTType>,
    // Just to hold the lifetime generated by parol
    phantom: PhantomData<&'t str>,
}

///
/// The `VerylGrammarAuto` impl is automatically generated for the
/// given grammar.
///
impl<'t, 'u> VerylGrammarAuto<'t, 'u> {
    pub fn new(user_grammar: &'u mut dyn VerylGrammarTrait) -> Self {
        Self {
            user_grammar,
            item_stack: Vec::new(),
            phantom: PhantomData::default(),
        }
    }

    #[allow(dead_code)]
    fn push(&mut self, item: ASTType, context: &str) {
        trace!("push    {}: {:?}", context, item);
        self.item_stack.push(item)
    }

    #[allow(dead_code)]
    fn pop(&mut self, context: &str) -> Option<ASTType> {
        if !self.item_stack.is_empty() {
            let item = self.item_stack.pop();
            if let Some(ref item) = item {
                trace!("pop     {}: {:?}", context, item);
            }
            item
        } else {
            None
        }
    }

    #[allow(dead_code)]
    // Use this function for debugging purposes:
    // trace!("{}", self.trace_item_stack(context));
    fn trace_item_stack(&self, context: &str) -> std::string::String {
        format!(
            "Item stack at {}:\n{}",
            context,
            self.item_stack
                .iter()
                .rev()
                .map(|s| format!("  {:?}", s))
                .collect::<Vec<std::string::String>>()
                .join("\n")
        )
    }

    /// Semantic action for production 0:
    ///
    /// CommentsTerm: "(?:(?:(?://.*(?:\r\n|\r|\n|$))|(?:(?ms)/\u{2a}.*?\u{2a}/))\s*)+" : Token;
    ///
    #[parol_runtime::function_name::named]
    fn comments_term(
        &mut self,
        comments_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments_term = comments_term
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let comments_term_built = CommentsTermBuilder::default()
            .comments_term(comments_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.comments_term(&comments_term_built)?;
        self.push(ASTType::CommentsTerm(comments_term_built), context);
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// ExponentTerm: /[0-9]+(?:_[0-9]+)*\.[0-9]+(?:_[0-9]+)*[eE][+-]?[0-9]+(?:_[0-9]+)*/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn exponent_term(
        &mut self,
        exponent_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let exponent_term = exponent_term
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let exponent_term_built = ExponentTermBuilder::default()
            .exponent_term(exponent_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.exponent_term(&exponent_term_built)?;
        self.push(ASTType::ExponentTerm(exponent_term_built), context);
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// FixedPointTerm: /[0-9]+(?:_[0-9]+)*\.[0-9]+(?:_[0-9]+)*/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn fixed_point_term(
        &mut self,
        fixed_point_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let fixed_point_term = fixed_point_term
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let fixed_point_term_built = FixedPointTermBuilder::default()
            .fixed_point_term(fixed_point_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .fixed_point_term(&fixed_point_term_built)?;
        self.push(ASTType::FixedPointTerm(fixed_point_term_built), context);
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// BasedTerm: /[0-9]+(?:_[0-9]+)*'[bodh][0-9a-fA-FxzXZ]+(?:_[0-9a-fA-FxzXZ]+)*/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn based_term(
        &mut self,
        based_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let based_term = based_term.token(parse_tree)?.try_into().into_diagnostic()?;
        let based_term_built = BasedTermBuilder::default()
            .based_term(based_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.based_term(&based_term_built)?;
        self.push(ASTType::BasedTerm(based_term_built), context);
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// BaseLessTerm: /[0-9]+(?:_[0-9]+)*/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn base_less_term(
        &mut self,
        base_less_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let base_less_term = base_less_term
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let base_less_term_built = BaseLessTermBuilder::default()
            .base_less_term(base_less_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.base_less_term(&base_less_term_built)?;
        self.push(ASTType::BaseLessTerm(base_less_term_built), context);
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// AllBitTerm: /'[01]/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn all_bit_term(
        &mut self,
        all_bit_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let all_bit_term = all_bit_term
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let all_bit_term_built = AllBitTermBuilder::default()
            .all_bit_term(all_bit_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.all_bit_term(&all_bit_term_built)?;
        self.push(ASTType::AllBitTerm(all_bit_term_built), context);
        Ok(())
    }

    /// Semantic action for production 6:
    ///
    /// MinusColonTerm: '-:' : Token;
    ///
    #[parol_runtime::function_name::named]
    fn minus_colon_term(
        &mut self,
        minus_colon_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let minus_colon_term = minus_colon_term
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let minus_colon_term_built = MinusColonTermBuilder::default()
            .minus_colon_term(minus_colon_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .minus_colon_term(&minus_colon_term_built)?;
        self.push(ASTType::MinusColonTerm(minus_colon_term_built), context);
        Ok(())
    }

    /// Semantic action for production 7:
    ///
    /// MinusGTTerm: '->' : Token;
    ///
    #[parol_runtime::function_name::named]
    fn minus_g_t_term(
        &mut self,
        minus_g_t_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let minus_g_t_term = minus_g_t_term
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let minus_g_t_term_built = MinusGTTermBuilder::default()
            .minus_g_t_term(minus_g_t_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.minus_g_t_term(&minus_g_t_term_built)?;
        self.push(ASTType::MinusGTTerm(minus_g_t_term_built), context);
        Ok(())
    }

    /// Semantic action for production 8:
    ///
    /// PlusColonTerm: '+:' : Token;
    ///
    #[parol_runtime::function_name::named]
    fn plus_colon_term(
        &mut self,
        plus_colon_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let plus_colon_term = plus_colon_term
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let plus_colon_term_built = PlusColonTermBuilder::default()
            .plus_colon_term(plus_colon_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.plus_colon_term(&plus_colon_term_built)?;
        self.push(ASTType::PlusColonTerm(plus_colon_term_built), context);
        Ok(())
    }

    /// Semantic action for production 9:
    ///
    /// AssignmentOperatorTerm: "\+=|-=|\*=|/=|%=|&=|\|=|\^=|<<=|>>=|<<<=|>>>=" : Token;
    ///
    #[parol_runtime::function_name::named]
    fn assignment_operator_term(
        &mut self,
        assignment_operator_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let assignment_operator_term = assignment_operator_term
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let assignment_operator_term_built = AssignmentOperatorTermBuilder::default()
            .assignment_operator_term(assignment_operator_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .assignment_operator_term(&assignment_operator_term_built)?;
        self.push(
            ASTType::AssignmentOperatorTerm(assignment_operator_term_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 10:
    ///
    /// Operator11Term: "\*\*" : Token;
    ///
    #[parol_runtime::function_name::named]
    fn operator11_term(
        &mut self,
        operator11_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator11_term = operator11_term
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let operator11_term_built = Operator11TermBuilder::default()
            .operator11_term(operator11_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.operator11_term(&operator11_term_built)?;
        self.push(ASTType::Operator11Term(operator11_term_built), context);
        Ok(())
    }

    /// Semantic action for production 11:
    ///
    /// Operator10Term: "\*|/|%" : Token;
    ///
    #[parol_runtime::function_name::named]
    fn operator10_term(
        &mut self,
        operator10_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator10_term = operator10_term
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let operator10_term_built = Operator10TermBuilder::default()
            .operator10_term(operator10_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.operator10_term(&operator10_term_built)?;
        self.push(ASTType::Operator10Term(operator10_term_built), context);
        Ok(())
    }

    /// Semantic action for production 12:
    ///
    /// Operator09Term: "\+|-" : Token;
    ///
    #[parol_runtime::function_name::named]
    fn operator09_term(
        &mut self,
        operator09_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator09_term = operator09_term
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let operator09_term_built = Operator09TermBuilder::default()
            .operator09_term(operator09_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.operator09_term(&operator09_term_built)?;
        self.push(ASTType::Operator09Term(operator09_term_built), context);
        Ok(())
    }

    /// Semantic action for production 13:
    ///
    /// Operator08Term: "<<<|>>>|<<|>>" : Token;
    ///
    #[parol_runtime::function_name::named]
    fn operator08_term(
        &mut self,
        operator08_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator08_term = operator08_term
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let operator08_term_built = Operator08TermBuilder::default()
            .operator08_term(operator08_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.operator08_term(&operator08_term_built)?;
        self.push(ASTType::Operator08Term(operator08_term_built), context);
        Ok(())
    }

    /// Semantic action for production 14:
    ///
    /// Operator07Term: "<=|>=|<|>" : Token;
    ///
    #[parol_runtime::function_name::named]
    fn operator07_term(
        &mut self,
        operator07_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator07_term = operator07_term
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let operator07_term_built = Operator07TermBuilder::default()
            .operator07_term(operator07_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.operator07_term(&operator07_term_built)?;
        self.push(ASTType::Operator07Term(operator07_term_built), context);
        Ok(())
    }

    /// Semantic action for production 15:
    ///
    /// Operator06Term: "===|==\?|!==|!=\?|==|!=" : Token;
    ///
    #[parol_runtime::function_name::named]
    fn operator06_term(
        &mut self,
        operator06_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator06_term = operator06_term
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let operator06_term_built = Operator06TermBuilder::default()
            .operator06_term(operator06_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.operator06_term(&operator06_term_built)?;
        self.push(ASTType::Operator06Term(operator06_term_built), context);
        Ok(())
    }

    /// Semantic action for production 16:
    ///
    /// Operator02Term: "&&" : Token;
    ///
    #[parol_runtime::function_name::named]
    fn operator02_term(
        &mut self,
        operator02_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator02_term = operator02_term
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let operator02_term_built = Operator02TermBuilder::default()
            .operator02_term(operator02_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.operator02_term(&operator02_term_built)?;
        self.push(ASTType::Operator02Term(operator02_term_built), context);
        Ok(())
    }

    /// Semantic action for production 17:
    ///
    /// Operator01Term: "\|\|" : Token;
    ///
    #[parol_runtime::function_name::named]
    fn operator01_term(
        &mut self,
        operator01_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator01_term = operator01_term
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let operator01_term_built = Operator01TermBuilder::default()
            .operator01_term(operator01_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.operator01_term(&operator01_term_built)?;
        self.push(ASTType::Operator01Term(operator01_term_built), context);
        Ok(())
    }

    /// Semantic action for production 18:
    ///
    /// Operator05Term: "&" : Token;
    ///
    #[parol_runtime::function_name::named]
    fn operator05_term(
        &mut self,
        operator05_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator05_term = operator05_term
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let operator05_term_built = Operator05TermBuilder::default()
            .operator05_term(operator05_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.operator05_term(&operator05_term_built)?;
        self.push(ASTType::Operator05Term(operator05_term_built), context);
        Ok(())
    }

    /// Semantic action for production 19:
    ///
    /// Operator04Term: "\^~|\^|~\^" : Token;
    ///
    #[parol_runtime::function_name::named]
    fn operator04_term(
        &mut self,
        operator04_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator04_term = operator04_term
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let operator04_term_built = Operator04TermBuilder::default()
            .operator04_term(operator04_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.operator04_term(&operator04_term_built)?;
        self.push(ASTType::Operator04Term(operator04_term_built), context);
        Ok(())
    }

    /// Semantic action for production 20:
    ///
    /// Operator03Term: "\|" : Token;
    ///
    #[parol_runtime::function_name::named]
    fn operator03_term(
        &mut self,
        operator03_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator03_term = operator03_term
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let operator03_term_built = Operator03TermBuilder::default()
            .operator03_term(operator03_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.operator03_term(&operator03_term_built)?;
        self.push(ASTType::Operator03Term(operator03_term_built), context);
        Ok(())
    }

    /// Semantic action for production 21:
    ///
    /// UnaryOperatorTerm: "~&|~\||!|~" : Token;
    ///
    #[parol_runtime::function_name::named]
    fn unary_operator_term(
        &mut self,
        unary_operator_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let unary_operator_term = unary_operator_term
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let unary_operator_term_built = UnaryOperatorTermBuilder::default()
            .unary_operator_term(unary_operator_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .unary_operator_term(&unary_operator_term_built)?;
        self.push(
            ASTType::UnaryOperatorTerm(unary_operator_term_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 22:
    ///
    /// ColonColonTerm: '::' : Token;
    ///
    #[parol_runtime::function_name::named]
    fn colon_colon_term(
        &mut self,
        colon_colon_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let colon_colon_term = colon_colon_term
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let colon_colon_term_built = ColonColonTermBuilder::default()
            .colon_colon_term(colon_colon_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .colon_colon_term(&colon_colon_term_built)?;
        self.push(ASTType::ColonColonTerm(colon_colon_term_built), context);
        Ok(())
    }

    /// Semantic action for production 23:
    ///
    /// ColonTerm: ':' : Token;
    ///
    #[parol_runtime::function_name::named]
    fn colon_term(
        &mut self,
        colon_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let colon_term = colon_term.token(parse_tree)?.try_into().into_diagnostic()?;
        let colon_term_built = ColonTermBuilder::default()
            .colon_term(colon_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.colon_term(&colon_term_built)?;
        self.push(ASTType::ColonTerm(colon_term_built), context);
        Ok(())
    }

    /// Semantic action for production 24:
    ///
    /// CommaTerm: ',' : Token;
    ///
    #[parol_runtime::function_name::named]
    fn comma_term(
        &mut self,
        comma_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma_term = comma_term.token(parse_tree)?.try_into().into_diagnostic()?;
        let comma_term_built = CommaTermBuilder::default()
            .comma_term(comma_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.comma_term(&comma_term_built)?;
        self.push(ASTType::CommaTerm(comma_term_built), context);
        Ok(())
    }

    /// Semantic action for production 25:
    ///
    /// DollarTerm: '$' : Token;
    ///
    #[parol_runtime::function_name::named]
    fn dollar_term(
        &mut self,
        dollar_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dollar_term = dollar_term
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let dollar_term_built = DollarTermBuilder::default()
            .dollar_term(dollar_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.dollar_term(&dollar_term_built)?;
        self.push(ASTType::DollarTerm(dollar_term_built), context);
        Ok(())
    }

    /// Semantic action for production 26:
    ///
    /// DotDotTerm: '..' : Token;
    ///
    #[parol_runtime::function_name::named]
    fn dot_dot_term(
        &mut self,
        dot_dot_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dot_dot_term = dot_dot_term
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let dot_dot_term_built = DotDotTermBuilder::default()
            .dot_dot_term(dot_dot_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.dot_dot_term(&dot_dot_term_built)?;
        self.push(ASTType::DotDotTerm(dot_dot_term_built), context);
        Ok(())
    }

    /// Semantic action for production 27:
    ///
    /// DotTerm: '.' : Token;
    ///
    #[parol_runtime::function_name::named]
    fn dot_term(
        &mut self,
        dot_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dot_term = dot_term.token(parse_tree)?.try_into().into_diagnostic()?;
        let dot_term_built = DotTermBuilder::default()
            .dot_term(dot_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.dot_term(&dot_term_built)?;
        self.push(ASTType::DotTerm(dot_term_built), context);
        Ok(())
    }

    /// Semantic action for production 28:
    ///
    /// EquTerm: '=' : Token;
    ///
    #[parol_runtime::function_name::named]
    fn equ_term(
        &mut self,
        equ_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let equ_term = equ_term.token(parse_tree)?.try_into().into_diagnostic()?;
        let equ_term_built = EquTermBuilder::default()
            .equ_term(equ_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.equ_term(&equ_term_built)?;
        self.push(ASTType::EquTerm(equ_term_built), context);
        Ok(())
    }

    /// Semantic action for production 29:
    ///
    /// HashTerm: '#' : Token;
    ///
    #[parol_runtime::function_name::named]
    fn hash_term(
        &mut self,
        hash_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let hash_term = hash_term.token(parse_tree)?.try_into().into_diagnostic()?;
        let hash_term_built = HashTermBuilder::default()
            .hash_term(hash_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.hash_term(&hash_term_built)?;
        self.push(ASTType::HashTerm(hash_term_built), context);
        Ok(())
    }

    /// Semantic action for production 30:
    ///
    /// LBraceTerm: '{' : Token;
    ///
    #[parol_runtime::function_name::named]
    fn l_brace_term(
        &mut self,
        l_brace_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_brace_term = l_brace_term
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let l_brace_term_built = LBraceTermBuilder::default()
            .l_brace_term(l_brace_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.l_brace_term(&l_brace_term_built)?;
        self.push(ASTType::LBraceTerm(l_brace_term_built), context);
        Ok(())
    }

    /// Semantic action for production 31:
    ///
    /// LBracketTerm: '[' : Token;
    ///
    #[parol_runtime::function_name::named]
    fn l_bracket_term(
        &mut self,
        l_bracket_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_bracket_term = l_bracket_term
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let l_bracket_term_built = LBracketTermBuilder::default()
            .l_bracket_term(l_bracket_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.l_bracket_term(&l_bracket_term_built)?;
        self.push(ASTType::LBracketTerm(l_bracket_term_built), context);
        Ok(())
    }

    /// Semantic action for production 32:
    ///
    /// LParenTerm: '(' : Token;
    ///
    #[parol_runtime::function_name::named]
    fn l_paren_term(
        &mut self,
        l_paren_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_paren_term = l_paren_term
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let l_paren_term_built = LParenTermBuilder::default()
            .l_paren_term(l_paren_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.l_paren_term(&l_paren_term_built)?;
        self.push(ASTType::LParenTerm(l_paren_term_built), context);
        Ok(())
    }

    /// Semantic action for production 33:
    ///
    /// RBraceTerm: '}' : Token;
    ///
    #[parol_runtime::function_name::named]
    fn r_brace_term(
        &mut self,
        r_brace_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace_term = r_brace_term
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let r_brace_term_built = RBraceTermBuilder::default()
            .r_brace_term(r_brace_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.r_brace_term(&r_brace_term_built)?;
        self.push(ASTType::RBraceTerm(r_brace_term_built), context);
        Ok(())
    }

    /// Semantic action for production 34:
    ///
    /// RBracketTerm: ']' : Token;
    ///
    #[parol_runtime::function_name::named]
    fn r_bracket_term(
        &mut self,
        r_bracket_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_bracket_term = r_bracket_term
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let r_bracket_term_built = RBracketTermBuilder::default()
            .r_bracket_term(r_bracket_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.r_bracket_term(&r_bracket_term_built)?;
        self.push(ASTType::RBracketTerm(r_bracket_term_built), context);
        Ok(())
    }

    /// Semantic action for production 35:
    ///
    /// RParenTerm: ')' : Token;
    ///
    #[parol_runtime::function_name::named]
    fn r_paren_term(
        &mut self,
        r_paren_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren_term = r_paren_term
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let r_paren_term_built = RParenTermBuilder::default()
            .r_paren_term(r_paren_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.r_paren_term(&r_paren_term_built)?;
        self.push(ASTType::RParenTerm(r_paren_term_built), context);
        Ok(())
    }

    /// Semantic action for production 36:
    ///
    /// SemicolonTerm: ';' : Token;
    ///
    #[parol_runtime::function_name::named]
    fn semicolon_term(
        &mut self,
        semicolon_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon_term = semicolon_term
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let semicolon_term_built = SemicolonTermBuilder::default()
            .semicolon_term(semicolon_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.semicolon_term(&semicolon_term_built)?;
        self.push(ASTType::SemicolonTerm(semicolon_term_built), context);
        Ok(())
    }

    /// Semantic action for production 37:
    ///
    /// AlwaysCombTerm: /\balways_comb\b/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn always_comb_term(
        &mut self,
        always_comb_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let always_comb_term = always_comb_term
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let always_comb_term_built = AlwaysCombTermBuilder::default()
            .always_comb_term(always_comb_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .always_comb_term(&always_comb_term_built)?;
        self.push(ASTType::AlwaysCombTerm(always_comb_term_built), context);
        Ok(())
    }

    /// Semantic action for production 38:
    ///
    /// AlwaysFfTerm: /\balways_ff\b/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_term(
        &mut self,
        always_ff_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let always_ff_term = always_ff_term
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let always_ff_term_built = AlwaysFfTermBuilder::default()
            .always_ff_term(always_ff_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.always_ff_term(&always_ff_term_built)?;
        self.push(ASTType::AlwaysFfTerm(always_ff_term_built), context);
        Ok(())
    }

    /// Semantic action for production 39:
    ///
    /// AssignTerm: /\bassign\b/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn assign_term(
        &mut self,
        assign_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let assign_term = assign_term
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let assign_term_built = AssignTermBuilder::default()
            .assign_term(assign_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.assign_term(&assign_term_built)?;
        self.push(ASTType::AssignTerm(assign_term_built), context);
        Ok(())
    }

    /// Semantic action for production 40:
    ///
    /// AsyncHighTerm: /\basync_high\b/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn async_high_term(
        &mut self,
        async_high_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let async_high_term = async_high_term
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let async_high_term_built = AsyncHighTermBuilder::default()
            .async_high_term(async_high_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.async_high_term(&async_high_term_built)?;
        self.push(ASTType::AsyncHighTerm(async_high_term_built), context);
        Ok(())
    }

    /// Semantic action for production 41:
    ///
    /// AsyncLowTerm: /\basync_low\b/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn async_low_term(
        &mut self,
        async_low_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let async_low_term = async_low_term
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let async_low_term_built = AsyncLowTermBuilder::default()
            .async_low_term(async_low_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.async_low_term(&async_low_term_built)?;
        self.push(ASTType::AsyncLowTerm(async_low_term_built), context);
        Ok(())
    }

    /// Semantic action for production 42:
    ///
    /// BitTerm: /\bbit\b/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn bit_term(
        &mut self,
        bit_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bit_term = bit_term.token(parse_tree)?.try_into().into_diagnostic()?;
        let bit_term_built = BitTermBuilder::default()
            .bit_term(bit_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.bit_term(&bit_term_built)?;
        self.push(ASTType::BitTerm(bit_term_built), context);
        Ok(())
    }

    /// Semantic action for production 43:
    ///
    /// CaseTerm: /\bcase\b/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn case_term(
        &mut self,
        case_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let case_term = case_term.token(parse_tree)?.try_into().into_diagnostic()?;
        let case_term_built = CaseTermBuilder::default()
            .case_term(case_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.case_term(&case_term_built)?;
        self.push(ASTType::CaseTerm(case_term_built), context);
        Ok(())
    }

    /// Semantic action for production 44:
    ///
    /// DefaultTerm: /\bdefault\b/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn default_term(
        &mut self,
        default_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let default_term = default_term
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let default_term_built = DefaultTermBuilder::default()
            .default_term(default_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.default_term(&default_term_built)?;
        self.push(ASTType::DefaultTerm(default_term_built), context);
        Ok(())
    }

    /// Semantic action for production 45:
    ///
    /// ElseTerm: /\belse\b/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn else_term(
        &mut self,
        else_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let else_term = else_term.token(parse_tree)?.try_into().into_diagnostic()?;
        let else_term_built = ElseTermBuilder::default()
            .else_term(else_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.else_term(&else_term_built)?;
        self.push(ASTType::ElseTerm(else_term_built), context);
        Ok(())
    }

    /// Semantic action for production 46:
    ///
    /// EnumTerm: /\benum\b/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn enum_term(
        &mut self,
        enum_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let enum_term = enum_term.token(parse_tree)?.try_into().into_diagnostic()?;
        let enum_term_built = EnumTermBuilder::default()
            .enum_term(enum_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.enum_term(&enum_term_built)?;
        self.push(ASTType::EnumTerm(enum_term_built), context);
        Ok(())
    }

    /// Semantic action for production 47:
    ///
    /// F32Term: /\bf32\b/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn f32_term(
        &mut self,
        f32_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let f32_term = f32_term.token(parse_tree)?.try_into().into_diagnostic()?;
        let f32_term_built = F32TermBuilder::default()
            .f32_term(f32_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.f32_term(&f32_term_built)?;
        self.push(ASTType::F32Term(f32_term_built), context);
        Ok(())
    }

    /// Semantic action for production 48:
    ///
    /// F64Term: /\bf64\b/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn f64_term(
        &mut self,
        f64_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let f64_term = f64_term.token(parse_tree)?.try_into().into_diagnostic()?;
        let f64_term_built = F64TermBuilder::default()
            .f64_term(f64_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.f64_term(&f64_term_built)?;
        self.push(ASTType::F64Term(f64_term_built), context);
        Ok(())
    }

    /// Semantic action for production 49:
    ///
    /// ForTerm: /\bfor\b/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn for_term(
        &mut self,
        for_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let for_term = for_term.token(parse_tree)?.try_into().into_diagnostic()?;
        let for_term_built = ForTermBuilder::default()
            .for_term(for_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.for_term(&for_term_built)?;
        self.push(ASTType::ForTerm(for_term_built), context);
        Ok(())
    }

    /// Semantic action for production 50:
    ///
    /// FunctionTerm: /\bfunction\b/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn function_term(
        &mut self,
        function_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let function_term = function_term
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let function_term_built = FunctionTermBuilder::default()
            .function_term(function_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.function_term(&function_term_built)?;
        self.push(ASTType::FunctionTerm(function_term_built), context);
        Ok(())
    }

    /// Semantic action for production 51:
    ///
    /// I32Term: /\bi32\b/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn i32_term(
        &mut self,
        i32_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let i32_term = i32_term.token(parse_tree)?.try_into().into_diagnostic()?;
        let i32_term_built = I32TermBuilder::default()
            .i32_term(i32_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.i32_term(&i32_term_built)?;
        self.push(ASTType::I32Term(i32_term_built), context);
        Ok(())
    }

    /// Semantic action for production 52:
    ///
    /// I64Term: /\bi64\b/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn i64_term(
        &mut self,
        i64_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let i64_term = i64_term.token(parse_tree)?.try_into().into_diagnostic()?;
        let i64_term_built = I64TermBuilder::default()
            .i64_term(i64_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.i64_term(&i64_term_built)?;
        self.push(ASTType::I64Term(i64_term_built), context);
        Ok(())
    }

    /// Semantic action for production 53:
    ///
    /// IfResetTerm: /\bif_reset\b/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn if_reset_term(
        &mut self,
        if_reset_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_reset_term = if_reset_term
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let if_reset_term_built = IfResetTermBuilder::default()
            .if_reset_term(if_reset_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.if_reset_term(&if_reset_term_built)?;
        self.push(ASTType::IfResetTerm(if_reset_term_built), context);
        Ok(())
    }

    /// Semantic action for production 54:
    ///
    /// IfTerm: /\bif\b/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn if_term(
        &mut self,
        if_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_term = if_term.token(parse_tree)?.try_into().into_diagnostic()?;
        let if_term_built = IfTermBuilder::default()
            .if_term(if_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.if_term(&if_term_built)?;
        self.push(ASTType::IfTerm(if_term_built), context);
        Ok(())
    }

    /// Semantic action for production 55:
    ///
    /// InoutTerm: /\binout\b/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn inout_term(
        &mut self,
        inout_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inout_term = inout_term.token(parse_tree)?.try_into().into_diagnostic()?;
        let inout_term_built = InoutTermBuilder::default()
            .inout_term(inout_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.inout_term(&inout_term_built)?;
        self.push(ASTType::InoutTerm(inout_term_built), context);
        Ok(())
    }

    /// Semantic action for production 56:
    ///
    /// InputTerm: /\binput\b/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn input_term(
        &mut self,
        input_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let input_term = input_term.token(parse_tree)?.try_into().into_diagnostic()?;
        let input_term_built = InputTermBuilder::default()
            .input_term(input_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.input_term(&input_term_built)?;
        self.push(ASTType::InputTerm(input_term_built), context);
        Ok(())
    }

    /// Semantic action for production 57:
    ///
    /// InstTerm: /\binst\b/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn inst_term(
        &mut self,
        inst_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inst_term = inst_term.token(parse_tree)?.try_into().into_diagnostic()?;
        let inst_term_built = InstTermBuilder::default()
            .inst_term(inst_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.inst_term(&inst_term_built)?;
        self.push(ASTType::InstTerm(inst_term_built), context);
        Ok(())
    }

    /// Semantic action for production 58:
    ///
    /// InterfaceTerm: /\binterface\b/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn interface_term(
        &mut self,
        interface_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let interface_term = interface_term
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let interface_term_built = InterfaceTermBuilder::default()
            .interface_term(interface_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.interface_term(&interface_term_built)?;
        self.push(ASTType::InterfaceTerm(interface_term_built), context);
        Ok(())
    }

    /// Semantic action for production 59:
    ///
    /// InTerm: /\bin\b/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn in_term(
        &mut self,
        in_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let in_term = in_term.token(parse_tree)?.try_into().into_diagnostic()?;
        let in_term_built = InTermBuilder::default()
            .in_term(in_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.in_term(&in_term_built)?;
        self.push(ASTType::InTerm(in_term_built), context);
        Ok(())
    }

    /// Semantic action for production 60:
    ///
    /// LocalparamTerm: /\blocalparam\b/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn localparam_term(
        &mut self,
        localparam_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let localparam_term = localparam_term
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let localparam_term_built = LocalparamTermBuilder::default()
            .localparam_term(localparam_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.localparam_term(&localparam_term_built)?;
        self.push(ASTType::LocalparamTerm(localparam_term_built), context);
        Ok(())
    }

    /// Semantic action for production 61:
    ///
    /// LogicTerm: /\blogic\b/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn logic_term(
        &mut self,
        logic_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logic_term = logic_term.token(parse_tree)?.try_into().into_diagnostic()?;
        let logic_term_built = LogicTermBuilder::default()
            .logic_term(logic_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.logic_term(&logic_term_built)?;
        self.push(ASTType::LogicTerm(logic_term_built), context);
        Ok(())
    }

    /// Semantic action for production 62:
    ///
    /// ModportTerm: /\bmodport\b/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn modport_term(
        &mut self,
        modport_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let modport_term = modport_term
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let modport_term_built = ModportTermBuilder::default()
            .modport_term(modport_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.modport_term(&modport_term_built)?;
        self.push(ASTType::ModportTerm(modport_term_built), context);
        Ok(())
    }

    /// Semantic action for production 63:
    ///
    /// ModuleTerm: /\bmodule\b/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn module_term(
        &mut self,
        module_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module_term = module_term
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let module_term_built = ModuleTermBuilder::default()
            .module_term(module_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.module_term(&module_term_built)?;
        self.push(ASTType::ModuleTerm(module_term_built), context);
        Ok(())
    }

    /// Semantic action for production 64:
    ///
    /// NegedgeTerm: /\bnegedge\b/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn negedge_term(
        &mut self,
        negedge_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let negedge_term = negedge_term
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let negedge_term_built = NegedgeTermBuilder::default()
            .negedge_term(negedge_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.negedge_term(&negedge_term_built)?;
        self.push(ASTType::NegedgeTerm(negedge_term_built), context);
        Ok(())
    }

    /// Semantic action for production 65:
    ///
    /// OutputTerm: /\boutput\b/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn output_term(
        &mut self,
        output_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let output_term = output_term
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let output_term_built = OutputTermBuilder::default()
            .output_term(output_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.output_term(&output_term_built)?;
        self.push(ASTType::OutputTerm(output_term_built), context);
        Ok(())
    }

    /// Semantic action for production 66:
    ///
    /// PackageTerm: /\bpackage\b/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn package_term(
        &mut self,
        package_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let package_term = package_term
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let package_term_built = PackageTermBuilder::default()
            .package_term(package_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.package_term(&package_term_built)?;
        self.push(ASTType::PackageTerm(package_term_built), context);
        Ok(())
    }

    /// Semantic action for production 67:
    ///
    /// ParameterTerm: /\bparameter\b/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn parameter_term(
        &mut self,
        parameter_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let parameter_term = parameter_term
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let parameter_term_built = ParameterTermBuilder::default()
            .parameter_term(parameter_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.parameter_term(&parameter_term_built)?;
        self.push(ASTType::ParameterTerm(parameter_term_built), context);
        Ok(())
    }

    /// Semantic action for production 68:
    ///
    /// PosedgeTerm: /\bposedge\b/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn posedge_term(
        &mut self,
        posedge_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let posedge_term = posedge_term
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let posedge_term_built = PosedgeTermBuilder::default()
            .posedge_term(posedge_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.posedge_term(&posedge_term_built)?;
        self.push(ASTType::PosedgeTerm(posedge_term_built), context);
        Ok(())
    }

    /// Semantic action for production 69:
    ///
    /// RefTerm: /\bref\b/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn ref_term(
        &mut self,
        ref_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ref_term = ref_term.token(parse_tree)?.try_into().into_diagnostic()?;
        let ref_term_built = RefTermBuilder::default()
            .ref_term(ref_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.ref_term(&ref_term_built)?;
        self.push(ASTType::RefTerm(ref_term_built), context);
        Ok(())
    }

    /// Semantic action for production 70:
    ///
    /// ReturnTerm: /\breturn\b/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn return_term(
        &mut self,
        return_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let return_term = return_term
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let return_term_built = ReturnTermBuilder::default()
            .return_term(return_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.return_term(&return_term_built)?;
        self.push(ASTType::ReturnTerm(return_term_built), context);
        Ok(())
    }

    /// Semantic action for production 71:
    ///
    /// StepTerm: /\bstep\b/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn step_term(
        &mut self,
        step_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let step_term = step_term.token(parse_tree)?.try_into().into_diagnostic()?;
        let step_term_built = StepTermBuilder::default()
            .step_term(step_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.step_term(&step_term_built)?;
        self.push(ASTType::StepTerm(step_term_built), context);
        Ok(())
    }

    /// Semantic action for production 72:
    ///
    /// StructTerm: /\bstruct\b/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn struct_term(
        &mut self,
        struct_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let struct_term = struct_term
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let struct_term_built = StructTermBuilder::default()
            .struct_term(struct_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.struct_term(&struct_term_built)?;
        self.push(ASTType::StructTerm(struct_term_built), context);
        Ok(())
    }

    /// Semantic action for production 73:
    ///
    /// SyncHighTerm: /\bsync_high\b/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn sync_high_term(
        &mut self,
        sync_high_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let sync_high_term = sync_high_term
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let sync_high_term_built = SyncHighTermBuilder::default()
            .sync_high_term(sync_high_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.sync_high_term(&sync_high_term_built)?;
        self.push(ASTType::SyncHighTerm(sync_high_term_built), context);
        Ok(())
    }

    /// Semantic action for production 74:
    ///
    /// SyncLowTerm: /\bsync_low\b/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn sync_low_term(
        &mut self,
        sync_low_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let sync_low_term = sync_low_term
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let sync_low_term_built = SyncLowTermBuilder::default()
            .sync_low_term(sync_low_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.sync_low_term(&sync_low_term_built)?;
        self.push(ASTType::SyncLowTerm(sync_low_term_built), context);
        Ok(())
    }

    /// Semantic action for production 75:
    ///
    /// U32Term: /\bu32\b/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn u32_term(
        &mut self,
        u32_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let u32_term = u32_term.token(parse_tree)?.try_into().into_diagnostic()?;
        let u32_term_built = U32TermBuilder::default()
            .u32_term(u32_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.u32_term(&u32_term_built)?;
        self.push(ASTType::U32Term(u32_term_built), context);
        Ok(())
    }

    /// Semantic action for production 76:
    ///
    /// U64Term: /\bu64\b/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn u64_term(
        &mut self,
        u64_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let u64_term = u64_term.token(parse_tree)?.try_into().into_diagnostic()?;
        let u64_term_built = U64TermBuilder::default()
            .u64_term(u64_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.u64_term(&u64_term_built)?;
        self.push(ASTType::U64Term(u64_term_built), context);
        Ok(())
    }

    /// Semantic action for production 77:
    ///
    /// VarTerm: /\bvar\b/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn var_term(
        &mut self,
        var_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let var_term = var_term.token(parse_tree)?.try_into().into_diagnostic()?;
        let var_term_built = VarTermBuilder::default()
            .var_term(var_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.var_term(&var_term_built)?;
        self.push(ASTType::VarTerm(var_term_built), context);
        Ok(())
    }

    /// Semantic action for production 78:
    ///
    /// IdentifierTerm: /[a-zA-Z_][0-9a-zA-Z_]*/ : Token;
    ///
    #[parol_runtime::function_name::named]
    fn identifier_term(
        &mut self,
        identifier_term: &ParseTreeStackEntry<'t>,
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let identifier_term = identifier_term
            .token(parse_tree)?
            .try_into()
            .into_diagnostic()?;
        let identifier_term_built = IdentifierTermBuilder::default()
            .identifier_term(identifier_term)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.identifier_term(&identifier_term_built)?;
        self.push(ASTType::IdentifierTerm(identifier_term_built), context);
        Ok(())
    }

    /// Semantic action for production 79:
    ///
    /// Comments: CommentsOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn comments(
        &mut self,
        _comments_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments_opt = pop_item!(self, comments_opt, CommentsOpt, context);
        let comments_built = CommentsBuilder::default()
            .comments_opt(comments_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.comments(&comments_built)?;
        self.push(ASTType::Comments(comments_built), context);
        Ok(())
    }

    /// Semantic action for production 80:
    ///
    /// CommentsOpt /* Option<T>::Some */: CommentsTerm;
    ///
    #[parol_runtime::function_name::named]
    fn comments_opt_0(
        &mut self,
        _comments_term: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments_term = pop_item!(self, comments_term, CommentsTerm, context);
        let comments_opt_0_built = CommentsOptBuilder::default()
            .comments_term(Box::new(comments_term))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::CommentsOpt(Some(Box::new(comments_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 81:
    ///
    /// CommentsOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn comments_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::CommentsOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 82:
    ///
    /// StartToken: Comments;
    ///
    #[parol_runtime::function_name::named]
    fn start_token(
        &mut self,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let start_token_built = StartTokenBuilder::default()
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.start_token(&start_token_built)?;
        self.push(ASTType::StartToken(start_token_built), context);
        Ok(())
    }

    /// Semantic action for production 83:
    ///
    /// ExponentToken: ExponentTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn exponent_token(
        &mut self,
        _exponent_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let exponent_term = pop_item!(self, exponent_term, ExponentTerm, context);
        let exponent_token_built = ExponentTokenBuilder::default()
            .exponent_term((&exponent_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.exponent_token(&exponent_token_built)?;
        self.push(ASTType::ExponentToken(exponent_token_built), context);
        Ok(())
    }

    /// Semantic action for production 84:
    ///
    /// FixedPointToken: FixedPointTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn fixed_point_token(
        &mut self,
        _fixed_point_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let fixed_point_term = pop_item!(self, fixed_point_term, FixedPointTerm, context);
        let fixed_point_token_built = FixedPointTokenBuilder::default()
            .fixed_point_term((&fixed_point_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .fixed_point_token(&fixed_point_token_built)?;
        self.push(ASTType::FixedPointToken(fixed_point_token_built), context);
        Ok(())
    }

    /// Semantic action for production 85:
    ///
    /// BasedToken: BasedTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn based_token(
        &mut self,
        _based_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let based_term = pop_item!(self, based_term, BasedTerm, context);
        let based_token_built = BasedTokenBuilder::default()
            .based_term((&based_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.based_token(&based_token_built)?;
        self.push(ASTType::BasedToken(based_token_built), context);
        Ok(())
    }

    /// Semantic action for production 86:
    ///
    /// BaseLessToken: BaseLessTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn base_less_token(
        &mut self,
        _base_less_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let base_less_term = pop_item!(self, base_less_term, BaseLessTerm, context);
        let base_less_token_built = BaseLessTokenBuilder::default()
            .base_less_term((&base_less_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.base_less_token(&base_less_token_built)?;
        self.push(ASTType::BaseLessToken(base_less_token_built), context);
        Ok(())
    }

    /// Semantic action for production 87:
    ///
    /// AllBitToken: AllBitTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn all_bit_token(
        &mut self,
        _all_bit_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let all_bit_term = pop_item!(self, all_bit_term, AllBitTerm, context);
        let all_bit_token_built = AllBitTokenBuilder::default()
            .all_bit_term((&all_bit_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.all_bit_token(&all_bit_token_built)?;
        self.push(ASTType::AllBitToken(all_bit_token_built), context);
        Ok(())
    }

    /// Semantic action for production 88:
    ///
    /// AssignmentOperatorToken: AssignmentOperatorTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn assignment_operator_token(
        &mut self,
        _assignment_operator_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let assignment_operator_term = pop_item!(
            self,
            assignment_operator_term,
            AssignmentOperatorTerm,
            context
        );
        let assignment_operator_token_built = AssignmentOperatorTokenBuilder::default()
            .assignment_operator_term((&assignment_operator_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .assignment_operator_token(&assignment_operator_token_built)?;
        self.push(
            ASTType::AssignmentOperatorToken(assignment_operator_token_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 89:
    ///
    /// Operator01Token: Operator01Term : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn operator01_token(
        &mut self,
        _operator01_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let operator01_term = pop_item!(self, operator01_term, Operator01Term, context);
        let operator01_token_built = Operator01TokenBuilder::default()
            .operator01_term((&operator01_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .operator01_token(&operator01_token_built)?;
        self.push(ASTType::Operator01Token(operator01_token_built), context);
        Ok(())
    }

    /// Semantic action for production 90:
    ///
    /// Operator02Token: Operator02Term : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn operator02_token(
        &mut self,
        _operator02_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let operator02_term = pop_item!(self, operator02_term, Operator02Term, context);
        let operator02_token_built = Operator02TokenBuilder::default()
            .operator02_term((&operator02_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .operator02_token(&operator02_token_built)?;
        self.push(ASTType::Operator02Token(operator02_token_built), context);
        Ok(())
    }

    /// Semantic action for production 91:
    ///
    /// Operator03Token: Operator03Term : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn operator03_token(
        &mut self,
        _operator03_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let operator03_term = pop_item!(self, operator03_term, Operator03Term, context);
        let operator03_token_built = Operator03TokenBuilder::default()
            .operator03_term((&operator03_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .operator03_token(&operator03_token_built)?;
        self.push(ASTType::Operator03Token(operator03_token_built), context);
        Ok(())
    }

    /// Semantic action for production 92:
    ///
    /// Operator04Token: Operator04Term : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn operator04_token(
        &mut self,
        _operator04_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let operator04_term = pop_item!(self, operator04_term, Operator04Term, context);
        let operator04_token_built = Operator04TokenBuilder::default()
            .operator04_term((&operator04_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .operator04_token(&operator04_token_built)?;
        self.push(ASTType::Operator04Token(operator04_token_built), context);
        Ok(())
    }

    /// Semantic action for production 93:
    ///
    /// Operator05Token: Operator05Term : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn operator05_token(
        &mut self,
        _operator05_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let operator05_term = pop_item!(self, operator05_term, Operator05Term, context);
        let operator05_token_built = Operator05TokenBuilder::default()
            .operator05_term((&operator05_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .operator05_token(&operator05_token_built)?;
        self.push(ASTType::Operator05Token(operator05_token_built), context);
        Ok(())
    }

    /// Semantic action for production 94:
    ///
    /// Operator06Token: Operator06Term : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn operator06_token(
        &mut self,
        _operator06_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let operator06_term = pop_item!(self, operator06_term, Operator06Term, context);
        let operator06_token_built = Operator06TokenBuilder::default()
            .operator06_term((&operator06_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .operator06_token(&operator06_token_built)?;
        self.push(ASTType::Operator06Token(operator06_token_built), context);
        Ok(())
    }

    /// Semantic action for production 95:
    ///
    /// Operator07Token: Operator07Term : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn operator07_token(
        &mut self,
        _operator07_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let operator07_term = pop_item!(self, operator07_term, Operator07Term, context);
        let operator07_token_built = Operator07TokenBuilder::default()
            .operator07_term((&operator07_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .operator07_token(&operator07_token_built)?;
        self.push(ASTType::Operator07Token(operator07_token_built), context);
        Ok(())
    }

    /// Semantic action for production 96:
    ///
    /// Operator08Token: Operator08Term : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn operator08_token(
        &mut self,
        _operator08_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let operator08_term = pop_item!(self, operator08_term, Operator08Term, context);
        let operator08_token_built = Operator08TokenBuilder::default()
            .operator08_term((&operator08_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .operator08_token(&operator08_token_built)?;
        self.push(ASTType::Operator08Token(operator08_token_built), context);
        Ok(())
    }

    /// Semantic action for production 97:
    ///
    /// Operator09Token: Operator09Term : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn operator09_token(
        &mut self,
        _operator09_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let operator09_term = pop_item!(self, operator09_term, Operator09Term, context);
        let operator09_token_built = Operator09TokenBuilder::default()
            .operator09_term((&operator09_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .operator09_token(&operator09_token_built)?;
        self.push(ASTType::Operator09Token(operator09_token_built), context);
        Ok(())
    }

    /// Semantic action for production 98:
    ///
    /// Operator10Token: Operator10Term : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn operator10_token(
        &mut self,
        _operator10_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let operator10_term = pop_item!(self, operator10_term, Operator10Term, context);
        let operator10_token_built = Operator10TokenBuilder::default()
            .operator10_term((&operator10_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .operator10_token(&operator10_token_built)?;
        self.push(ASTType::Operator10Token(operator10_token_built), context);
        Ok(())
    }

    /// Semantic action for production 99:
    ///
    /// Operator11Token: Operator11Term : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn operator11_token(
        &mut self,
        _operator11_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let operator11_term = pop_item!(self, operator11_term, Operator11Term, context);
        let operator11_token_built = Operator11TokenBuilder::default()
            .operator11_term((&operator11_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .operator11_token(&operator11_token_built)?;
        self.push(ASTType::Operator11Token(operator11_token_built), context);
        Ok(())
    }

    /// Semantic action for production 100:
    ///
    /// UnaryOperatorToken: UnaryOperatorTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn unary_operator_token(
        &mut self,
        _unary_operator_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let unary_operator_term = pop_item!(self, unary_operator_term, UnaryOperatorTerm, context);
        let unary_operator_token_built = UnaryOperatorTokenBuilder::default()
            .unary_operator_term((&unary_operator_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .unary_operator_token(&unary_operator_token_built)?;
        self.push(
            ASTType::UnaryOperatorToken(unary_operator_token_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 101:
    ///
    /// ColonToken: ColonTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn colon_token(
        &mut self,
        _colon_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let colon_term = pop_item!(self, colon_term, ColonTerm, context);
        let colon_token_built = ColonTokenBuilder::default()
            .colon_term((&colon_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.colon_token(&colon_token_built)?;
        self.push(ASTType::ColonToken(colon_token_built), context);
        Ok(())
    }

    /// Semantic action for production 102:
    ///
    /// ColonColonToken: ColonColonTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn colon_colon_token(
        &mut self,
        _colon_colon_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let colon_colon_term = pop_item!(self, colon_colon_term, ColonColonTerm, context);
        let colon_colon_token_built = ColonColonTokenBuilder::default()
            .colon_colon_term((&colon_colon_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .colon_colon_token(&colon_colon_token_built)?;
        self.push(ASTType::ColonColonToken(colon_colon_token_built), context);
        Ok(())
    }

    /// Semantic action for production 103:
    ///
    /// CommaToken: CommaTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn comma_token(
        &mut self,
        _comma_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let comma_term = pop_item!(self, comma_term, CommaTerm, context);
        let comma_token_built = CommaTokenBuilder::default()
            .comma_term((&comma_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.comma_token(&comma_token_built)?;
        self.push(ASTType::CommaToken(comma_token_built), context);
        Ok(())
    }

    /// Semantic action for production 104:
    ///
    /// DollarToken: DollarTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn dollar_token(
        &mut self,
        _dollar_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let dollar_term = pop_item!(self, dollar_term, DollarTerm, context);
        let dollar_token_built = DollarTokenBuilder::default()
            .dollar_term((&dollar_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.dollar_token(&dollar_token_built)?;
        self.push(ASTType::DollarToken(dollar_token_built), context);
        Ok(())
    }

    /// Semantic action for production 105:
    ///
    /// DotDotToken: DotDotTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn dot_dot_token(
        &mut self,
        _dot_dot_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let dot_dot_term = pop_item!(self, dot_dot_term, DotDotTerm, context);
        let dot_dot_token_built = DotDotTokenBuilder::default()
            .dot_dot_term((&dot_dot_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.dot_dot_token(&dot_dot_token_built)?;
        self.push(ASTType::DotDotToken(dot_dot_token_built), context);
        Ok(())
    }

    /// Semantic action for production 106:
    ///
    /// DotToken: DotTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn dot_token(
        &mut self,
        _dot_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let dot_term = pop_item!(self, dot_term, DotTerm, context);
        let dot_token_built = DotTokenBuilder::default()
            .dot_term((&dot_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.dot_token(&dot_token_built)?;
        self.push(ASTType::DotToken(dot_token_built), context);
        Ok(())
    }

    /// Semantic action for production 107:
    ///
    /// EquToken: EquTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn equ_token(
        &mut self,
        _equ_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let equ_term = pop_item!(self, equ_term, EquTerm, context);
        let equ_token_built = EquTokenBuilder::default()
            .equ_term((&equ_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.equ_token(&equ_token_built)?;
        self.push(ASTType::EquToken(equ_token_built), context);
        Ok(())
    }

    /// Semantic action for production 108:
    ///
    /// HashToken: HashTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn hash_token(
        &mut self,
        _hash_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let hash_term = pop_item!(self, hash_term, HashTerm, context);
        let hash_token_built = HashTokenBuilder::default()
            .hash_term((&hash_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.hash_token(&hash_token_built)?;
        self.push(ASTType::HashToken(hash_token_built), context);
        Ok(())
    }

    /// Semantic action for production 109:
    ///
    /// LBraceToken: LBraceTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn l_brace_token(
        &mut self,
        _l_brace_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let l_brace_term = pop_item!(self, l_brace_term, LBraceTerm, context);
        let l_brace_token_built = LBraceTokenBuilder::default()
            .l_brace_term((&l_brace_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.l_brace_token(&l_brace_token_built)?;
        self.push(ASTType::LBraceToken(l_brace_token_built), context);
        Ok(())
    }

    /// Semantic action for production 110:
    ///
    /// LBracketToken: LBracketTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn l_bracket_token(
        &mut self,
        _l_bracket_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let l_bracket_term = pop_item!(self, l_bracket_term, LBracketTerm, context);
        let l_bracket_token_built = LBracketTokenBuilder::default()
            .l_bracket_term((&l_bracket_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.l_bracket_token(&l_bracket_token_built)?;
        self.push(ASTType::LBracketToken(l_bracket_token_built), context);
        Ok(())
    }

    /// Semantic action for production 111:
    ///
    /// LParenToken: LParenTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn l_paren_token(
        &mut self,
        _l_paren_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let l_paren_term = pop_item!(self, l_paren_term, LParenTerm, context);
        let l_paren_token_built = LParenTokenBuilder::default()
            .l_paren_term((&l_paren_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.l_paren_token(&l_paren_token_built)?;
        self.push(ASTType::LParenToken(l_paren_token_built), context);
        Ok(())
    }

    /// Semantic action for production 112:
    ///
    /// MinusColonToken: MinusColonTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn minus_colon_token(
        &mut self,
        _minus_colon_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let minus_colon_term = pop_item!(self, minus_colon_term, MinusColonTerm, context);
        let minus_colon_token_built = MinusColonTokenBuilder::default()
            .minus_colon_term((&minus_colon_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .minus_colon_token(&minus_colon_token_built)?;
        self.push(ASTType::MinusColonToken(minus_colon_token_built), context);
        Ok(())
    }

    /// Semantic action for production 113:
    ///
    /// MinusGTToken: MinusGTTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn minus_g_t_token(
        &mut self,
        _minus_g_t_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let minus_g_t_term = pop_item!(self, minus_g_t_term, MinusGTTerm, context);
        let minus_g_t_token_built = MinusGTTokenBuilder::default()
            .minus_g_t_term((&minus_g_t_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.minus_g_t_token(&minus_g_t_token_built)?;
        self.push(ASTType::MinusGTToken(minus_g_t_token_built), context);
        Ok(())
    }

    /// Semantic action for production 114:
    ///
    /// PlusColonToken: PlusColonTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn plus_colon_token(
        &mut self,
        _plus_colon_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let plus_colon_term = pop_item!(self, plus_colon_term, PlusColonTerm, context);
        let plus_colon_token_built = PlusColonTokenBuilder::default()
            .plus_colon_term((&plus_colon_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .plus_colon_token(&plus_colon_token_built)?;
        self.push(ASTType::PlusColonToken(plus_colon_token_built), context);
        Ok(())
    }

    /// Semantic action for production 115:
    ///
    /// RBraceToken: RBraceTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn r_brace_token(
        &mut self,
        _r_brace_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let r_brace_term = pop_item!(self, r_brace_term, RBraceTerm, context);
        let r_brace_token_built = RBraceTokenBuilder::default()
            .r_brace_term((&r_brace_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.r_brace_token(&r_brace_token_built)?;
        self.push(ASTType::RBraceToken(r_brace_token_built), context);
        Ok(())
    }

    /// Semantic action for production 116:
    ///
    /// RBracketToken: RBracketTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn r_bracket_token(
        &mut self,
        _r_bracket_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let r_bracket_term = pop_item!(self, r_bracket_term, RBracketTerm, context);
        let r_bracket_token_built = RBracketTokenBuilder::default()
            .r_bracket_term((&r_bracket_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.r_bracket_token(&r_bracket_token_built)?;
        self.push(ASTType::RBracketToken(r_bracket_token_built), context);
        Ok(())
    }

    /// Semantic action for production 117:
    ///
    /// RParenToken: RParenTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn r_paren_token(
        &mut self,
        _r_paren_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let r_paren_term = pop_item!(self, r_paren_term, RParenTerm, context);
        let r_paren_token_built = RParenTokenBuilder::default()
            .r_paren_term((&r_paren_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.r_paren_token(&r_paren_token_built)?;
        self.push(ASTType::RParenToken(r_paren_token_built), context);
        Ok(())
    }

    /// Semantic action for production 118:
    ///
    /// SemicolonToken: SemicolonTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn semicolon_token(
        &mut self,
        _semicolon_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let semicolon_term = pop_item!(self, semicolon_term, SemicolonTerm, context);
        let semicolon_token_built = SemicolonTokenBuilder::default()
            .semicolon_term((&semicolon_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.semicolon_token(&semicolon_token_built)?;
        self.push(ASTType::SemicolonToken(semicolon_token_built), context);
        Ok(())
    }

    /// Semantic action for production 119:
    ///
    /// AlwaysCombToken: AlwaysCombTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn always_comb_token(
        &mut self,
        _always_comb_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let always_comb_term = pop_item!(self, always_comb_term, AlwaysCombTerm, context);
        let always_comb_token_built = AlwaysCombTokenBuilder::default()
            .always_comb_term((&always_comb_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .always_comb_token(&always_comb_token_built)?;
        self.push(ASTType::AlwaysCombToken(always_comb_token_built), context);
        Ok(())
    }

    /// Semantic action for production 120:
    ///
    /// AlwaysFfToken: AlwaysFfTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_token(
        &mut self,
        _always_ff_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let always_ff_term = pop_item!(self, always_ff_term, AlwaysFfTerm, context);
        let always_ff_token_built = AlwaysFfTokenBuilder::default()
            .always_ff_term((&always_ff_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.always_ff_token(&always_ff_token_built)?;
        self.push(ASTType::AlwaysFfToken(always_ff_token_built), context);
        Ok(())
    }

    /// Semantic action for production 121:
    ///
    /// AssignToken: AssignTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn assign_token(
        &mut self,
        _assign_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let assign_term = pop_item!(self, assign_term, AssignTerm, context);
        let assign_token_built = AssignTokenBuilder::default()
            .assign_term((&assign_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.assign_token(&assign_token_built)?;
        self.push(ASTType::AssignToken(assign_token_built), context);
        Ok(())
    }

    /// Semantic action for production 122:
    ///
    /// AsyncHighToken: AsyncHighTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn async_high_token(
        &mut self,
        _async_high_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let async_high_term = pop_item!(self, async_high_term, AsyncHighTerm, context);
        let async_high_token_built = AsyncHighTokenBuilder::default()
            .async_high_term((&async_high_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .async_high_token(&async_high_token_built)?;
        self.push(ASTType::AsyncHighToken(async_high_token_built), context);
        Ok(())
    }

    /// Semantic action for production 123:
    ///
    /// AsyncLowToken: AsyncLowTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn async_low_token(
        &mut self,
        _async_low_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let async_low_term = pop_item!(self, async_low_term, AsyncLowTerm, context);
        let async_low_token_built = AsyncLowTokenBuilder::default()
            .async_low_term((&async_low_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.async_low_token(&async_low_token_built)?;
        self.push(ASTType::AsyncLowToken(async_low_token_built), context);
        Ok(())
    }

    /// Semantic action for production 124:
    ///
    /// BitToken: BitTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn bit_token(
        &mut self,
        _bit_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let bit_term = pop_item!(self, bit_term, BitTerm, context);
        let bit_token_built = BitTokenBuilder::default()
            .bit_term((&bit_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.bit_token(&bit_token_built)?;
        self.push(ASTType::BitToken(bit_token_built), context);
        Ok(())
    }

    /// Semantic action for production 125:
    ///
    /// CaseToken: CaseTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn case_token(
        &mut self,
        _case_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let case_term = pop_item!(self, case_term, CaseTerm, context);
        let case_token_built = CaseTokenBuilder::default()
            .case_term((&case_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.case_token(&case_token_built)?;
        self.push(ASTType::CaseToken(case_token_built), context);
        Ok(())
    }

    /// Semantic action for production 126:
    ///
    /// DefaultToken: DefaultTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn default_token(
        &mut self,
        _default_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let default_term = pop_item!(self, default_term, DefaultTerm, context);
        let default_token_built = DefaultTokenBuilder::default()
            .default_term((&default_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.default_token(&default_token_built)?;
        self.push(ASTType::DefaultToken(default_token_built), context);
        Ok(())
    }

    /// Semantic action for production 127:
    ///
    /// ElseToken: ElseTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn else_token(
        &mut self,
        _else_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let else_term = pop_item!(self, else_term, ElseTerm, context);
        let else_token_built = ElseTokenBuilder::default()
            .else_term((&else_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.else_token(&else_token_built)?;
        self.push(ASTType::ElseToken(else_token_built), context);
        Ok(())
    }

    /// Semantic action for production 128:
    ///
    /// EnumToken: EnumTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn enum_token(
        &mut self,
        _enum_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let enum_term = pop_item!(self, enum_term, EnumTerm, context);
        let enum_token_built = EnumTokenBuilder::default()
            .enum_term((&enum_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.enum_token(&enum_token_built)?;
        self.push(ASTType::EnumToken(enum_token_built), context);
        Ok(())
    }

    /// Semantic action for production 129:
    ///
    /// F32Token: F32Term : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn f32_token(
        &mut self,
        _f32_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let f32_term = pop_item!(self, f32_term, F32Term, context);
        let f32_token_built = F32TokenBuilder::default()
            .f32_term((&f32_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.f32_token(&f32_token_built)?;
        self.push(ASTType::F32Token(f32_token_built), context);
        Ok(())
    }

    /// Semantic action for production 130:
    ///
    /// F64Token: F64Term : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn f64_token(
        &mut self,
        _f64_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let f64_term = pop_item!(self, f64_term, F64Term, context);
        let f64_token_built = F64TokenBuilder::default()
            .f64_term((&f64_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.f64_token(&f64_token_built)?;
        self.push(ASTType::F64Token(f64_token_built), context);
        Ok(())
    }

    /// Semantic action for production 131:
    ///
    /// ForToken: ForTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn for_token(
        &mut self,
        _for_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let for_term = pop_item!(self, for_term, ForTerm, context);
        let for_token_built = ForTokenBuilder::default()
            .for_term((&for_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.for_token(&for_token_built)?;
        self.push(ASTType::ForToken(for_token_built), context);
        Ok(())
    }

    /// Semantic action for production 132:
    ///
    /// FunctionToken: FunctionTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn function_token(
        &mut self,
        _function_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let function_term = pop_item!(self, function_term, FunctionTerm, context);
        let function_token_built = FunctionTokenBuilder::default()
            .function_term((&function_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.function_token(&function_token_built)?;
        self.push(ASTType::FunctionToken(function_token_built), context);
        Ok(())
    }

    /// Semantic action for production 133:
    ///
    /// I32Token: I32Term : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn i32_token(
        &mut self,
        _i32_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let i32_term = pop_item!(self, i32_term, I32Term, context);
        let i32_token_built = I32TokenBuilder::default()
            .i32_term((&i32_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.i32_token(&i32_token_built)?;
        self.push(ASTType::I32Token(i32_token_built), context);
        Ok(())
    }

    /// Semantic action for production 134:
    ///
    /// I64Token: I64Term : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn i64_token(
        &mut self,
        _i64_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let i64_term = pop_item!(self, i64_term, I64Term, context);
        let i64_token_built = I64TokenBuilder::default()
            .i64_term((&i64_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.i64_token(&i64_token_built)?;
        self.push(ASTType::I64Token(i64_token_built), context);
        Ok(())
    }

    /// Semantic action for production 135:
    ///
    /// IfResetToken: IfResetTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn if_reset_token(
        &mut self,
        _if_reset_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let if_reset_term = pop_item!(self, if_reset_term, IfResetTerm, context);
        let if_reset_token_built = IfResetTokenBuilder::default()
            .if_reset_term((&if_reset_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.if_reset_token(&if_reset_token_built)?;
        self.push(ASTType::IfResetToken(if_reset_token_built), context);
        Ok(())
    }

    /// Semantic action for production 136:
    ///
    /// IfToken: IfTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn if_token(
        &mut self,
        _if_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let if_term = pop_item!(self, if_term, IfTerm, context);
        let if_token_built = IfTokenBuilder::default()
            .if_term((&if_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.if_token(&if_token_built)?;
        self.push(ASTType::IfToken(if_token_built), context);
        Ok(())
    }

    /// Semantic action for production 137:
    ///
    /// InoutToken: InoutTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn inout_token(
        &mut self,
        _inout_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let inout_term = pop_item!(self, inout_term, InoutTerm, context);
        let inout_token_built = InoutTokenBuilder::default()
            .inout_term((&inout_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.inout_token(&inout_token_built)?;
        self.push(ASTType::InoutToken(inout_token_built), context);
        Ok(())
    }

    /// Semantic action for production 138:
    ///
    /// InputToken: InputTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn input_token(
        &mut self,
        _input_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let input_term = pop_item!(self, input_term, InputTerm, context);
        let input_token_built = InputTokenBuilder::default()
            .input_term((&input_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.input_token(&input_token_built)?;
        self.push(ASTType::InputToken(input_token_built), context);
        Ok(())
    }

    /// Semantic action for production 139:
    ///
    /// InstToken: InstTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn inst_token(
        &mut self,
        _inst_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let inst_term = pop_item!(self, inst_term, InstTerm, context);
        let inst_token_built = InstTokenBuilder::default()
            .inst_term((&inst_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.inst_token(&inst_token_built)?;
        self.push(ASTType::InstToken(inst_token_built), context);
        Ok(())
    }

    /// Semantic action for production 140:
    ///
    /// InterfaceToken: InterfaceTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn interface_token(
        &mut self,
        _interface_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let interface_term = pop_item!(self, interface_term, InterfaceTerm, context);
        let interface_token_built = InterfaceTokenBuilder::default()
            .interface_term((&interface_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.interface_token(&interface_token_built)?;
        self.push(ASTType::InterfaceToken(interface_token_built), context);
        Ok(())
    }

    /// Semantic action for production 141:
    ///
    /// InToken: InTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn in_token(
        &mut self,
        _in_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let in_term = pop_item!(self, in_term, InTerm, context);
        let in_token_built = InTokenBuilder::default()
            .in_term((&in_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.in_token(&in_token_built)?;
        self.push(ASTType::InToken(in_token_built), context);
        Ok(())
    }

    /// Semantic action for production 142:
    ///
    /// LocalparamToken: LocalparamTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn localparam_token(
        &mut self,
        _localparam_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let localparam_term = pop_item!(self, localparam_term, LocalparamTerm, context);
        let localparam_token_built = LocalparamTokenBuilder::default()
            .localparam_term((&localparam_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .localparam_token(&localparam_token_built)?;
        self.push(ASTType::LocalparamToken(localparam_token_built), context);
        Ok(())
    }

    /// Semantic action for production 143:
    ///
    /// LogicToken: LogicTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn logic_token(
        &mut self,
        _logic_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let logic_term = pop_item!(self, logic_term, LogicTerm, context);
        let logic_token_built = LogicTokenBuilder::default()
            .logic_term((&logic_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.logic_token(&logic_token_built)?;
        self.push(ASTType::LogicToken(logic_token_built), context);
        Ok(())
    }

    /// Semantic action for production 144:
    ///
    /// ModportToken: ModportTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn modport_token(
        &mut self,
        _modport_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let modport_term = pop_item!(self, modport_term, ModportTerm, context);
        let modport_token_built = ModportTokenBuilder::default()
            .modport_term((&modport_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.modport_token(&modport_token_built)?;
        self.push(ASTType::ModportToken(modport_token_built), context);
        Ok(())
    }

    /// Semantic action for production 145:
    ///
    /// ModuleToken: ModuleTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn module_token(
        &mut self,
        _module_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let module_term = pop_item!(self, module_term, ModuleTerm, context);
        let module_token_built = ModuleTokenBuilder::default()
            .module_term((&module_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.module_token(&module_token_built)?;
        self.push(ASTType::ModuleToken(module_token_built), context);
        Ok(())
    }

    /// Semantic action for production 146:
    ///
    /// NegedgeToken: NegedgeTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn negedge_token(
        &mut self,
        _negedge_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let negedge_term = pop_item!(self, negedge_term, NegedgeTerm, context);
        let negedge_token_built = NegedgeTokenBuilder::default()
            .negedge_term((&negedge_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.negedge_token(&negedge_token_built)?;
        self.push(ASTType::NegedgeToken(negedge_token_built), context);
        Ok(())
    }

    /// Semantic action for production 147:
    ///
    /// OutputToken: OutputTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn output_token(
        &mut self,
        _output_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let output_term = pop_item!(self, output_term, OutputTerm, context);
        let output_token_built = OutputTokenBuilder::default()
            .output_term((&output_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.output_token(&output_token_built)?;
        self.push(ASTType::OutputToken(output_token_built), context);
        Ok(())
    }

    /// Semantic action for production 148:
    ///
    /// PackageToken: PackageTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn package_token(
        &mut self,
        _package_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let package_term = pop_item!(self, package_term, PackageTerm, context);
        let package_token_built = PackageTokenBuilder::default()
            .package_term((&package_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.package_token(&package_token_built)?;
        self.push(ASTType::PackageToken(package_token_built), context);
        Ok(())
    }

    /// Semantic action for production 149:
    ///
    /// ParameterToken: ParameterTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn parameter_token(
        &mut self,
        _parameter_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let parameter_term = pop_item!(self, parameter_term, ParameterTerm, context);
        let parameter_token_built = ParameterTokenBuilder::default()
            .parameter_term((&parameter_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.parameter_token(&parameter_token_built)?;
        self.push(ASTType::ParameterToken(parameter_token_built), context);
        Ok(())
    }

    /// Semantic action for production 150:
    ///
    /// PosedgeToken: PosedgeTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn posedge_token(
        &mut self,
        _posedge_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let posedge_term = pop_item!(self, posedge_term, PosedgeTerm, context);
        let posedge_token_built = PosedgeTokenBuilder::default()
            .posedge_term((&posedge_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.posedge_token(&posedge_token_built)?;
        self.push(ASTType::PosedgeToken(posedge_token_built), context);
        Ok(())
    }

    /// Semantic action for production 151:
    ///
    /// RefToken: RefTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn ref_token(
        &mut self,
        _ref_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let ref_term = pop_item!(self, ref_term, RefTerm, context);
        let ref_token_built = RefTokenBuilder::default()
            .ref_term((&ref_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.ref_token(&ref_token_built)?;
        self.push(ASTType::RefToken(ref_token_built), context);
        Ok(())
    }

    /// Semantic action for production 152:
    ///
    /// ReturnToken: ReturnTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn return_token(
        &mut self,
        _return_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let return_term = pop_item!(self, return_term, ReturnTerm, context);
        let return_token_built = ReturnTokenBuilder::default()
            .return_term((&return_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.return_token(&return_token_built)?;
        self.push(ASTType::ReturnToken(return_token_built), context);
        Ok(())
    }

    /// Semantic action for production 153:
    ///
    /// StepToken: StepTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn step_token(
        &mut self,
        _step_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let step_term = pop_item!(self, step_term, StepTerm, context);
        let step_token_built = StepTokenBuilder::default()
            .step_term((&step_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.step_token(&step_token_built)?;
        self.push(ASTType::StepToken(step_token_built), context);
        Ok(())
    }

    /// Semantic action for production 154:
    ///
    /// StructToken: StructTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn struct_token(
        &mut self,
        _struct_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let struct_term = pop_item!(self, struct_term, StructTerm, context);
        let struct_token_built = StructTokenBuilder::default()
            .struct_term((&struct_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.struct_token(&struct_token_built)?;
        self.push(ASTType::StructToken(struct_token_built), context);
        Ok(())
    }

    /// Semantic action for production 155:
    ///
    /// SyncHighToken: SyncHighTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn sync_high_token(
        &mut self,
        _sync_high_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let sync_high_term = pop_item!(self, sync_high_term, SyncHighTerm, context);
        let sync_high_token_built = SyncHighTokenBuilder::default()
            .sync_high_term((&sync_high_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.sync_high_token(&sync_high_token_built)?;
        self.push(ASTType::SyncHighToken(sync_high_token_built), context);
        Ok(())
    }

    /// Semantic action for production 156:
    ///
    /// SyncLowToken: SyncLowTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn sync_low_token(
        &mut self,
        _sync_low_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let sync_low_term = pop_item!(self, sync_low_term, SyncLowTerm, context);
        let sync_low_token_built = SyncLowTokenBuilder::default()
            .sync_low_term((&sync_low_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.sync_low_token(&sync_low_token_built)?;
        self.push(ASTType::SyncLowToken(sync_low_token_built), context);
        Ok(())
    }

    /// Semantic action for production 157:
    ///
    /// U32Token: U32Term : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn u32_token(
        &mut self,
        _u32_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let u32_term = pop_item!(self, u32_term, U32Term, context);
        let u32_token_built = U32TokenBuilder::default()
            .u32_term((&u32_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.u32_token(&u32_token_built)?;
        self.push(ASTType::U32Token(u32_token_built), context);
        Ok(())
    }

    /// Semantic action for production 158:
    ///
    /// U64Token: U64Term : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn u64_token(
        &mut self,
        _u64_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let u64_term = pop_item!(self, u64_term, U64Term, context);
        let u64_token_built = U64TokenBuilder::default()
            .u64_term((&u64_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.u64_token(&u64_token_built)?;
        self.push(ASTType::U64Token(u64_token_built), context);
        Ok(())
    }

    /// Semantic action for production 159:
    ///
    /// VarToken: VarTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn var_token(
        &mut self,
        _var_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let var_term = pop_item!(self, var_term, VarTerm, context);
        let var_token_built = VarTokenBuilder::default()
            .var_term((&var_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.var_token(&var_token_built)?;
        self.push(ASTType::VarToken(var_token_built), context);
        Ok(())
    }

    /// Semantic action for production 160:
    ///
    /// IdentifierToken: IdentifierTerm : Token Comments;
    ///
    #[parol_runtime::function_name::named]
    fn identifier_token(
        &mut self,
        _identifier_term: &ParseTreeStackEntry<'t>,
        _comments: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let identifier_term = pop_item!(self, identifier_term, IdentifierTerm, context);
        let identifier_token_built = IdentifierTokenBuilder::default()
            .identifier_term((&identifier_term).try_into().into_diagnostic()?)
            .comments(Box::new(comments))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .identifier_token(&identifier_token_built)?;
        self.push(ASTType::IdentifierToken(identifier_token_built), context);
        Ok(())
    }

    /// Semantic action for production 161:
    ///
    /// Start: StartToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn start(
        &mut self,
        _start_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let start_token = pop_item!(self, start_token, StartToken, context);
        let start_built = StartBuilder::default()
            .start_token((&start_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.start(&start_built)?;
        self.push(ASTType::Start(start_built), context);
        Ok(())
    }

    /// Semantic action for production 162:
    ///
    /// Exponent: ExponentToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn exponent(
        &mut self,
        _exponent_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let exponent_token = pop_item!(self, exponent_token, ExponentToken, context);
        let exponent_built = ExponentBuilder::default()
            .exponent_token((&exponent_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.exponent(&exponent_built)?;
        self.push(ASTType::Exponent(exponent_built), context);
        Ok(())
    }

    /// Semantic action for production 163:
    ///
    /// FixedPoint: FixedPointToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn fixed_point(
        &mut self,
        _fixed_point_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let fixed_point_token = pop_item!(self, fixed_point_token, FixedPointToken, context);
        let fixed_point_built = FixedPointBuilder::default()
            .fixed_point_token((&fixed_point_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.fixed_point(&fixed_point_built)?;
        self.push(ASTType::FixedPoint(fixed_point_built), context);
        Ok(())
    }

    /// Semantic action for production 164:
    ///
    /// Based: BasedToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn based(
        &mut self,
        _based_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let based_token = pop_item!(self, based_token, BasedToken, context);
        let based_built = BasedBuilder::default()
            .based_token((&based_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.based(&based_built)?;
        self.push(ASTType::Based(based_built), context);
        Ok(())
    }

    /// Semantic action for production 165:
    ///
    /// BaseLess: BaseLessToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn base_less(
        &mut self,
        _base_less_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let base_less_token = pop_item!(self, base_less_token, BaseLessToken, context);
        let base_less_built = BaseLessBuilder::default()
            .base_less_token((&base_less_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.base_less(&base_less_built)?;
        self.push(ASTType::BaseLess(base_less_built), context);
        Ok(())
    }

    /// Semantic action for production 166:
    ///
    /// AllBit: AllBitToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn all_bit(
        &mut self,
        _all_bit_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let all_bit_token = pop_item!(self, all_bit_token, AllBitToken, context);
        let all_bit_built = AllBitBuilder::default()
            .all_bit_token((&all_bit_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.all_bit(&all_bit_built)?;
        self.push(ASTType::AllBit(all_bit_built), context);
        Ok(())
    }

    /// Semantic action for production 167:
    ///
    /// AssignmentOperator: AssignmentOperatorToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn assignment_operator(
        &mut self,
        _assignment_operator_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let assignment_operator_token = pop_item!(
            self,
            assignment_operator_token,
            AssignmentOperatorToken,
            context
        );
        let assignment_operator_built = AssignmentOperatorBuilder::default()
            .assignment_operator_token((&assignment_operator_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .assignment_operator(&assignment_operator_built)?;
        self.push(
            ASTType::AssignmentOperator(assignment_operator_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 168:
    ///
    /// Operator01: Operator01Token : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn operator01(
        &mut self,
        _operator01_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator01_token = pop_item!(self, operator01_token, Operator01Token, context);
        let operator01_built = Operator01Builder::default()
            .operator01_token((&operator01_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.operator01(&operator01_built)?;
        self.push(ASTType::Operator01(operator01_built), context);
        Ok(())
    }

    /// Semantic action for production 169:
    ///
    /// Operator02: Operator02Token : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn operator02(
        &mut self,
        _operator02_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator02_token = pop_item!(self, operator02_token, Operator02Token, context);
        let operator02_built = Operator02Builder::default()
            .operator02_token((&operator02_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.operator02(&operator02_built)?;
        self.push(ASTType::Operator02(operator02_built), context);
        Ok(())
    }

    /// Semantic action for production 170:
    ///
    /// Operator03: Operator03Token : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn operator03(
        &mut self,
        _operator03_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator03_token = pop_item!(self, operator03_token, Operator03Token, context);
        let operator03_built = Operator03Builder::default()
            .operator03_token((&operator03_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.operator03(&operator03_built)?;
        self.push(ASTType::Operator03(operator03_built), context);
        Ok(())
    }

    /// Semantic action for production 171:
    ///
    /// Operator04: Operator04Token : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn operator04(
        &mut self,
        _operator04_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator04_token = pop_item!(self, operator04_token, Operator04Token, context);
        let operator04_built = Operator04Builder::default()
            .operator04_token((&operator04_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.operator04(&operator04_built)?;
        self.push(ASTType::Operator04(operator04_built), context);
        Ok(())
    }

    /// Semantic action for production 172:
    ///
    /// Operator05: Operator05Token : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn operator05(
        &mut self,
        _operator05_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator05_token = pop_item!(self, operator05_token, Operator05Token, context);
        let operator05_built = Operator05Builder::default()
            .operator05_token((&operator05_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.operator05(&operator05_built)?;
        self.push(ASTType::Operator05(operator05_built), context);
        Ok(())
    }

    /// Semantic action for production 173:
    ///
    /// Operator06: Operator06Token : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn operator06(
        &mut self,
        _operator06_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator06_token = pop_item!(self, operator06_token, Operator06Token, context);
        let operator06_built = Operator06Builder::default()
            .operator06_token((&operator06_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.operator06(&operator06_built)?;
        self.push(ASTType::Operator06(operator06_built), context);
        Ok(())
    }

    /// Semantic action for production 174:
    ///
    /// Operator07: Operator07Token : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn operator07(
        &mut self,
        _operator07_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator07_token = pop_item!(self, operator07_token, Operator07Token, context);
        let operator07_built = Operator07Builder::default()
            .operator07_token((&operator07_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.operator07(&operator07_built)?;
        self.push(ASTType::Operator07(operator07_built), context);
        Ok(())
    }

    /// Semantic action for production 175:
    ///
    /// Operator08: Operator08Token : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn operator08(
        &mut self,
        _operator08_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator08_token = pop_item!(self, operator08_token, Operator08Token, context);
        let operator08_built = Operator08Builder::default()
            .operator08_token((&operator08_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.operator08(&operator08_built)?;
        self.push(ASTType::Operator08(operator08_built), context);
        Ok(())
    }

    /// Semantic action for production 176:
    ///
    /// Operator09: Operator09Token : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn operator09(
        &mut self,
        _operator09_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator09_token = pop_item!(self, operator09_token, Operator09Token, context);
        let operator09_built = Operator09Builder::default()
            .operator09_token((&operator09_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.operator09(&operator09_built)?;
        self.push(ASTType::Operator09(operator09_built), context);
        Ok(())
    }

    /// Semantic action for production 177:
    ///
    /// Operator10: Operator10Token : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn operator10(
        &mut self,
        _operator10_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator10_token = pop_item!(self, operator10_token, Operator10Token, context);
        let operator10_built = Operator10Builder::default()
            .operator10_token((&operator10_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.operator10(&operator10_built)?;
        self.push(ASTType::Operator10(operator10_built), context);
        Ok(())
    }

    /// Semantic action for production 178:
    ///
    /// Operator11: Operator11Token : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn operator11(
        &mut self,
        _operator11_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator11_token = pop_item!(self, operator11_token, Operator11Token, context);
        let operator11_built = Operator11Builder::default()
            .operator11_token((&operator11_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.operator11(&operator11_built)?;
        self.push(ASTType::Operator11(operator11_built), context);
        Ok(())
    }

    /// Semantic action for production 179:
    ///
    /// UnaryOperator: UnaryOperatorToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn unary_operator(
        &mut self,
        _unary_operator_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let unary_operator_token =
            pop_item!(self, unary_operator_token, UnaryOperatorToken, context);
        let unary_operator_built = UnaryOperatorBuilder::default()
            .unary_operator_token((&unary_operator_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.unary_operator(&unary_operator_built)?;
        self.push(ASTType::UnaryOperator(unary_operator_built), context);
        Ok(())
    }

    /// Semantic action for production 180:
    ///
    /// Colon: ColonToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn colon(
        &mut self,
        _colon_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let colon_token = pop_item!(self, colon_token, ColonToken, context);
        let colon_built = ColonBuilder::default()
            .colon_token((&colon_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.colon(&colon_built)?;
        self.push(ASTType::Colon(colon_built), context);
        Ok(())
    }

    /// Semantic action for production 181:
    ///
    /// ColonColon: ColonColonToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn colon_colon(
        &mut self,
        _colon_colon_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let colon_colon_token = pop_item!(self, colon_colon_token, ColonColonToken, context);
        let colon_colon_built = ColonColonBuilder::default()
            .colon_colon_token((&colon_colon_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.colon_colon(&colon_colon_built)?;
        self.push(ASTType::ColonColon(colon_colon_built), context);
        Ok(())
    }

    /// Semantic action for production 182:
    ///
    /// Comma: CommaToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn comma(
        &mut self,
        _comma_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma_token = pop_item!(self, comma_token, CommaToken, context);
        let comma_built = CommaBuilder::default()
            .comma_token((&comma_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.comma(&comma_built)?;
        self.push(ASTType::Comma(comma_built), context);
        Ok(())
    }

    /// Semantic action for production 183:
    ///
    /// Dollar: DollarToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn dollar(
        &mut self,
        _dollar_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dollar_token = pop_item!(self, dollar_token, DollarToken, context);
        let dollar_built = DollarBuilder::default()
            .dollar_token((&dollar_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.dollar(&dollar_built)?;
        self.push(ASTType::Dollar(dollar_built), context);
        Ok(())
    }

    /// Semantic action for production 184:
    ///
    /// DotDot: DotDotToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn dot_dot(
        &mut self,
        _dot_dot_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dot_dot_token = pop_item!(self, dot_dot_token, DotDotToken, context);
        let dot_dot_built = DotDotBuilder::default()
            .dot_dot_token((&dot_dot_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.dot_dot(&dot_dot_built)?;
        self.push(ASTType::DotDot(dot_dot_built), context);
        Ok(())
    }

    /// Semantic action for production 185:
    ///
    /// Dot: DotToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn dot(
        &mut self,
        _dot_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dot_token = pop_item!(self, dot_token, DotToken, context);
        let dot_built = DotBuilder::default()
            .dot_token((&dot_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.dot(&dot_built)?;
        self.push(ASTType::Dot(dot_built), context);
        Ok(())
    }

    /// Semantic action for production 186:
    ///
    /// Equ: EquToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn equ(
        &mut self,
        _equ_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let equ_token = pop_item!(self, equ_token, EquToken, context);
        let equ_built = EquBuilder::default()
            .equ_token((&equ_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.equ(&equ_built)?;
        self.push(ASTType::Equ(equ_built), context);
        Ok(())
    }

    /// Semantic action for production 187:
    ///
    /// Hash: HashToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn hash(
        &mut self,
        _hash_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let hash_token = pop_item!(self, hash_token, HashToken, context);
        let hash_built = HashBuilder::default()
            .hash_token((&hash_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.hash(&hash_built)?;
        self.push(ASTType::Hash(hash_built), context);
        Ok(())
    }

    /// Semantic action for production 188:
    ///
    /// LBrace: LBraceToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn l_brace(
        &mut self,
        _l_brace_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_brace_token = pop_item!(self, l_brace_token, LBraceToken, context);
        let l_brace_built = LBraceBuilder::default()
            .l_brace_token((&l_brace_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.l_brace(&l_brace_built)?;
        self.push(ASTType::LBrace(l_brace_built), context);
        Ok(())
    }

    /// Semantic action for production 189:
    ///
    /// LBracket: LBracketToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn l_bracket(
        &mut self,
        _l_bracket_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_bracket_token = pop_item!(self, l_bracket_token, LBracketToken, context);
        let l_bracket_built = LBracketBuilder::default()
            .l_bracket_token((&l_bracket_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.l_bracket(&l_bracket_built)?;
        self.push(ASTType::LBracket(l_bracket_built), context);
        Ok(())
    }

    /// Semantic action for production 190:
    ///
    /// LParen: LParenToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn l_paren(
        &mut self,
        _l_paren_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_paren_token = pop_item!(self, l_paren_token, LParenToken, context);
        let l_paren_built = LParenBuilder::default()
            .l_paren_token((&l_paren_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.l_paren(&l_paren_built)?;
        self.push(ASTType::LParen(l_paren_built), context);
        Ok(())
    }

    /// Semantic action for production 191:
    ///
    /// MinusColon: MinusColonToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn minus_colon(
        &mut self,
        _minus_colon_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let minus_colon_token = pop_item!(self, minus_colon_token, MinusColonToken, context);
        let minus_colon_built = MinusColonBuilder::default()
            .minus_colon_token((&minus_colon_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.minus_colon(&minus_colon_built)?;
        self.push(ASTType::MinusColon(minus_colon_built), context);
        Ok(())
    }

    /// Semantic action for production 192:
    ///
    /// MinusGT: MinusGTToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn minus_g_t(
        &mut self,
        _minus_g_t_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let minus_g_t_token = pop_item!(self, minus_g_t_token, MinusGTToken, context);
        let minus_g_t_built = MinusGTBuilder::default()
            .minus_g_t_token((&minus_g_t_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.minus_g_t(&minus_g_t_built)?;
        self.push(ASTType::MinusGT(minus_g_t_built), context);
        Ok(())
    }

    /// Semantic action for production 193:
    ///
    /// PlusColon: PlusColonToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn plus_colon(
        &mut self,
        _plus_colon_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let plus_colon_token = pop_item!(self, plus_colon_token, PlusColonToken, context);
        let plus_colon_built = PlusColonBuilder::default()
            .plus_colon_token((&plus_colon_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.plus_colon(&plus_colon_built)?;
        self.push(ASTType::PlusColon(plus_colon_built), context);
        Ok(())
    }

    /// Semantic action for production 194:
    ///
    /// RBrace: RBraceToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn r_brace(
        &mut self,
        _r_brace_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace_token = pop_item!(self, r_brace_token, RBraceToken, context);
        let r_brace_built = RBraceBuilder::default()
            .r_brace_token((&r_brace_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.r_brace(&r_brace_built)?;
        self.push(ASTType::RBrace(r_brace_built), context);
        Ok(())
    }

    /// Semantic action for production 195:
    ///
    /// RBracket: RBracketToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn r_bracket(
        &mut self,
        _r_bracket_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_bracket_token = pop_item!(self, r_bracket_token, RBracketToken, context);
        let r_bracket_built = RBracketBuilder::default()
            .r_bracket_token((&r_bracket_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.r_bracket(&r_bracket_built)?;
        self.push(ASTType::RBracket(r_bracket_built), context);
        Ok(())
    }

    /// Semantic action for production 196:
    ///
    /// RParen: RParenToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn r_paren(
        &mut self,
        _r_paren_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren_token = pop_item!(self, r_paren_token, RParenToken, context);
        let r_paren_built = RParenBuilder::default()
            .r_paren_token((&r_paren_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.r_paren(&r_paren_built)?;
        self.push(ASTType::RParen(r_paren_built), context);
        Ok(())
    }

    /// Semantic action for production 197:
    ///
    /// Semicolon: SemicolonToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn semicolon(
        &mut self,
        _semicolon_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon_token = pop_item!(self, semicolon_token, SemicolonToken, context);
        let semicolon_built = SemicolonBuilder::default()
            .semicolon_token((&semicolon_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.semicolon(&semicolon_built)?;
        self.push(ASTType::Semicolon(semicolon_built), context);
        Ok(())
    }

    /// Semantic action for production 198:
    ///
    /// AlwaysComb: AlwaysCombToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn always_comb(
        &mut self,
        _always_comb_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let always_comb_token = pop_item!(self, always_comb_token, AlwaysCombToken, context);
        let always_comb_built = AlwaysCombBuilder::default()
            .always_comb_token((&always_comb_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.always_comb(&always_comb_built)?;
        self.push(ASTType::AlwaysComb(always_comb_built), context);
        Ok(())
    }

    /// Semantic action for production 199:
    ///
    /// AlwaysFf: AlwaysFfToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff(
        &mut self,
        _always_ff_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let always_ff_token = pop_item!(self, always_ff_token, AlwaysFfToken, context);
        let always_ff_built = AlwaysFfBuilder::default()
            .always_ff_token((&always_ff_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.always_ff(&always_ff_built)?;
        self.push(ASTType::AlwaysFf(always_ff_built), context);
        Ok(())
    }

    /// Semantic action for production 200:
    ///
    /// Assign: AssignToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn assign(
        &mut self,
        _assign_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let assign_token = pop_item!(self, assign_token, AssignToken, context);
        let assign_built = AssignBuilder::default()
            .assign_token((&assign_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.assign(&assign_built)?;
        self.push(ASTType::Assign(assign_built), context);
        Ok(())
    }

    /// Semantic action for production 201:
    ///
    /// AsyncHigh: AsyncHighToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn async_high(
        &mut self,
        _async_high_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let async_high_token = pop_item!(self, async_high_token, AsyncHighToken, context);
        let async_high_built = AsyncHighBuilder::default()
            .async_high_token((&async_high_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.async_high(&async_high_built)?;
        self.push(ASTType::AsyncHigh(async_high_built), context);
        Ok(())
    }

    /// Semantic action for production 202:
    ///
    /// AsyncLow: AsyncLowToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn async_low(
        &mut self,
        _async_low_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let async_low_token = pop_item!(self, async_low_token, AsyncLowToken, context);
        let async_low_built = AsyncLowBuilder::default()
            .async_low_token((&async_low_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.async_low(&async_low_built)?;
        self.push(ASTType::AsyncLow(async_low_built), context);
        Ok(())
    }

    /// Semantic action for production 203:
    ///
    /// Bit: BitToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn bit(
        &mut self,
        _bit_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bit_token = pop_item!(self, bit_token, BitToken, context);
        let bit_built = BitBuilder::default()
            .bit_token((&bit_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.bit(&bit_built)?;
        self.push(ASTType::Bit(bit_built), context);
        Ok(())
    }

    /// Semantic action for production 204:
    ///
    /// Case: CaseToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn case(
        &mut self,
        _case_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let case_token = pop_item!(self, case_token, CaseToken, context);
        let case_built = CaseBuilder::default()
            .case_token((&case_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.case(&case_built)?;
        self.push(ASTType::Case(case_built), context);
        Ok(())
    }

    /// Semantic action for production 205:
    ///
    /// Defaul: DefaultToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn defaul(
        &mut self,
        _default_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let default_token = pop_item!(self, default_token, DefaultToken, context);
        let defaul_built = DefaulBuilder::default()
            .default_token((&default_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.defaul(&defaul_built)?;
        self.push(ASTType::Defaul(defaul_built), context);
        Ok(())
    }

    /// Semantic action for production 206:
    ///
    /// Else: ElseToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn r#else(
        &mut self,
        _else_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let else_token = pop_item!(self, else_token, ElseToken, context);
        let r#else_built = ElseBuilder::default()
            .else_token((&else_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.r#else(&r#else_built)?;
        self.push(ASTType::Else(r#else_built), context);
        Ok(())
    }

    /// Semantic action for production 207:
    ///
    /// Enum: EnumToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn r#enum(
        &mut self,
        _enum_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let enum_token = pop_item!(self, enum_token, EnumToken, context);
        let r#enum_built = EnumBuilder::default()
            .enum_token((&enum_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.r#enum(&r#enum_built)?;
        self.push(ASTType::Enum(r#enum_built), context);
        Ok(())
    }

    /// Semantic action for production 208:
    ///
    /// F32: F32Token : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn f32(
        &mut self,
        _f32_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let f32_token = pop_item!(self, f32_token, F32Token, context);
        let f32_built = F32Builder::default()
            .f32_token((&f32_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.f32(&f32_built)?;
        self.push(ASTType::F32(f32_built), context);
        Ok(())
    }

    /// Semantic action for production 209:
    ///
    /// F64: F64Token : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn f64(
        &mut self,
        _f64_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let f64_token = pop_item!(self, f64_token, F64Token, context);
        let f64_built = F64Builder::default()
            .f64_token((&f64_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.f64(&f64_built)?;
        self.push(ASTType::F64(f64_built), context);
        Ok(())
    }

    /// Semantic action for production 210:
    ///
    /// For: ForToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn r#for(
        &mut self,
        _for_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let for_token = pop_item!(self, for_token, ForToken, context);
        let r#for_built = ForBuilder::default()
            .for_token((&for_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.r#for(&r#for_built)?;
        self.push(ASTType::For(r#for_built), context);
        Ok(())
    }

    /// Semantic action for production 211:
    ///
    /// Function: FunctionToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn function(
        &mut self,
        _function_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let function_token = pop_item!(self, function_token, FunctionToken, context);
        let function_built = FunctionBuilder::default()
            .function_token((&function_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.function(&function_built)?;
        self.push(ASTType::Function(function_built), context);
        Ok(())
    }

    /// Semantic action for production 212:
    ///
    /// I32: I32Token : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn i32(
        &mut self,
        _i32_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let i32_token = pop_item!(self, i32_token, I32Token, context);
        let i32_built = I32Builder::default()
            .i32_token((&i32_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.i32(&i32_built)?;
        self.push(ASTType::I32(i32_built), context);
        Ok(())
    }

    /// Semantic action for production 213:
    ///
    /// I64: I64Token : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn i64(
        &mut self,
        _i64_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let i64_token = pop_item!(self, i64_token, I64Token, context);
        let i64_built = I64Builder::default()
            .i64_token((&i64_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.i64(&i64_built)?;
        self.push(ASTType::I64(i64_built), context);
        Ok(())
    }

    /// Semantic action for production 214:
    ///
    /// If: IfToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn r#if(
        &mut self,
        _if_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_token = pop_item!(self, if_token, IfToken, context);
        let r#if_built = IfBuilder::default()
            .if_token((&if_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.r#if(&r#if_built)?;
        self.push(ASTType::If(r#if_built), context);
        Ok(())
    }

    /// Semantic action for production 215:
    ///
    /// IfReset: IfResetToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn if_reset(
        &mut self,
        _if_reset_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_reset_token = pop_item!(self, if_reset_token, IfResetToken, context);
        let if_reset_built = IfResetBuilder::default()
            .if_reset_token((&if_reset_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.if_reset(&if_reset_built)?;
        self.push(ASTType::IfReset(if_reset_built), context);
        Ok(())
    }

    /// Semantic action for production 216:
    ///
    /// In: InToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn r#in(
        &mut self,
        _in_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let in_token = pop_item!(self, in_token, InToken, context);
        let r#in_built = InBuilder::default()
            .in_token((&in_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.r#in(&r#in_built)?;
        self.push(ASTType::In(r#in_built), context);
        Ok(())
    }

    /// Semantic action for production 217:
    ///
    /// Inout: InoutToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn inout(
        &mut self,
        _inout_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inout_token = pop_item!(self, inout_token, InoutToken, context);
        let inout_built = InoutBuilder::default()
            .inout_token((&inout_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.inout(&inout_built)?;
        self.push(ASTType::Inout(inout_built), context);
        Ok(())
    }

    /// Semantic action for production 218:
    ///
    /// Input: InputToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn input(
        &mut self,
        _input_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let input_token = pop_item!(self, input_token, InputToken, context);
        let input_built = InputBuilder::default()
            .input_token((&input_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.input(&input_built)?;
        self.push(ASTType::Input(input_built), context);
        Ok(())
    }

    /// Semantic action for production 219:
    ///
    /// Inst: InstToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn inst(
        &mut self,
        _inst_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inst_token = pop_item!(self, inst_token, InstToken, context);
        let inst_built = InstBuilder::default()
            .inst_token((&inst_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.inst(&inst_built)?;
        self.push(ASTType::Inst(inst_built), context);
        Ok(())
    }

    /// Semantic action for production 220:
    ///
    /// Interface: InterfaceToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn interface(
        &mut self,
        _interface_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let interface_token = pop_item!(self, interface_token, InterfaceToken, context);
        let interface_built = InterfaceBuilder::default()
            .interface_token((&interface_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.interface(&interface_built)?;
        self.push(ASTType::Interface(interface_built), context);
        Ok(())
    }

    /// Semantic action for production 221:
    ///
    /// Localparam: LocalparamToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn localparam(
        &mut self,
        _localparam_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let localparam_token = pop_item!(self, localparam_token, LocalparamToken, context);
        let localparam_built = LocalparamBuilder::default()
            .localparam_token((&localparam_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.localparam(&localparam_built)?;
        self.push(ASTType::Localparam(localparam_built), context);
        Ok(())
    }

    /// Semantic action for production 222:
    ///
    /// Logic: LogicToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn logic(
        &mut self,
        _logic_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logic_token = pop_item!(self, logic_token, LogicToken, context);
        let logic_built = LogicBuilder::default()
            .logic_token((&logic_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.logic(&logic_built)?;
        self.push(ASTType::Logic(logic_built), context);
        Ok(())
    }

    /// Semantic action for production 223:
    ///
    /// Modport: ModportToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn modport(
        &mut self,
        _modport_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let modport_token = pop_item!(self, modport_token, ModportToken, context);
        let modport_built = ModportBuilder::default()
            .modport_token((&modport_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.modport(&modport_built)?;
        self.push(ASTType::Modport(modport_built), context);
        Ok(())
    }

    /// Semantic action for production 224:
    ///
    /// Module: ModuleToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn module(
        &mut self,
        _module_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module_token = pop_item!(self, module_token, ModuleToken, context);
        let module_built = ModuleBuilder::default()
            .module_token((&module_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.module(&module_built)?;
        self.push(ASTType::Module(module_built), context);
        Ok(())
    }

    /// Semantic action for production 225:
    ///
    /// Negedge: NegedgeToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn negedge(
        &mut self,
        _negedge_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let negedge_token = pop_item!(self, negedge_token, NegedgeToken, context);
        let negedge_built = NegedgeBuilder::default()
            .negedge_token((&negedge_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.negedge(&negedge_built)?;
        self.push(ASTType::Negedge(negedge_built), context);
        Ok(())
    }

    /// Semantic action for production 226:
    ///
    /// Output: OutputToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn output(
        &mut self,
        _output_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let output_token = pop_item!(self, output_token, OutputToken, context);
        let output_built = OutputBuilder::default()
            .output_token((&output_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.output(&output_built)?;
        self.push(ASTType::Output(output_built), context);
        Ok(())
    }

    /// Semantic action for production 227:
    ///
    /// Package: PackageToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn package(
        &mut self,
        _package_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let package_token = pop_item!(self, package_token, PackageToken, context);
        let package_built = PackageBuilder::default()
            .package_token((&package_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.package(&package_built)?;
        self.push(ASTType::Package(package_built), context);
        Ok(())
    }

    /// Semantic action for production 228:
    ///
    /// Parameter: ParameterToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn parameter(
        &mut self,
        _parameter_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let parameter_token = pop_item!(self, parameter_token, ParameterToken, context);
        let parameter_built = ParameterBuilder::default()
            .parameter_token((&parameter_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.parameter(&parameter_built)?;
        self.push(ASTType::Parameter(parameter_built), context);
        Ok(())
    }

    /// Semantic action for production 229:
    ///
    /// Posedge: PosedgeToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn posedge(
        &mut self,
        _posedge_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let posedge_token = pop_item!(self, posedge_token, PosedgeToken, context);
        let posedge_built = PosedgeBuilder::default()
            .posedge_token((&posedge_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.posedge(&posedge_built)?;
        self.push(ASTType::Posedge(posedge_built), context);
        Ok(())
    }

    /// Semantic action for production 230:
    ///
    /// Ref: RefToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn r#ref(
        &mut self,
        _ref_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let ref_token = pop_item!(self, ref_token, RefToken, context);
        let r#ref_built = RefBuilder::default()
            .ref_token((&ref_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.r#ref(&r#ref_built)?;
        self.push(ASTType::Ref(r#ref_built), context);
        Ok(())
    }

    /// Semantic action for production 231:
    ///
    /// Return: ReturnToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn r#return(
        &mut self,
        _return_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let return_token = pop_item!(self, return_token, ReturnToken, context);
        let r#return_built = ReturnBuilder::default()
            .return_token((&return_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.r#return(&r#return_built)?;
        self.push(ASTType::Return(r#return_built), context);
        Ok(())
    }

    /// Semantic action for production 232:
    ///
    /// Step: StepToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn step(
        &mut self,
        _step_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let step_token = pop_item!(self, step_token, StepToken, context);
        let step_built = StepBuilder::default()
            .step_token((&step_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.step(&step_built)?;
        self.push(ASTType::Step(step_built), context);
        Ok(())
    }

    /// Semantic action for production 233:
    ///
    /// Struct: StructToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn r#struct(
        &mut self,
        _struct_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let struct_token = pop_item!(self, struct_token, StructToken, context);
        let r#struct_built = StructBuilder::default()
            .struct_token((&struct_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.r#struct(&r#struct_built)?;
        self.push(ASTType::Struct(r#struct_built), context);
        Ok(())
    }

    /// Semantic action for production 234:
    ///
    /// SyncHigh: SyncHighToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn sync_high(
        &mut self,
        _sync_high_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let sync_high_token = pop_item!(self, sync_high_token, SyncHighToken, context);
        let sync_high_built = SyncHighBuilder::default()
            .sync_high_token((&sync_high_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.sync_high(&sync_high_built)?;
        self.push(ASTType::SyncHigh(sync_high_built), context);
        Ok(())
    }

    /// Semantic action for production 235:
    ///
    /// SyncLow: SyncLowToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn sync_low(
        &mut self,
        _sync_low_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let sync_low_token = pop_item!(self, sync_low_token, SyncLowToken, context);
        let sync_low_built = SyncLowBuilder::default()
            .sync_low_token((&sync_low_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.sync_low(&sync_low_built)?;
        self.push(ASTType::SyncLow(sync_low_built), context);
        Ok(())
    }

    /// Semantic action for production 236:
    ///
    /// U32: U32Token : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn u32(
        &mut self,
        _u32_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let u32_token = pop_item!(self, u32_token, U32Token, context);
        let u32_built = U32Builder::default()
            .u32_token((&u32_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.u32(&u32_built)?;
        self.push(ASTType::U32(u32_built), context);
        Ok(())
    }

    /// Semantic action for production 237:
    ///
    /// U64: U64Token : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn u64(
        &mut self,
        _u64_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let u64_token = pop_item!(self, u64_token, U64Token, context);
        let u64_built = U64Builder::default()
            .u64_token((&u64_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.u64(&u64_built)?;
        self.push(ASTType::U64(u64_built), context);
        Ok(())
    }

    /// Semantic action for production 238:
    ///
    /// Var: VarToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn var(
        &mut self,
        _var_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let var_token = pop_item!(self, var_token, VarToken, context);
        let var_built = VarBuilder::default()
            .var_token((&var_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.var(&var_built)?;
        self.push(ASTType::Var(var_built), context);
        Ok(())
    }

    /// Semantic action for production 239:
    ///
    /// Identifier: IdentifierToken : VerylToken;
    ///
    #[parol_runtime::function_name::named]
    fn identifier(
        &mut self,
        _identifier_token: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let identifier_token = pop_item!(self, identifier_token, IdentifierToken, context);
        let identifier_built = IdentifierBuilder::default()
            .identifier_token((&identifier_token).try_into().into_diagnostic()?)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.identifier(&identifier_built)?;
        self.push(ASTType::Identifier(identifier_built), context);
        Ok(())
    }

    /// Semantic action for production 240:
    ///
    /// Number: IntegralNumber;
    ///
    #[parol_runtime::function_name::named]
    fn number_0(
        &mut self,
        _integral_number: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let integral_number = pop_item!(self, integral_number, IntegralNumber, context);
        let number_0_built = NumberIntegralNumberBuilder::default()
            .integral_number(Box::new(integral_number))
            .build()
            .into_diagnostic()?;
        let number_0_built = Number::IntegralNumber(number_0_built);
        // Calling user action here
        self.user_grammar.number(&number_0_built)?;
        self.push(ASTType::Number(number_0_built), context);
        Ok(())
    }

    /// Semantic action for production 241:
    ///
    /// Number: RealNumber;
    ///
    #[parol_runtime::function_name::named]
    fn number_1(
        &mut self,
        _real_number: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let real_number = pop_item!(self, real_number, RealNumber, context);
        let number_1_built = NumberRealNumberBuilder::default()
            .real_number(Box::new(real_number))
            .build()
            .into_diagnostic()?;
        let number_1_built = Number::RealNumber(number_1_built);
        // Calling user action here
        self.user_grammar.number(&number_1_built)?;
        self.push(ASTType::Number(number_1_built), context);
        Ok(())
    }

    /// Semantic action for production 242:
    ///
    /// IntegralNumber: Based;
    ///
    #[parol_runtime::function_name::named]
    fn integral_number_0(
        &mut self,
        _based: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let based = pop_item!(self, based, Based, context);
        let integral_number_0_built = IntegralNumberBasedBuilder::default()
            .based(Box::new(based))
            .build()
            .into_diagnostic()?;
        let integral_number_0_built = IntegralNumber::Based(integral_number_0_built);
        // Calling user action here
        self.user_grammar
            .integral_number(&integral_number_0_built)?;
        self.push(ASTType::IntegralNumber(integral_number_0_built), context);
        Ok(())
    }

    /// Semantic action for production 243:
    ///
    /// IntegralNumber: BaseLess;
    ///
    #[parol_runtime::function_name::named]
    fn integral_number_1(
        &mut self,
        _base_less: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let base_less = pop_item!(self, base_less, BaseLess, context);
        let integral_number_1_built = IntegralNumberBaseLessBuilder::default()
            .base_less(Box::new(base_less))
            .build()
            .into_diagnostic()?;
        let integral_number_1_built = IntegralNumber::BaseLess(integral_number_1_built);
        // Calling user action here
        self.user_grammar
            .integral_number(&integral_number_1_built)?;
        self.push(ASTType::IntegralNumber(integral_number_1_built), context);
        Ok(())
    }

    /// Semantic action for production 244:
    ///
    /// IntegralNumber: AllBit;
    ///
    #[parol_runtime::function_name::named]
    fn integral_number_2(
        &mut self,
        _all_bit: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let all_bit = pop_item!(self, all_bit, AllBit, context);
        let integral_number_2_built = IntegralNumberAllBitBuilder::default()
            .all_bit(Box::new(all_bit))
            .build()
            .into_diagnostic()?;
        let integral_number_2_built = IntegralNumber::AllBit(integral_number_2_built);
        // Calling user action here
        self.user_grammar
            .integral_number(&integral_number_2_built)?;
        self.push(ASTType::IntegralNumber(integral_number_2_built), context);
        Ok(())
    }

    /// Semantic action for production 245:
    ///
    /// RealNumber: FixedPoint;
    ///
    #[parol_runtime::function_name::named]
    fn real_number_0(
        &mut self,
        _fixed_point: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let fixed_point = pop_item!(self, fixed_point, FixedPoint, context);
        let real_number_0_built = RealNumberFixedPointBuilder::default()
            .fixed_point(Box::new(fixed_point))
            .build()
            .into_diagnostic()?;
        let real_number_0_built = RealNumber::FixedPoint(real_number_0_built);
        // Calling user action here
        self.user_grammar.real_number(&real_number_0_built)?;
        self.push(ASTType::RealNumber(real_number_0_built), context);
        Ok(())
    }

    /// Semantic action for production 246:
    ///
    /// RealNumber: Exponent;
    ///
    #[parol_runtime::function_name::named]
    fn real_number_1(
        &mut self,
        _exponent: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let exponent = pop_item!(self, exponent, Exponent, context);
        let real_number_1_built = RealNumberExponentBuilder::default()
            .exponent(Box::new(exponent))
            .build()
            .into_diagnostic()?;
        let real_number_1_built = RealNumber::Exponent(real_number_1_built);
        // Calling user action here
        self.user_grammar.real_number(&real_number_1_built)?;
        self.push(ASTType::RealNumber(real_number_1_built), context);
        Ok(())
    }

    /// Semantic action for production 247:
    ///
    /// HierarchicalIdentifier: Identifier HierarchicalIdentifierList /* Vec */ HierarchicalIdentifierList0 /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn hierarchical_identifier(
        &mut self,
        _identifier: &ParseTreeStackEntry<'t>,
        _hierarchical_identifier_list: &ParseTreeStackEntry<'t>,
        _hierarchical_identifier_list0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let hierarchical_identifier_list0 = pop_and_reverse_item!(
            self,
            hierarchical_identifier_list0,
            HierarchicalIdentifierList0,
            context
        );
        let hierarchical_identifier_list = pop_and_reverse_item!(
            self,
            hierarchical_identifier_list,
            HierarchicalIdentifierList,
            context
        );
        let identifier = pop_item!(self, identifier, Identifier, context);
        let hierarchical_identifier_built = HierarchicalIdentifierBuilder::default()
            .identifier(Box::new(identifier))
            .hierarchical_identifier_list(hierarchical_identifier_list)
            .hierarchical_identifier_list0(hierarchical_identifier_list0)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .hierarchical_identifier(&hierarchical_identifier_built)?;
        self.push(
            ASTType::HierarchicalIdentifier(hierarchical_identifier_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 248:
    ///
    /// HierarchicalIdentifierList0 /* Vec<T>::Push */: Dot Identifier HierarchicalIdentifierList0List /* Vec */ HierarchicalIdentifierList0;
    ///
    #[parol_runtime::function_name::named]
    fn hierarchical_identifier_list0_0(
        &mut self,
        _dot: &ParseTreeStackEntry<'t>,
        _identifier: &ParseTreeStackEntry<'t>,
        _hierarchical_identifier_list0_list: &ParseTreeStackEntry<'t>,
        _hierarchical_identifier_list0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut hierarchical_identifier_list0 = pop_item!(
            self,
            hierarchical_identifier_list0,
            HierarchicalIdentifierList0,
            context
        );
        let hierarchical_identifier_list0_list = pop_and_reverse_item!(
            self,
            hierarchical_identifier_list0_list,
            HierarchicalIdentifierList0List,
            context
        );
        let identifier = pop_item!(self, identifier, Identifier, context);
        let dot = pop_item!(self, dot, Dot, context);
        let hierarchical_identifier_list0_0_built = HierarchicalIdentifierList0Builder::default()
            .hierarchical_identifier_list0_list(hierarchical_identifier_list0_list)
            .identifier(Box::new(identifier))
            .dot(Box::new(dot))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        hierarchical_identifier_list0.push(hierarchical_identifier_list0_0_built);
        self.push(
            ASTType::HierarchicalIdentifierList0(hierarchical_identifier_list0),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 249:
    ///
    /// HierarchicalIdentifierList0List /* Vec<T>::Push */: Range HierarchicalIdentifierList0List;
    ///
    #[parol_runtime::function_name::named]
    fn hierarchical_identifier_list0_list_0(
        &mut self,
        _range: &ParseTreeStackEntry<'t>,
        _hierarchical_identifier_list0_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut hierarchical_identifier_list0_list = pop_item!(
            self,
            hierarchical_identifier_list0_list,
            HierarchicalIdentifierList0List,
            context
        );
        let range = pop_item!(self, range, Range, context);
        let hierarchical_identifier_list0_list_0_built =
            HierarchicalIdentifierList0ListBuilder::default()
                .range(Box::new(range))
                .build()
                .into_diagnostic()?;
        // Add an element to the vector
        hierarchical_identifier_list0_list.push(hierarchical_identifier_list0_list_0_built);
        self.push(
            ASTType::HierarchicalIdentifierList0List(hierarchical_identifier_list0_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 250:
    ///
    /// HierarchicalIdentifierList0List /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn hierarchical_identifier_list0_list_1(
        &mut self,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let hierarchical_identifier_list0_list_1_built = Vec::new();
        self.push(
            ASTType::HierarchicalIdentifierList0List(hierarchical_identifier_list0_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 251:
    ///
    /// HierarchicalIdentifierList0 /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn hierarchical_identifier_list0_1(
        &mut self,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let hierarchical_identifier_list0_1_built = Vec::new();
        self.push(
            ASTType::HierarchicalIdentifierList0(hierarchical_identifier_list0_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 252:
    ///
    /// HierarchicalIdentifierList /* Vec<T>::Push */: Range HierarchicalIdentifierList;
    ///
    #[parol_runtime::function_name::named]
    fn hierarchical_identifier_list_0(
        &mut self,
        _range: &ParseTreeStackEntry<'t>,
        _hierarchical_identifier_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut hierarchical_identifier_list = pop_item!(
            self,
            hierarchical_identifier_list,
            HierarchicalIdentifierList,
            context
        );
        let range = pop_item!(self, range, Range, context);
        let hierarchical_identifier_list_0_built = HierarchicalIdentifierListBuilder::default()
            .range(Box::new(range))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        hierarchical_identifier_list.push(hierarchical_identifier_list_0_built);
        self.push(
            ASTType::HierarchicalIdentifierList(hierarchical_identifier_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 253:
    ///
    /// HierarchicalIdentifierList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn hierarchical_identifier_list_1(
        &mut self,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let hierarchical_identifier_list_1_built = Vec::new();
        self.push(
            ASTType::HierarchicalIdentifierList(hierarchical_identifier_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 254:
    ///
    /// ScopedIdentifier: Identifier ScopedIdentifierList /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn scoped_identifier(
        &mut self,
        _identifier: &ParseTreeStackEntry<'t>,
        _scoped_identifier_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scoped_identifier_list =
            pop_and_reverse_item!(self, scoped_identifier_list, ScopedIdentifierList, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let scoped_identifier_built = ScopedIdentifierBuilder::default()
            .identifier(Box::new(identifier))
            .scoped_identifier_list(scoped_identifier_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .scoped_identifier(&scoped_identifier_built)?;
        self.push(ASTType::ScopedIdentifier(scoped_identifier_built), context);
        Ok(())
    }

    /// Semantic action for production 255:
    ///
    /// ScopedIdentifierList /* Vec<T>::Push */: ColonColon Identifier ScopedIdentifierList;
    ///
    #[parol_runtime::function_name::named]
    fn scoped_identifier_list_0(
        &mut self,
        _colon_colon: &ParseTreeStackEntry<'t>,
        _identifier: &ParseTreeStackEntry<'t>,
        _scoped_identifier_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut scoped_identifier_list =
            pop_item!(self, scoped_identifier_list, ScopedIdentifierList, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let colon_colon = pop_item!(self, colon_colon, ColonColon, context);
        let scoped_identifier_list_0_built = ScopedIdentifierListBuilder::default()
            .identifier(Box::new(identifier))
            .colon_colon(Box::new(colon_colon))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        scoped_identifier_list.push(scoped_identifier_list_0_built);
        self.push(
            ASTType::ScopedIdentifierList(scoped_identifier_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 256:
    ///
    /// ScopedIdentifierList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn scoped_identifier_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scoped_identifier_list_1_built = Vec::new();
        self.push(
            ASTType::ScopedIdentifierList(scoped_identifier_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 257:
    ///
    /// ScopedOrHierIdentifier: Identifier ScopedOrHierIdentifierGroup;
    ///
    #[parol_runtime::function_name::named]
    fn scoped_or_hier_identifier(
        &mut self,
        _identifier: &ParseTreeStackEntry<'t>,
        _scoped_or_hier_identifier_group: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scoped_or_hier_identifier_group = pop_item!(
            self,
            scoped_or_hier_identifier_group,
            ScopedOrHierIdentifierGroup,
            context
        );
        let identifier = pop_item!(self, identifier, Identifier, context);
        let scoped_or_hier_identifier_built = ScopedOrHierIdentifierBuilder::default()
            .identifier(Box::new(identifier))
            .scoped_or_hier_identifier_group(Box::new(scoped_or_hier_identifier_group))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .scoped_or_hier_identifier(&scoped_or_hier_identifier_built)?;
        self.push(
            ASTType::ScopedOrHierIdentifier(scoped_or_hier_identifier_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 258:
    ///
    /// ScopedOrHierIdentifierGroup: ColonColon Identifier ScopedOrHierIdentifierGroupList /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn scoped_or_hier_identifier_group_0(
        &mut self,
        _colon_colon: &ParseTreeStackEntry<'t>,
        _identifier: &ParseTreeStackEntry<'t>,
        _scoped_or_hier_identifier_group_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scoped_or_hier_identifier_group_list = pop_and_reverse_item!(
            self,
            scoped_or_hier_identifier_group_list,
            ScopedOrHierIdentifierGroupList,
            context
        );
        let identifier = pop_item!(self, identifier, Identifier, context);
        let colon_colon = pop_item!(self, colon_colon, ColonColon, context);
        let scoped_or_hier_identifier_group_0_built = ScopedOrHierIdentifierGroupColonColonIdentifierScopedOrHierIdentifierGroupListBuilder::default()
            .colon_colon(Box::new(colon_colon))
            .identifier(Box::new(identifier))
            .scoped_or_hier_identifier_group_list(scoped_or_hier_identifier_group_list)
            .build()
            .into_diagnostic()?;
        let scoped_or_hier_identifier_group_0_built =
            ScopedOrHierIdentifierGroup::ColonColonIdentifierScopedOrHierIdentifierGroupList(
                scoped_or_hier_identifier_group_0_built,
            );
        self.push(
            ASTType::ScopedOrHierIdentifierGroup(scoped_or_hier_identifier_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 259:
    ///
    /// ScopedOrHierIdentifierGroupList /* Vec<T>::Push */: ColonColon Identifier ScopedOrHierIdentifierGroupList;
    ///
    #[parol_runtime::function_name::named]
    fn scoped_or_hier_identifier_group_list_0(
        &mut self,
        _colon_colon: &ParseTreeStackEntry<'t>,
        _identifier: &ParseTreeStackEntry<'t>,
        _scoped_or_hier_identifier_group_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut scoped_or_hier_identifier_group_list = pop_item!(
            self,
            scoped_or_hier_identifier_group_list,
            ScopedOrHierIdentifierGroupList,
            context
        );
        let identifier = pop_item!(self, identifier, Identifier, context);
        let colon_colon = pop_item!(self, colon_colon, ColonColon, context);
        let scoped_or_hier_identifier_group_list_0_built =
            ScopedOrHierIdentifierGroupListBuilder::default()
                .identifier(Box::new(identifier))
                .colon_colon(Box::new(colon_colon))
                .build()
                .into_diagnostic()?;
        // Add an element to the vector
        scoped_or_hier_identifier_group_list.push(scoped_or_hier_identifier_group_list_0_built);
        self.push(
            ASTType::ScopedOrHierIdentifierGroupList(scoped_or_hier_identifier_group_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 260:
    ///
    /// ScopedOrHierIdentifierGroupList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn scoped_or_hier_identifier_group_list_1(
        &mut self,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scoped_or_hier_identifier_group_list_1_built = Vec::new();
        self.push(
            ASTType::ScopedOrHierIdentifierGroupList(scoped_or_hier_identifier_group_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 261:
    ///
    /// ScopedOrHierIdentifierGroup: ScopedOrHierIdentifierGroupList0 /* Vec */ ScopedOrHierIdentifierGroupList1 /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn scoped_or_hier_identifier_group_1(
        &mut self,
        _scoped_or_hier_identifier_group_list0: &ParseTreeStackEntry<'t>,
        _scoped_or_hier_identifier_group_list1: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scoped_or_hier_identifier_group_list1 = pop_and_reverse_item!(
            self,
            scoped_or_hier_identifier_group_list1,
            ScopedOrHierIdentifierGroupList1,
            context
        );
        let scoped_or_hier_identifier_group_list0 = pop_and_reverse_item!(
            self,
            scoped_or_hier_identifier_group_list0,
            ScopedOrHierIdentifierGroupList0,
            context
        );
        let scoped_or_hier_identifier_group_1_built = ScopedOrHierIdentifierGroupScopedOrHierIdentifierGroupList0ScopedOrHierIdentifierGroupList1Builder::default()
            .scoped_or_hier_identifier_group_list0(scoped_or_hier_identifier_group_list0)
            .scoped_or_hier_identifier_group_list1(scoped_or_hier_identifier_group_list1)
            .build()
            .into_diagnostic()?;
        let scoped_or_hier_identifier_group_1_built = ScopedOrHierIdentifierGroup::ScopedOrHierIdentifierGroupList0ScopedOrHierIdentifierGroupList1(scoped_or_hier_identifier_group_1_built);
        self.push(
            ASTType::ScopedOrHierIdentifierGroup(scoped_or_hier_identifier_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 262:
    ///
    /// ScopedOrHierIdentifierGroupList1 /* Vec<T>::Push */: Dot Identifier ScopedOrHierIdentifierGroupList1List /* Vec */ ScopedOrHierIdentifierGroupList1;
    ///
    #[parol_runtime::function_name::named]
    fn scoped_or_hier_identifier_group_list1_0(
        &mut self,
        _dot: &ParseTreeStackEntry<'t>,
        _identifier: &ParseTreeStackEntry<'t>,
        _scoped_or_hier_identifier_group_list1_list: &ParseTreeStackEntry<'t>,
        _scoped_or_hier_identifier_group_list1: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut scoped_or_hier_identifier_group_list1 = pop_item!(
            self,
            scoped_or_hier_identifier_group_list1,
            ScopedOrHierIdentifierGroupList1,
            context
        );
        let scoped_or_hier_identifier_group_list1_list = pop_and_reverse_item!(
            self,
            scoped_or_hier_identifier_group_list1_list,
            ScopedOrHierIdentifierGroupList1List,
            context
        );
        let identifier = pop_item!(self, identifier, Identifier, context);
        let dot = pop_item!(self, dot, Dot, context);
        let scoped_or_hier_identifier_group_list1_0_built =
            ScopedOrHierIdentifierGroupList1Builder::default()
                .scoped_or_hier_identifier_group_list1_list(
                    scoped_or_hier_identifier_group_list1_list,
                )
                .identifier(Box::new(identifier))
                .dot(Box::new(dot))
                .build()
                .into_diagnostic()?;
        // Add an element to the vector
        scoped_or_hier_identifier_group_list1.push(scoped_or_hier_identifier_group_list1_0_built);
        self.push(
            ASTType::ScopedOrHierIdentifierGroupList1(scoped_or_hier_identifier_group_list1),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 263:
    ///
    /// ScopedOrHierIdentifierGroupList1List /* Vec<T>::Push */: Range ScopedOrHierIdentifierGroupList1List;
    ///
    #[parol_runtime::function_name::named]
    fn scoped_or_hier_identifier_group_list1_list_0(
        &mut self,
        _range: &ParseTreeStackEntry<'t>,
        _scoped_or_hier_identifier_group_list1_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut scoped_or_hier_identifier_group_list1_list = pop_item!(
            self,
            scoped_or_hier_identifier_group_list1_list,
            ScopedOrHierIdentifierGroupList1List,
            context
        );
        let range = pop_item!(self, range, Range, context);
        let scoped_or_hier_identifier_group_list1_list_0_built =
            ScopedOrHierIdentifierGroupList1ListBuilder::default()
                .range(Box::new(range))
                .build()
                .into_diagnostic()?;
        // Add an element to the vector
        scoped_or_hier_identifier_group_list1_list
            .push(scoped_or_hier_identifier_group_list1_list_0_built);
        self.push(
            ASTType::ScopedOrHierIdentifierGroupList1List(
                scoped_or_hier_identifier_group_list1_list,
            ),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 264:
    ///
    /// ScopedOrHierIdentifierGroupList1List /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn scoped_or_hier_identifier_group_list1_list_1(
        &mut self,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scoped_or_hier_identifier_group_list1_list_1_built = Vec::new();
        self.push(
            ASTType::ScopedOrHierIdentifierGroupList1List(
                scoped_or_hier_identifier_group_list1_list_1_built,
            ),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 265:
    ///
    /// ScopedOrHierIdentifierGroupList1 /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn scoped_or_hier_identifier_group_list1_1(
        &mut self,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scoped_or_hier_identifier_group_list1_1_built = Vec::new();
        self.push(
            ASTType::ScopedOrHierIdentifierGroupList1(
                scoped_or_hier_identifier_group_list1_1_built,
            ),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 266:
    ///
    /// ScopedOrHierIdentifierGroupList0 /* Vec<T>::Push */: Range ScopedOrHierIdentifierGroupList0;
    ///
    #[parol_runtime::function_name::named]
    fn scoped_or_hier_identifier_group_list0_0(
        &mut self,
        _range: &ParseTreeStackEntry<'t>,
        _scoped_or_hier_identifier_group_list0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut scoped_or_hier_identifier_group_list0 = pop_item!(
            self,
            scoped_or_hier_identifier_group_list0,
            ScopedOrHierIdentifierGroupList0,
            context
        );
        let range = pop_item!(self, range, Range, context);
        let scoped_or_hier_identifier_group_list0_0_built =
            ScopedOrHierIdentifierGroupList0Builder::default()
                .range(Box::new(range))
                .build()
                .into_diagnostic()?;
        // Add an element to the vector
        scoped_or_hier_identifier_group_list0.push(scoped_or_hier_identifier_group_list0_0_built);
        self.push(
            ASTType::ScopedOrHierIdentifierGroupList0(scoped_or_hier_identifier_group_list0),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 267:
    ///
    /// ScopedOrHierIdentifierGroupList0 /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn scoped_or_hier_identifier_group_list0_1(
        &mut self,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scoped_or_hier_identifier_group_list0_1_built = Vec::new();
        self.push(
            ASTType::ScopedOrHierIdentifierGroupList0(
                scoped_or_hier_identifier_group_list0_1_built,
            ),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 268:
    ///
    /// Expression: Expression01 ExpressionList /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn expression(
        &mut self,
        _expression01: &ParseTreeStackEntry<'t>,
        _expression_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression_list = pop_and_reverse_item!(self, expression_list, ExpressionList, context);
        let expression01 = pop_item!(self, expression01, Expression01, context);
        let expression_built = ExpressionBuilder::default()
            .expression01(Box::new(expression01))
            .expression_list(expression_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.expression(&expression_built)?;
        self.push(ASTType::Expression(expression_built), context);
        Ok(())
    }

    /// Semantic action for production 269:
    ///
    /// ExpressionList /* Vec<T>::Push */: Operator01 Expression01 ExpressionList;
    ///
    #[parol_runtime::function_name::named]
    fn expression_list_0(
        &mut self,
        _operator01: &ParseTreeStackEntry<'t>,
        _expression01: &ParseTreeStackEntry<'t>,
        _expression_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression_list = pop_item!(self, expression_list, ExpressionList, context);
        let expression01 = pop_item!(self, expression01, Expression01, context);
        let operator01 = pop_item!(self, operator01, Operator01, context);
        let expression_list_0_built = ExpressionListBuilder::default()
            .expression01(Box::new(expression01))
            .operator01(Box::new(operator01))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        expression_list.push(expression_list_0_built);
        self.push(ASTType::ExpressionList(expression_list), context);
        Ok(())
    }

    /// Semantic action for production 270:
    ///
    /// ExpressionList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn expression_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression_list_1_built = Vec::new();
        self.push(ASTType::ExpressionList(expression_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 271:
    ///
    /// Expression01: Expression02 Expression01List /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn expression01(
        &mut self,
        _expression02: &ParseTreeStackEntry<'t>,
        _expression01_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression01_list =
            pop_and_reverse_item!(self, expression01_list, Expression01List, context);
        let expression02 = pop_item!(self, expression02, Expression02, context);
        let expression01_built = Expression01Builder::default()
            .expression02(Box::new(expression02))
            .expression01_list(expression01_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.expression01(&expression01_built)?;
        self.push(ASTType::Expression01(expression01_built), context);
        Ok(())
    }

    /// Semantic action for production 272:
    ///
    /// Expression01List /* Vec<T>::Push */: Operator02 Expression02 Expression01List;
    ///
    #[parol_runtime::function_name::named]
    fn expression01_list_0(
        &mut self,
        _operator02: &ParseTreeStackEntry<'t>,
        _expression02: &ParseTreeStackEntry<'t>,
        _expression01_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression01_list = pop_item!(self, expression01_list, Expression01List, context);
        let expression02 = pop_item!(self, expression02, Expression02, context);
        let operator02 = pop_item!(self, operator02, Operator02, context);
        let expression01_list_0_built = Expression01ListBuilder::default()
            .expression02(Box::new(expression02))
            .operator02(Box::new(operator02))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        expression01_list.push(expression01_list_0_built);
        self.push(ASTType::Expression01List(expression01_list), context);
        Ok(())
    }

    /// Semantic action for production 273:
    ///
    /// Expression01List /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn expression01_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression01_list_1_built = Vec::new();
        self.push(
            ASTType::Expression01List(expression01_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 274:
    ///
    /// Expression02: Expression03 Expression02List /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn expression02(
        &mut self,
        _expression03: &ParseTreeStackEntry<'t>,
        _expression02_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression02_list =
            pop_and_reverse_item!(self, expression02_list, Expression02List, context);
        let expression03 = pop_item!(self, expression03, Expression03, context);
        let expression02_built = Expression02Builder::default()
            .expression03(Box::new(expression03))
            .expression02_list(expression02_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.expression02(&expression02_built)?;
        self.push(ASTType::Expression02(expression02_built), context);
        Ok(())
    }

    /// Semantic action for production 275:
    ///
    /// Expression02List /* Vec<T>::Push */: Operator03 Expression03 Expression02List;
    ///
    #[parol_runtime::function_name::named]
    fn expression02_list_0(
        &mut self,
        _operator03: &ParseTreeStackEntry<'t>,
        _expression03: &ParseTreeStackEntry<'t>,
        _expression02_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression02_list = pop_item!(self, expression02_list, Expression02List, context);
        let expression03 = pop_item!(self, expression03, Expression03, context);
        let operator03 = pop_item!(self, operator03, Operator03, context);
        let expression02_list_0_built = Expression02ListBuilder::default()
            .expression03(Box::new(expression03))
            .operator03(Box::new(operator03))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        expression02_list.push(expression02_list_0_built);
        self.push(ASTType::Expression02List(expression02_list), context);
        Ok(())
    }

    /// Semantic action for production 276:
    ///
    /// Expression02List /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn expression02_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression02_list_1_built = Vec::new();
        self.push(
            ASTType::Expression02List(expression02_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 277:
    ///
    /// Expression03: Expression04 Expression03List /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn expression03(
        &mut self,
        _expression04: &ParseTreeStackEntry<'t>,
        _expression03_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression03_list =
            pop_and_reverse_item!(self, expression03_list, Expression03List, context);
        let expression04 = pop_item!(self, expression04, Expression04, context);
        let expression03_built = Expression03Builder::default()
            .expression04(Box::new(expression04))
            .expression03_list(expression03_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.expression03(&expression03_built)?;
        self.push(ASTType::Expression03(expression03_built), context);
        Ok(())
    }

    /// Semantic action for production 278:
    ///
    /// Expression03List /* Vec<T>::Push */: Operator04 Expression04 Expression03List;
    ///
    #[parol_runtime::function_name::named]
    fn expression03_list_0(
        &mut self,
        _operator04: &ParseTreeStackEntry<'t>,
        _expression04: &ParseTreeStackEntry<'t>,
        _expression03_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression03_list = pop_item!(self, expression03_list, Expression03List, context);
        let expression04 = pop_item!(self, expression04, Expression04, context);
        let operator04 = pop_item!(self, operator04, Operator04, context);
        let expression03_list_0_built = Expression03ListBuilder::default()
            .expression04(Box::new(expression04))
            .operator04(Box::new(operator04))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        expression03_list.push(expression03_list_0_built);
        self.push(ASTType::Expression03List(expression03_list), context);
        Ok(())
    }

    /// Semantic action for production 279:
    ///
    /// Expression03List /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn expression03_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression03_list_1_built = Vec::new();
        self.push(
            ASTType::Expression03List(expression03_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 280:
    ///
    /// Expression04: Expression05 Expression04List /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn expression04(
        &mut self,
        _expression05: &ParseTreeStackEntry<'t>,
        _expression04_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression04_list =
            pop_and_reverse_item!(self, expression04_list, Expression04List, context);
        let expression05 = pop_item!(self, expression05, Expression05, context);
        let expression04_built = Expression04Builder::default()
            .expression05(Box::new(expression05))
            .expression04_list(expression04_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.expression04(&expression04_built)?;
        self.push(ASTType::Expression04(expression04_built), context);
        Ok(())
    }

    /// Semantic action for production 281:
    ///
    /// Expression04List /* Vec<T>::Push */: Operator05 Expression05 Expression04List;
    ///
    #[parol_runtime::function_name::named]
    fn expression04_list_0(
        &mut self,
        _operator05: &ParseTreeStackEntry<'t>,
        _expression05: &ParseTreeStackEntry<'t>,
        _expression04_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression04_list = pop_item!(self, expression04_list, Expression04List, context);
        let expression05 = pop_item!(self, expression05, Expression05, context);
        let operator05 = pop_item!(self, operator05, Operator05, context);
        let expression04_list_0_built = Expression04ListBuilder::default()
            .expression05(Box::new(expression05))
            .operator05(Box::new(operator05))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        expression04_list.push(expression04_list_0_built);
        self.push(ASTType::Expression04List(expression04_list), context);
        Ok(())
    }

    /// Semantic action for production 282:
    ///
    /// Expression04List /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn expression04_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression04_list_1_built = Vec::new();
        self.push(
            ASTType::Expression04List(expression04_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 283:
    ///
    /// Expression05: Expression06 Expression05List /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn expression05(
        &mut self,
        _expression06: &ParseTreeStackEntry<'t>,
        _expression05_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression05_list =
            pop_and_reverse_item!(self, expression05_list, Expression05List, context);
        let expression06 = pop_item!(self, expression06, Expression06, context);
        let expression05_built = Expression05Builder::default()
            .expression06(Box::new(expression06))
            .expression05_list(expression05_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.expression05(&expression05_built)?;
        self.push(ASTType::Expression05(expression05_built), context);
        Ok(())
    }

    /// Semantic action for production 284:
    ///
    /// Expression05List /* Vec<T>::Push */: Operator06 Expression06 Expression05List;
    ///
    #[parol_runtime::function_name::named]
    fn expression05_list_0(
        &mut self,
        _operator06: &ParseTreeStackEntry<'t>,
        _expression06: &ParseTreeStackEntry<'t>,
        _expression05_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression05_list = pop_item!(self, expression05_list, Expression05List, context);
        let expression06 = pop_item!(self, expression06, Expression06, context);
        let operator06 = pop_item!(self, operator06, Operator06, context);
        let expression05_list_0_built = Expression05ListBuilder::default()
            .expression06(Box::new(expression06))
            .operator06(Box::new(operator06))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        expression05_list.push(expression05_list_0_built);
        self.push(ASTType::Expression05List(expression05_list), context);
        Ok(())
    }

    /// Semantic action for production 285:
    ///
    /// Expression05List /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn expression05_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression05_list_1_built = Vec::new();
        self.push(
            ASTType::Expression05List(expression05_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 286:
    ///
    /// Expression06: Expression07 Expression06List /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn expression06(
        &mut self,
        _expression07: &ParseTreeStackEntry<'t>,
        _expression06_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression06_list =
            pop_and_reverse_item!(self, expression06_list, Expression06List, context);
        let expression07 = pop_item!(self, expression07, Expression07, context);
        let expression06_built = Expression06Builder::default()
            .expression07(Box::new(expression07))
            .expression06_list(expression06_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.expression06(&expression06_built)?;
        self.push(ASTType::Expression06(expression06_built), context);
        Ok(())
    }

    /// Semantic action for production 287:
    ///
    /// Expression06List /* Vec<T>::Push */: Operator07 Expression07 Expression06List;
    ///
    #[parol_runtime::function_name::named]
    fn expression06_list_0(
        &mut self,
        _operator07: &ParseTreeStackEntry<'t>,
        _expression07: &ParseTreeStackEntry<'t>,
        _expression06_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression06_list = pop_item!(self, expression06_list, Expression06List, context);
        let expression07 = pop_item!(self, expression07, Expression07, context);
        let operator07 = pop_item!(self, operator07, Operator07, context);
        let expression06_list_0_built = Expression06ListBuilder::default()
            .expression07(Box::new(expression07))
            .operator07(Box::new(operator07))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        expression06_list.push(expression06_list_0_built);
        self.push(ASTType::Expression06List(expression06_list), context);
        Ok(())
    }

    /// Semantic action for production 288:
    ///
    /// Expression06List /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn expression06_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression06_list_1_built = Vec::new();
        self.push(
            ASTType::Expression06List(expression06_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 289:
    ///
    /// Expression07: Expression08 Expression07List /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn expression07(
        &mut self,
        _expression08: &ParseTreeStackEntry<'t>,
        _expression07_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression07_list =
            pop_and_reverse_item!(self, expression07_list, Expression07List, context);
        let expression08 = pop_item!(self, expression08, Expression08, context);
        let expression07_built = Expression07Builder::default()
            .expression08(Box::new(expression08))
            .expression07_list(expression07_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.expression07(&expression07_built)?;
        self.push(ASTType::Expression07(expression07_built), context);
        Ok(())
    }

    /// Semantic action for production 290:
    ///
    /// Expression07List /* Vec<T>::Push */: Operator08 Expression08 Expression07List;
    ///
    #[parol_runtime::function_name::named]
    fn expression07_list_0(
        &mut self,
        _operator08: &ParseTreeStackEntry<'t>,
        _expression08: &ParseTreeStackEntry<'t>,
        _expression07_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression07_list = pop_item!(self, expression07_list, Expression07List, context);
        let expression08 = pop_item!(self, expression08, Expression08, context);
        let operator08 = pop_item!(self, operator08, Operator08, context);
        let expression07_list_0_built = Expression07ListBuilder::default()
            .expression08(Box::new(expression08))
            .operator08(Box::new(operator08))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        expression07_list.push(expression07_list_0_built);
        self.push(ASTType::Expression07List(expression07_list), context);
        Ok(())
    }

    /// Semantic action for production 291:
    ///
    /// Expression07List /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn expression07_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression07_list_1_built = Vec::new();
        self.push(
            ASTType::Expression07List(expression07_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 292:
    ///
    /// Expression08: Expression09 Expression08List /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn expression08(
        &mut self,
        _expression09: &ParseTreeStackEntry<'t>,
        _expression08_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression08_list =
            pop_and_reverse_item!(self, expression08_list, Expression08List, context);
        let expression09 = pop_item!(self, expression09, Expression09, context);
        let expression08_built = Expression08Builder::default()
            .expression09(Box::new(expression09))
            .expression08_list(expression08_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.expression08(&expression08_built)?;
        self.push(ASTType::Expression08(expression08_built), context);
        Ok(())
    }

    /// Semantic action for production 293:
    ///
    /// Expression08List /* Vec<T>::Push */: Operator09 Expression09 Expression08List;
    ///
    #[parol_runtime::function_name::named]
    fn expression08_list_0(
        &mut self,
        _operator09: &ParseTreeStackEntry<'t>,
        _expression09: &ParseTreeStackEntry<'t>,
        _expression08_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression08_list = pop_item!(self, expression08_list, Expression08List, context);
        let expression09 = pop_item!(self, expression09, Expression09, context);
        let operator09 = pop_item!(self, operator09, Operator09, context);
        let expression08_list_0_built = Expression08ListBuilder::default()
            .expression09(Box::new(expression09))
            .operator09(Box::new(operator09))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        expression08_list.push(expression08_list_0_built);
        self.push(ASTType::Expression08List(expression08_list), context);
        Ok(())
    }

    /// Semantic action for production 294:
    ///
    /// Expression08List /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn expression08_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression08_list_1_built = Vec::new();
        self.push(
            ASTType::Expression08List(expression08_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 295:
    ///
    /// Expression09: Expression10 Expression09List /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn expression09(
        &mut self,
        _expression10: &ParseTreeStackEntry<'t>,
        _expression09_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression09_list =
            pop_and_reverse_item!(self, expression09_list, Expression09List, context);
        let expression10 = pop_item!(self, expression10, Expression10, context);
        let expression09_built = Expression09Builder::default()
            .expression10(Box::new(expression10))
            .expression09_list(expression09_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.expression09(&expression09_built)?;
        self.push(ASTType::Expression09(expression09_built), context);
        Ok(())
    }

    /// Semantic action for production 296:
    ///
    /// Expression09List /* Vec<T>::Push */: Operator10 Expression10 Expression09List;
    ///
    #[parol_runtime::function_name::named]
    fn expression09_list_0(
        &mut self,
        _operator10: &ParseTreeStackEntry<'t>,
        _expression10: &ParseTreeStackEntry<'t>,
        _expression09_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression09_list = pop_item!(self, expression09_list, Expression09List, context);
        let expression10 = pop_item!(self, expression10, Expression10, context);
        let operator10 = pop_item!(self, operator10, Operator10, context);
        let expression09_list_0_built = Expression09ListBuilder::default()
            .expression10(Box::new(expression10))
            .operator10(Box::new(operator10))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        expression09_list.push(expression09_list_0_built);
        self.push(ASTType::Expression09List(expression09_list), context);
        Ok(())
    }

    /// Semantic action for production 297:
    ///
    /// Expression09List /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn expression09_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression09_list_1_built = Vec::new();
        self.push(
            ASTType::Expression09List(expression09_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 298:
    ///
    /// Expression10: Expression11 Expression10List /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn expression10(
        &mut self,
        _expression11: &ParseTreeStackEntry<'t>,
        _expression10_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression10_list =
            pop_and_reverse_item!(self, expression10_list, Expression10List, context);
        let expression11 = pop_item!(self, expression11, Expression11, context);
        let expression10_built = Expression10Builder::default()
            .expression11(Box::new(expression11))
            .expression10_list(expression10_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.expression10(&expression10_built)?;
        self.push(ASTType::Expression10(expression10_built), context);
        Ok(())
    }

    /// Semantic action for production 299:
    ///
    /// Expression10List /* Vec<T>::Push */: Operator11 Expression11 Expression10List;
    ///
    #[parol_runtime::function_name::named]
    fn expression10_list_0(
        &mut self,
        _operator11: &ParseTreeStackEntry<'t>,
        _expression11: &ParseTreeStackEntry<'t>,
        _expression10_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression10_list = pop_item!(self, expression10_list, Expression10List, context);
        let expression11 = pop_item!(self, expression11, Expression11, context);
        let operator11 = pop_item!(self, operator11, Operator11, context);
        let expression10_list_0_built = Expression10ListBuilder::default()
            .expression11(Box::new(expression11))
            .operator11(Box::new(operator11))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        expression10_list.push(expression10_list_0_built);
        self.push(ASTType::Expression10List(expression10_list), context);
        Ok(())
    }

    /// Semantic action for production 300:
    ///
    /// Expression10List /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn expression10_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression10_list_1_built = Vec::new();
        self.push(
            ASTType::Expression10List(expression10_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 301:
    ///
    /// Expression11: Expression11List /* Vec */ Factor;
    ///
    #[parol_runtime::function_name::named]
    fn expression11(
        &mut self,
        _expression11_list: &ParseTreeStackEntry<'t>,
        _factor: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let factor = pop_item!(self, factor, Factor, context);
        let expression11_list =
            pop_and_reverse_item!(self, expression11_list, Expression11List, context);
        let expression11_built = Expression11Builder::default()
            .expression11_list(expression11_list)
            .factor(Box::new(factor))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.expression11(&expression11_built)?;
        self.push(ASTType::Expression11(expression11_built), context);
        Ok(())
    }

    /// Semantic action for production 302:
    ///
    /// Expression11List /* Vec<T>::Push */: Expression11ListGroup Expression11List;
    ///
    #[parol_runtime::function_name::named]
    fn expression11_list_0(
        &mut self,
        _expression11_list_group: &ParseTreeStackEntry<'t>,
        _expression11_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression11_list = pop_item!(self, expression11_list, Expression11List, context);
        let expression11_list_group = pop_item!(
            self,
            expression11_list_group,
            Expression11ListGroup,
            context
        );
        let expression11_list_0_built = Expression11ListBuilder::default()
            .expression11_list_group(Box::new(expression11_list_group))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        expression11_list.push(expression11_list_0_built);
        self.push(ASTType::Expression11List(expression11_list), context);
        Ok(())
    }

    /// Semantic action for production 303:
    ///
    /// Expression11ListGroup: UnaryOperator;
    ///
    #[parol_runtime::function_name::named]
    fn expression11_list_group_0(
        &mut self,
        _unary_operator: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let unary_operator = pop_item!(self, unary_operator, UnaryOperator, context);
        let expression11_list_group_0_built = Expression11ListGroupUnaryOperatorBuilder::default()
            .unary_operator(Box::new(unary_operator))
            .build()
            .into_diagnostic()?;
        let expression11_list_group_0_built =
            Expression11ListGroup::UnaryOperator(expression11_list_group_0_built);
        self.push(
            ASTType::Expression11ListGroup(expression11_list_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 304:
    ///
    /// Expression11ListGroup: Operator09;
    ///
    #[parol_runtime::function_name::named]
    fn expression11_list_group_1(
        &mut self,
        _operator09: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator09 = pop_item!(self, operator09, Operator09, context);
        let expression11_list_group_1_built = Expression11ListGroupOperator09Builder::default()
            .operator09(Box::new(operator09))
            .build()
            .into_diagnostic()?;
        let expression11_list_group_1_built =
            Expression11ListGroup::Operator09(expression11_list_group_1_built);
        self.push(
            ASTType::Expression11ListGroup(expression11_list_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 305:
    ///
    /// Expression11ListGroup: Operator05;
    ///
    #[parol_runtime::function_name::named]
    fn expression11_list_group_2(
        &mut self,
        _operator05: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator05 = pop_item!(self, operator05, Operator05, context);
        let expression11_list_group_2_built = Expression11ListGroupOperator05Builder::default()
            .operator05(Box::new(operator05))
            .build()
            .into_diagnostic()?;
        let expression11_list_group_2_built =
            Expression11ListGroup::Operator05(expression11_list_group_2_built);
        self.push(
            ASTType::Expression11ListGroup(expression11_list_group_2_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 306:
    ///
    /// Expression11ListGroup: Operator03;
    ///
    #[parol_runtime::function_name::named]
    fn expression11_list_group_3(
        &mut self,
        _operator03: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator03 = pop_item!(self, operator03, Operator03, context);
        let expression11_list_group_3_built = Expression11ListGroupOperator03Builder::default()
            .operator03(Box::new(operator03))
            .build()
            .into_diagnostic()?;
        let expression11_list_group_3_built =
            Expression11ListGroup::Operator03(expression11_list_group_3_built);
        self.push(
            ASTType::Expression11ListGroup(expression11_list_group_3_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 307:
    ///
    /// Expression11ListGroup: Operator04;
    ///
    #[parol_runtime::function_name::named]
    fn expression11_list_group_4(
        &mut self,
        _operator04: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator04 = pop_item!(self, operator04, Operator04, context);
        let expression11_list_group_4_built = Expression11ListGroupOperator04Builder::default()
            .operator04(Box::new(operator04))
            .build()
            .into_diagnostic()?;
        let expression11_list_group_4_built =
            Expression11ListGroup::Operator04(expression11_list_group_4_built);
        self.push(
            ASTType::Expression11ListGroup(expression11_list_group_4_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 308:
    ///
    /// Expression11List /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn expression11_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression11_list_1_built = Vec::new();
        self.push(
            ASTType::Expression11List(expression11_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 309:
    ///
    /// Factor: Number;
    ///
    #[parol_runtime::function_name::named]
    fn factor_0(
        &mut self,
        _number: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let number = pop_item!(self, number, Number, context);
        let factor_0_built = FactorNumberBuilder::default()
            .number(Box::new(number))
            .build()
            .into_diagnostic()?;
        let factor_0_built = Factor::Number(factor_0_built);
        // Calling user action here
        self.user_grammar.factor(&factor_0_built)?;
        self.push(ASTType::Factor(factor_0_built), context);
        Ok(())
    }

    /// Semantic action for production 310:
    ///
    /// Factor: FactorOpt /* Option */ ScopedOrHierIdentifier FactorOpt0 /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn factor_1(
        &mut self,
        _factor_opt: &ParseTreeStackEntry<'t>,
        _scoped_or_hier_identifier: &ParseTreeStackEntry<'t>,
        _factor_opt0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let factor_opt0 = pop_item!(self, factor_opt0, FactorOpt0, context);
        let scoped_or_hier_identifier = pop_item!(
            self,
            scoped_or_hier_identifier,
            ScopedOrHierIdentifier,
            context
        );
        let factor_opt = pop_item!(self, factor_opt, FactorOpt, context);
        let factor_1_built = FactorFactorOptScopedOrHierIdentifierFactorOpt0Builder::default()
            .factor_opt(factor_opt)
            .scoped_or_hier_identifier(Box::new(scoped_or_hier_identifier))
            .factor_opt0(factor_opt0)
            .build()
            .into_diagnostic()?;
        let factor_1_built = Factor::FactorOptScopedOrHierIdentifierFactorOpt0(factor_1_built);
        // Calling user action here
        self.user_grammar.factor(&factor_1_built)?;
        self.push(ASTType::Factor(factor_1_built), context);
        Ok(())
    }

    /// Semantic action for production 311:
    ///
    /// Factor: LParen Expression RParen;
    ///
    #[parol_runtime::function_name::named]
    fn factor_2(
        &mut self,
        _l_paren: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _r_paren: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren = pop_item!(self, r_paren, RParen, context);
        let expression = pop_item!(self, expression, Expression, context);
        let l_paren = pop_item!(self, l_paren, LParen, context);
        let factor_2_built = FactorLParenExpressionRParenBuilder::default()
            .l_paren(Box::new(l_paren))
            .expression(Box::new(expression))
            .r_paren(Box::new(r_paren))
            .build()
            .into_diagnostic()?;
        let factor_2_built = Factor::LParenExpressionRParen(factor_2_built);
        // Calling user action here
        self.user_grammar.factor(&factor_2_built)?;
        self.push(ASTType::Factor(factor_2_built), context);
        Ok(())
    }

    /// Semantic action for production 312:
    ///
    /// FactorOpt0 /* Option<T>::Some */: LParen FactorOpt1 /* Option */ RParen;
    ///
    #[parol_runtime::function_name::named]
    fn factor_opt0_0(
        &mut self,
        _l_paren: &ParseTreeStackEntry<'t>,
        _factor_opt1: &ParseTreeStackEntry<'t>,
        _r_paren: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren = pop_item!(self, r_paren, RParen, context);
        let factor_opt1 = pop_item!(self, factor_opt1, FactorOpt1, context);
        let l_paren = pop_item!(self, l_paren, LParen, context);
        let factor_opt0_0_built = FactorOpt0Builder::default()
            .l_paren(Box::new(l_paren))
            .factor_opt1(factor_opt1)
            .r_paren(Box::new(r_paren))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::FactorOpt0(Some(Box::new(factor_opt0_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 313:
    ///
    /// FactorOpt1 /* Option<T>::Some */: FunctionCallArg;
    ///
    #[parol_runtime::function_name::named]
    fn factor_opt1_0(
        &mut self,
        _function_call_arg: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let function_call_arg = pop_item!(self, function_call_arg, FunctionCallArg, context);
        let factor_opt1_0_built = FactorOpt1Builder::default()
            .function_call_arg(Box::new(function_call_arg))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::FactorOpt1(Some(Box::new(factor_opt1_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 314:
    ///
    /// FactorOpt1 /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn factor_opt1_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::FactorOpt1(None), context);
        Ok(())
    }

    /// Semantic action for production 315:
    ///
    /// FactorOpt0 /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn factor_opt0_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::FactorOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 316:
    ///
    /// FactorOpt /* Option<T>::Some */: Dollar;
    ///
    #[parol_runtime::function_name::named]
    fn factor_opt_0(
        &mut self,
        _dollar: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dollar = pop_item!(self, dollar, Dollar, context);
        let factor_opt_0_built = FactorOptBuilder::default()
            .dollar(Box::new(dollar))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::FactorOpt(Some(Box::new(factor_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 317:
    ///
    /// FactorOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn factor_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::FactorOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 318:
    ///
    /// FunctionCallArg: Expression FunctionCallArgList /* Vec */ FunctionCallArgOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn function_call_arg(
        &mut self,
        _expression: &ParseTreeStackEntry<'t>,
        _function_call_arg_list: &ParseTreeStackEntry<'t>,
        _function_call_arg_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let function_call_arg_opt =
            pop_item!(self, function_call_arg_opt, FunctionCallArgOpt, context);
        let function_call_arg_list =
            pop_and_reverse_item!(self, function_call_arg_list, FunctionCallArgList, context);
        let expression = pop_item!(self, expression, Expression, context);
        let function_call_arg_built = FunctionCallArgBuilder::default()
            .expression(Box::new(expression))
            .function_call_arg_list(function_call_arg_list)
            .function_call_arg_opt(function_call_arg_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .function_call_arg(&function_call_arg_built)?;
        self.push(ASTType::FunctionCallArg(function_call_arg_built), context);
        Ok(())
    }

    /// Semantic action for production 319:
    ///
    /// FunctionCallArgList /* Vec<T>::Push */: Comma Expression FunctionCallArgList;
    ///
    #[parol_runtime::function_name::named]
    fn function_call_arg_list_0(
        &mut self,
        _comma: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _function_call_arg_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut function_call_arg_list =
            pop_item!(self, function_call_arg_list, FunctionCallArgList, context);
        let expression = pop_item!(self, expression, Expression, context);
        let comma = pop_item!(self, comma, Comma, context);
        let function_call_arg_list_0_built = FunctionCallArgListBuilder::default()
            .expression(Box::new(expression))
            .comma(Box::new(comma))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        function_call_arg_list.push(function_call_arg_list_0_built);
        self.push(
            ASTType::FunctionCallArgList(function_call_arg_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 320:
    ///
    /// FunctionCallArgList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn function_call_arg_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let function_call_arg_list_1_built = Vec::new();
        self.push(
            ASTType::FunctionCallArgList(function_call_arg_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 321:
    ///
    /// FunctionCallArgOpt /* Option<T>::Some */: Comma;
    ///
    #[parol_runtime::function_name::named]
    fn function_call_arg_opt_0(
        &mut self,
        _comma: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = pop_item!(self, comma, Comma, context);
        let function_call_arg_opt_0_built = FunctionCallArgOptBuilder::default()
            .comma(Box::new(comma))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::FunctionCallArgOpt(Some(Box::new(function_call_arg_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 322:
    ///
    /// FunctionCallArgOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn function_call_arg_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::FunctionCallArgOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 323:
    ///
    /// Range: LBracket Expression RangeOpt /* Option */ RBracket;
    ///
    #[parol_runtime::function_name::named]
    fn range(
        &mut self,
        _l_bracket: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _range_opt: &ParseTreeStackEntry<'t>,
        _r_bracket: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_bracket = pop_item!(self, r_bracket, RBracket, context);
        let range_opt = pop_item!(self, range_opt, RangeOpt, context);
        let expression = pop_item!(self, expression, Expression, context);
        let l_bracket = pop_item!(self, l_bracket, LBracket, context);
        let range_built = RangeBuilder::default()
            .l_bracket(Box::new(l_bracket))
            .expression(Box::new(expression))
            .range_opt(range_opt)
            .r_bracket(Box::new(r_bracket))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.range(&range_built)?;
        self.push(ASTType::Range(range_built), context);
        Ok(())
    }

    /// Semantic action for production 324:
    ///
    /// RangeOpt /* Option<T>::Some */: RangeOperator Expression;
    ///
    #[parol_runtime::function_name::named]
    fn range_opt_0(
        &mut self,
        _range_operator: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = pop_item!(self, expression, Expression, context);
        let range_operator = pop_item!(self, range_operator, RangeOperator, context);
        let range_opt_0_built = RangeOptBuilder::default()
            .range_operator(Box::new(range_operator))
            .expression(Box::new(expression))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::RangeOpt(Some(Box::new(range_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 325:
    ///
    /// RangeOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn range_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::RangeOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 326:
    ///
    /// RangeOperator: Colon;
    ///
    #[parol_runtime::function_name::named]
    fn range_operator_0(
        &mut self,
        _colon: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let colon = pop_item!(self, colon, Colon, context);
        let range_operator_0_built = RangeOperatorColonBuilder::default()
            .colon(Box::new(colon))
            .build()
            .into_diagnostic()?;
        let range_operator_0_built = RangeOperator::Colon(range_operator_0_built);
        // Calling user action here
        self.user_grammar.range_operator(&range_operator_0_built)?;
        self.push(ASTType::RangeOperator(range_operator_0_built), context);
        Ok(())
    }

    /// Semantic action for production 327:
    ///
    /// RangeOperator: PlusColon;
    ///
    #[parol_runtime::function_name::named]
    fn range_operator_1(
        &mut self,
        _plus_colon: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let plus_colon = pop_item!(self, plus_colon, PlusColon, context);
        let range_operator_1_built = RangeOperatorPlusColonBuilder::default()
            .plus_colon(Box::new(plus_colon))
            .build()
            .into_diagnostic()?;
        let range_operator_1_built = RangeOperator::PlusColon(range_operator_1_built);
        // Calling user action here
        self.user_grammar.range_operator(&range_operator_1_built)?;
        self.push(ASTType::RangeOperator(range_operator_1_built), context);
        Ok(())
    }

    /// Semantic action for production 328:
    ///
    /// RangeOperator: MinusColon;
    ///
    #[parol_runtime::function_name::named]
    fn range_operator_2(
        &mut self,
        _minus_colon: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let minus_colon = pop_item!(self, minus_colon, MinusColon, context);
        let range_operator_2_built = RangeOperatorMinusColonBuilder::default()
            .minus_colon(Box::new(minus_colon))
            .build()
            .into_diagnostic()?;
        let range_operator_2_built = RangeOperator::MinusColon(range_operator_2_built);
        // Calling user action here
        self.user_grammar.range_operator(&range_operator_2_built)?;
        self.push(ASTType::RangeOperator(range_operator_2_built), context);
        Ok(())
    }

    /// Semantic action for production 329:
    ///
    /// RangeOperator: Step;
    ///
    #[parol_runtime::function_name::named]
    fn range_operator_3(
        &mut self,
        _step: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let step = pop_item!(self, step, Step, context);
        let range_operator_3_built = RangeOperatorStepBuilder::default()
            .step(Box::new(step))
            .build()
            .into_diagnostic()?;
        let range_operator_3_built = RangeOperator::Step(range_operator_3_built);
        // Calling user action here
        self.user_grammar.range_operator(&range_operator_3_built)?;
        self.push(ASTType::RangeOperator(range_operator_3_built), context);
        Ok(())
    }

    /// Semantic action for production 330:
    ///
    /// Width: LBracket Expression RBracket;
    ///
    #[parol_runtime::function_name::named]
    fn width(
        &mut self,
        _l_bracket: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _r_bracket: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_bracket = pop_item!(self, r_bracket, RBracket, context);
        let expression = pop_item!(self, expression, Expression, context);
        let l_bracket = pop_item!(self, l_bracket, LBracket, context);
        let width_built = WidthBuilder::default()
            .l_bracket(Box::new(l_bracket))
            .expression(Box::new(expression))
            .r_bracket(Box::new(r_bracket))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.width(&width_built)?;
        self.push(ASTType::Width(width_built), context);
        Ok(())
    }

    /// Semantic action for production 331:
    ///
    /// BuiltinType: Logic;
    ///
    #[parol_runtime::function_name::named]
    fn builtin_type_0(
        &mut self,
        _logic: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logic = pop_item!(self, logic, Logic, context);
        let builtin_type_0_built = BuiltinTypeLogicBuilder::default()
            .logic(Box::new(logic))
            .build()
            .into_diagnostic()?;
        let builtin_type_0_built = BuiltinType::Logic(builtin_type_0_built);
        // Calling user action here
        self.user_grammar.builtin_type(&builtin_type_0_built)?;
        self.push(ASTType::BuiltinType(builtin_type_0_built), context);
        Ok(())
    }

    /// Semantic action for production 332:
    ///
    /// BuiltinType: Bit;
    ///
    #[parol_runtime::function_name::named]
    fn builtin_type_1(
        &mut self,
        _bit: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bit = pop_item!(self, bit, Bit, context);
        let builtin_type_1_built = BuiltinTypeBitBuilder::default()
            .bit(Box::new(bit))
            .build()
            .into_diagnostic()?;
        let builtin_type_1_built = BuiltinType::Bit(builtin_type_1_built);
        // Calling user action here
        self.user_grammar.builtin_type(&builtin_type_1_built)?;
        self.push(ASTType::BuiltinType(builtin_type_1_built), context);
        Ok(())
    }

    /// Semantic action for production 333:
    ///
    /// BuiltinType: U32;
    ///
    #[parol_runtime::function_name::named]
    fn builtin_type_2(
        &mut self,
        _u32: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let u32 = pop_item!(self, u32, U32, context);
        let builtin_type_2_built = BuiltinTypeU32Builder::default()
            .u32(Box::new(u32))
            .build()
            .into_diagnostic()?;
        let builtin_type_2_built = BuiltinType::U32(builtin_type_2_built);
        // Calling user action here
        self.user_grammar.builtin_type(&builtin_type_2_built)?;
        self.push(ASTType::BuiltinType(builtin_type_2_built), context);
        Ok(())
    }

    /// Semantic action for production 334:
    ///
    /// BuiltinType: U64;
    ///
    #[parol_runtime::function_name::named]
    fn builtin_type_3(
        &mut self,
        _u64: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let u64 = pop_item!(self, u64, U64, context);
        let builtin_type_3_built = BuiltinTypeU64Builder::default()
            .u64(Box::new(u64))
            .build()
            .into_diagnostic()?;
        let builtin_type_3_built = BuiltinType::U64(builtin_type_3_built);
        // Calling user action here
        self.user_grammar.builtin_type(&builtin_type_3_built)?;
        self.push(ASTType::BuiltinType(builtin_type_3_built), context);
        Ok(())
    }

    /// Semantic action for production 335:
    ///
    /// BuiltinType: I32;
    ///
    #[parol_runtime::function_name::named]
    fn builtin_type_4(
        &mut self,
        _i32: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let i32 = pop_item!(self, i32, I32, context);
        let builtin_type_4_built = BuiltinTypeI32Builder::default()
            .i32(Box::new(i32))
            .build()
            .into_diagnostic()?;
        let builtin_type_4_built = BuiltinType::I32(builtin_type_4_built);
        // Calling user action here
        self.user_grammar.builtin_type(&builtin_type_4_built)?;
        self.push(ASTType::BuiltinType(builtin_type_4_built), context);
        Ok(())
    }

    /// Semantic action for production 336:
    ///
    /// BuiltinType: I64;
    ///
    #[parol_runtime::function_name::named]
    fn builtin_type_5(
        &mut self,
        _i64: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let i64 = pop_item!(self, i64, I64, context);
        let builtin_type_5_built = BuiltinTypeI64Builder::default()
            .i64(Box::new(i64))
            .build()
            .into_diagnostic()?;
        let builtin_type_5_built = BuiltinType::I64(builtin_type_5_built);
        // Calling user action here
        self.user_grammar.builtin_type(&builtin_type_5_built)?;
        self.push(ASTType::BuiltinType(builtin_type_5_built), context);
        Ok(())
    }

    /// Semantic action for production 337:
    ///
    /// BuiltinType: F32;
    ///
    #[parol_runtime::function_name::named]
    fn builtin_type_6(
        &mut self,
        _f32: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let f32 = pop_item!(self, f32, F32, context);
        let builtin_type_6_built = BuiltinTypeF32Builder::default()
            .f32(Box::new(f32))
            .build()
            .into_diagnostic()?;
        let builtin_type_6_built = BuiltinType::F32(builtin_type_6_built);
        // Calling user action here
        self.user_grammar.builtin_type(&builtin_type_6_built)?;
        self.push(ASTType::BuiltinType(builtin_type_6_built), context);
        Ok(())
    }

    /// Semantic action for production 338:
    ///
    /// BuiltinType: F64;
    ///
    #[parol_runtime::function_name::named]
    fn builtin_type_7(
        &mut self,
        _f64: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let f64 = pop_item!(self, f64, F64, context);
        let builtin_type_7_built = BuiltinTypeF64Builder::default()
            .f64(Box::new(f64))
            .build()
            .into_diagnostic()?;
        let builtin_type_7_built = BuiltinType::F64(builtin_type_7_built);
        // Calling user action here
        self.user_grammar.builtin_type(&builtin_type_7_built)?;
        self.push(ASTType::BuiltinType(builtin_type_7_built), context);
        Ok(())
    }

    /// Semantic action for production 339:
    ///
    /// Type: TypeGroup TypeList /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn r#type(
        &mut self,
        _type_group: &ParseTreeStackEntry<'t>,
        _type_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_list = pop_and_reverse_item!(self, type_list, TypeList, context);
        let type_group = pop_item!(self, type_group, TypeGroup, context);
        let r#type_built = TypeBuilder::default()
            .type_group(Box::new(type_group))
            .type_list(type_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.r#type(&r#type_built)?;
        self.push(ASTType::Type(r#type_built), context);
        Ok(())
    }

    /// Semantic action for production 340:
    ///
    /// TypeGroup: BuiltinType;
    ///
    #[parol_runtime::function_name::named]
    fn type_group_0(
        &mut self,
        _builtin_type: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let builtin_type = pop_item!(self, builtin_type, BuiltinType, context);
        let type_group_0_built = TypeGroupBuiltinTypeBuilder::default()
            .builtin_type(Box::new(builtin_type))
            .build()
            .into_diagnostic()?;
        let type_group_0_built = TypeGroup::BuiltinType(type_group_0_built);
        self.push(ASTType::TypeGroup(type_group_0_built), context);
        Ok(())
    }

    /// Semantic action for production 341:
    ///
    /// TypeGroup: ScopedIdentifier;
    ///
    #[parol_runtime::function_name::named]
    fn type_group_1(
        &mut self,
        _scoped_identifier: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scoped_identifier = pop_item!(self, scoped_identifier, ScopedIdentifier, context);
        let type_group_1_built = TypeGroupScopedIdentifierBuilder::default()
            .scoped_identifier(Box::new(scoped_identifier))
            .build()
            .into_diagnostic()?;
        let type_group_1_built = TypeGroup::ScopedIdentifier(type_group_1_built);
        self.push(ASTType::TypeGroup(type_group_1_built), context);
        Ok(())
    }

    /// Semantic action for production 342:
    ///
    /// TypeList /* Vec<T>::Push */: Width TypeList;
    ///
    #[parol_runtime::function_name::named]
    fn type_list_0(
        &mut self,
        _width: &ParseTreeStackEntry<'t>,
        _type_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut type_list = pop_item!(self, type_list, TypeList, context);
        let width = pop_item!(self, width, Width, context);
        let type_list_0_built = TypeListBuilder::default()
            .width(Box::new(width))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        type_list.push(type_list_0_built);
        self.push(ASTType::TypeList(type_list), context);
        Ok(())
    }

    /// Semantic action for production 343:
    ///
    /// TypeList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn type_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_list_1_built = Vec::new();
        self.push(ASTType::TypeList(type_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 344:
    ///
    /// Statement: AssignmentStatement;
    ///
    #[parol_runtime::function_name::named]
    fn statement_0(
        &mut self,
        _assignment_statement: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let assignment_statement =
            pop_item!(self, assignment_statement, AssignmentStatement, context);
        let statement_0_built = StatementAssignmentStatementBuilder::default()
            .assignment_statement(Box::new(assignment_statement))
            .build()
            .into_diagnostic()?;
        let statement_0_built = Statement::AssignmentStatement(statement_0_built);
        // Calling user action here
        self.user_grammar.statement(&statement_0_built)?;
        self.push(ASTType::Statement(statement_0_built), context);
        Ok(())
    }

    /// Semantic action for production 345:
    ///
    /// Statement: IfStatement;
    ///
    #[parol_runtime::function_name::named]
    fn statement_1(
        &mut self,
        _if_statement: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_statement = pop_item!(self, if_statement, IfStatement, context);
        let statement_1_built = StatementIfStatementBuilder::default()
            .if_statement(Box::new(if_statement))
            .build()
            .into_diagnostic()?;
        let statement_1_built = Statement::IfStatement(statement_1_built);
        // Calling user action here
        self.user_grammar.statement(&statement_1_built)?;
        self.push(ASTType::Statement(statement_1_built), context);
        Ok(())
    }

    /// Semantic action for production 346:
    ///
    /// Statement: IfResetStatement;
    ///
    #[parol_runtime::function_name::named]
    fn statement_2(
        &mut self,
        _if_reset_statement: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_reset_statement = pop_item!(self, if_reset_statement, IfResetStatement, context);
        let statement_2_built = StatementIfResetStatementBuilder::default()
            .if_reset_statement(Box::new(if_reset_statement))
            .build()
            .into_diagnostic()?;
        let statement_2_built = Statement::IfResetStatement(statement_2_built);
        // Calling user action here
        self.user_grammar.statement(&statement_2_built)?;
        self.push(ASTType::Statement(statement_2_built), context);
        Ok(())
    }

    /// Semantic action for production 347:
    ///
    /// Statement: ReturnStatement;
    ///
    #[parol_runtime::function_name::named]
    fn statement_3(
        &mut self,
        _return_statement: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let return_statement = pop_item!(self, return_statement, ReturnStatement, context);
        let statement_3_built = StatementReturnStatementBuilder::default()
            .return_statement(Box::new(return_statement))
            .build()
            .into_diagnostic()?;
        let statement_3_built = Statement::ReturnStatement(statement_3_built);
        // Calling user action here
        self.user_grammar.statement(&statement_3_built)?;
        self.push(ASTType::Statement(statement_3_built), context);
        Ok(())
    }

    /// Semantic action for production 348:
    ///
    /// Statement: ForStatement;
    ///
    #[parol_runtime::function_name::named]
    fn statement_4(
        &mut self,
        _for_statement: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let for_statement = pop_item!(self, for_statement, ForStatement, context);
        let statement_4_built = StatementForStatementBuilder::default()
            .for_statement(Box::new(for_statement))
            .build()
            .into_diagnostic()?;
        let statement_4_built = Statement::ForStatement(statement_4_built);
        // Calling user action here
        self.user_grammar.statement(&statement_4_built)?;
        self.push(ASTType::Statement(statement_4_built), context);
        Ok(())
    }

    /// Semantic action for production 349:
    ///
    /// Statement: CaseStatement;
    ///
    #[parol_runtime::function_name::named]
    fn statement_5(
        &mut self,
        _case_statement: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let case_statement = pop_item!(self, case_statement, CaseStatement, context);
        let statement_5_built = StatementCaseStatementBuilder::default()
            .case_statement(Box::new(case_statement))
            .build()
            .into_diagnostic()?;
        let statement_5_built = Statement::CaseStatement(statement_5_built);
        // Calling user action here
        self.user_grammar.statement(&statement_5_built)?;
        self.push(ASTType::Statement(statement_5_built), context);
        Ok(())
    }

    /// Semantic action for production 350:
    ///
    /// AssignmentStatement: HierarchicalIdentifier AssignmentStatementGroup Expression Semicolon;
    ///
    #[parol_runtime::function_name::named]
    fn assignment_statement(
        &mut self,
        _hierarchical_identifier: &ParseTreeStackEntry<'t>,
        _assignment_statement_group: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _semicolon: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon = pop_item!(self, semicolon, Semicolon, context);
        let expression = pop_item!(self, expression, Expression, context);
        let assignment_statement_group = pop_item!(
            self,
            assignment_statement_group,
            AssignmentStatementGroup,
            context
        );
        let hierarchical_identifier = pop_item!(
            self,
            hierarchical_identifier,
            HierarchicalIdentifier,
            context
        );
        let assignment_statement_built = AssignmentStatementBuilder::default()
            .hierarchical_identifier(Box::new(hierarchical_identifier))
            .assignment_statement_group(Box::new(assignment_statement_group))
            .expression(Box::new(expression))
            .semicolon(Box::new(semicolon))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .assignment_statement(&assignment_statement_built)?;
        self.push(
            ASTType::AssignmentStatement(assignment_statement_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 351:
    ///
    /// AssignmentStatementGroup: Equ;
    ///
    #[parol_runtime::function_name::named]
    fn assignment_statement_group_0(
        &mut self,
        _equ: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let equ = pop_item!(self, equ, Equ, context);
        let assignment_statement_group_0_built = AssignmentStatementGroupEquBuilder::default()
            .equ(Box::new(equ))
            .build()
            .into_diagnostic()?;
        let assignment_statement_group_0_built =
            AssignmentStatementGroup::Equ(assignment_statement_group_0_built);
        self.push(
            ASTType::AssignmentStatementGroup(assignment_statement_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 352:
    ///
    /// AssignmentStatementGroup: AssignmentOperator;
    ///
    #[parol_runtime::function_name::named]
    fn assignment_statement_group_1(
        &mut self,
        _assignment_operator: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let assignment_operator = pop_item!(self, assignment_operator, AssignmentOperator, context);
        let assignment_statement_group_1_built =
            AssignmentStatementGroupAssignmentOperatorBuilder::default()
                .assignment_operator(Box::new(assignment_operator))
                .build()
                .into_diagnostic()?;
        let assignment_statement_group_1_built =
            AssignmentStatementGroup::AssignmentOperator(assignment_statement_group_1_built);
        self.push(
            ASTType::AssignmentStatementGroup(assignment_statement_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 353:
    ///
    /// IfStatement: If Expression LBrace IfStatementList /* Vec */ RBrace IfStatementList0 /* Vec */ IfStatementOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn if_statement(
        &mut self,
        _if: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _l_brace: &ParseTreeStackEntry<'t>,
        _if_statement_list: &ParseTreeStackEntry<'t>,
        _r_brace: &ParseTreeStackEntry<'t>,
        _if_statement_list0: &ParseTreeStackEntry<'t>,
        _if_statement_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_statement_opt = pop_item!(self, if_statement_opt, IfStatementOpt, context);
        let if_statement_list0 =
            pop_and_reverse_item!(self, if_statement_list0, IfStatementList0, context);
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let if_statement_list =
            pop_and_reverse_item!(self, if_statement_list, IfStatementList, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let expression = pop_item!(self, expression, Expression, context);
        let r#if = pop_item!(self, r#if, If, context);
        let if_statement_built = IfStatementBuilder::default()
            .r#if(Box::new(r#if))
            .expression(Box::new(expression))
            .l_brace(Box::new(l_brace))
            .if_statement_list(if_statement_list)
            .r_brace(Box::new(r_brace))
            .if_statement_list0(if_statement_list0)
            .if_statement_opt(if_statement_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.if_statement(&if_statement_built)?;
        self.push(ASTType::IfStatement(if_statement_built), context);
        Ok(())
    }

    /// Semantic action for production 354:
    ///
    /// IfStatementList0 /* Vec<T>::Push */: Else If Expression LBrace IfStatementList0List /* Vec */ RBrace IfStatementList0;
    ///
    #[parol_runtime::function_name::named]
    fn if_statement_list0_0(
        &mut self,
        _else: &ParseTreeStackEntry<'t>,
        _if: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _l_brace: &ParseTreeStackEntry<'t>,
        _if_statement_list0_list: &ParseTreeStackEntry<'t>,
        _r_brace: &ParseTreeStackEntry<'t>,
        _if_statement_list0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut if_statement_list0 = pop_item!(self, if_statement_list0, IfStatementList0, context);
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let if_statement_list0_list =
            pop_and_reverse_item!(self, if_statement_list0_list, IfStatementList0List, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let expression = pop_item!(self, expression, Expression, context);
        let r#if = pop_item!(self, r#if, If, context);
        let r#else = pop_item!(self, r#else, Else, context);
        let if_statement_list0_0_built = IfStatementList0Builder::default()
            .r_brace(Box::new(r_brace))
            .if_statement_list0_list(if_statement_list0_list)
            .l_brace(Box::new(l_brace))
            .expression(Box::new(expression))
            .r#if(Box::new(r#if))
            .r#else(Box::new(r#else))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        if_statement_list0.push(if_statement_list0_0_built);
        self.push(ASTType::IfStatementList0(if_statement_list0), context);
        Ok(())
    }

    /// Semantic action for production 355:
    ///
    /// IfStatementList0List /* Vec<T>::Push */: Statement IfStatementList0List;
    ///
    #[parol_runtime::function_name::named]
    fn if_statement_list0_list_0(
        &mut self,
        _statement: &ParseTreeStackEntry<'t>,
        _if_statement_list0_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut if_statement_list0_list =
            pop_item!(self, if_statement_list0_list, IfStatementList0List, context);
        let statement = pop_item!(self, statement, Statement, context);
        let if_statement_list0_list_0_built = IfStatementList0ListBuilder::default()
            .statement(Box::new(statement))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        if_statement_list0_list.push(if_statement_list0_list_0_built);
        self.push(
            ASTType::IfStatementList0List(if_statement_list0_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 356:
    ///
    /// IfStatementList0List /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn if_statement_list0_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_statement_list0_list_1_built = Vec::new();
        self.push(
            ASTType::IfStatementList0List(if_statement_list0_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 357:
    ///
    /// IfStatementList0 /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn if_statement_list0_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_statement_list0_1_built = Vec::new();
        self.push(
            ASTType::IfStatementList0(if_statement_list0_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 358:
    ///
    /// IfStatementList /* Vec<T>::Push */: Statement IfStatementList;
    ///
    #[parol_runtime::function_name::named]
    fn if_statement_list_0(
        &mut self,
        _statement: &ParseTreeStackEntry<'t>,
        _if_statement_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut if_statement_list = pop_item!(self, if_statement_list, IfStatementList, context);
        let statement = pop_item!(self, statement, Statement, context);
        let if_statement_list_0_built = IfStatementListBuilder::default()
            .statement(Box::new(statement))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        if_statement_list.push(if_statement_list_0_built);
        self.push(ASTType::IfStatementList(if_statement_list), context);
        Ok(())
    }

    /// Semantic action for production 359:
    ///
    /// IfStatementList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn if_statement_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_statement_list_1_built = Vec::new();
        self.push(ASTType::IfStatementList(if_statement_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 360:
    ///
    /// IfStatementOpt /* Option<T>::Some */: Else LBrace IfStatementOptList /* Vec */ RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn if_statement_opt_0(
        &mut self,
        _else: &ParseTreeStackEntry<'t>,
        _l_brace: &ParseTreeStackEntry<'t>,
        _if_statement_opt_list: &ParseTreeStackEntry<'t>,
        _r_brace: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let if_statement_opt_list =
            pop_and_reverse_item!(self, if_statement_opt_list, IfStatementOptList, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let r#else = pop_item!(self, r#else, Else, context);
        let if_statement_opt_0_built = IfStatementOptBuilder::default()
            .r#else(Box::new(r#else))
            .l_brace(Box::new(l_brace))
            .if_statement_opt_list(if_statement_opt_list)
            .r_brace(Box::new(r_brace))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::IfStatementOpt(Some(Box::new(if_statement_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 361:
    ///
    /// IfStatementOptList /* Vec<T>::Push */: Statement IfStatementOptList;
    ///
    #[parol_runtime::function_name::named]
    fn if_statement_opt_list_0(
        &mut self,
        _statement: &ParseTreeStackEntry<'t>,
        _if_statement_opt_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut if_statement_opt_list =
            pop_item!(self, if_statement_opt_list, IfStatementOptList, context);
        let statement = pop_item!(self, statement, Statement, context);
        let if_statement_opt_list_0_built = IfStatementOptListBuilder::default()
            .statement(Box::new(statement))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        if_statement_opt_list.push(if_statement_opt_list_0_built);
        self.push(ASTType::IfStatementOptList(if_statement_opt_list), context);
        Ok(())
    }

    /// Semantic action for production 362:
    ///
    /// IfStatementOptList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn if_statement_opt_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_statement_opt_list_1_built = Vec::new();
        self.push(
            ASTType::IfStatementOptList(if_statement_opt_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 363:
    ///
    /// IfStatementOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn if_statement_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::IfStatementOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 364:
    ///
    /// IfResetStatement: IfReset LBrace IfResetStatementList /* Vec */ RBrace IfResetStatementList0 /* Vec */ IfResetStatementOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn if_reset_statement(
        &mut self,
        _if_reset: &ParseTreeStackEntry<'t>,
        _l_brace: &ParseTreeStackEntry<'t>,
        _if_reset_statement_list: &ParseTreeStackEntry<'t>,
        _r_brace: &ParseTreeStackEntry<'t>,
        _if_reset_statement_list0: &ParseTreeStackEntry<'t>,
        _if_reset_statement_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_reset_statement_opt =
            pop_item!(self, if_reset_statement_opt, IfResetStatementOpt, context);
        let if_reset_statement_list0 = pop_and_reverse_item!(
            self,
            if_reset_statement_list0,
            IfResetStatementList0,
            context
        );
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let if_reset_statement_list =
            pop_and_reverse_item!(self, if_reset_statement_list, IfResetStatementList, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let if_reset = pop_item!(self, if_reset, IfReset, context);
        let if_reset_statement_built = IfResetStatementBuilder::default()
            .if_reset(Box::new(if_reset))
            .l_brace(Box::new(l_brace))
            .if_reset_statement_list(if_reset_statement_list)
            .r_brace(Box::new(r_brace))
            .if_reset_statement_list0(if_reset_statement_list0)
            .if_reset_statement_opt(if_reset_statement_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .if_reset_statement(&if_reset_statement_built)?;
        self.push(ASTType::IfResetStatement(if_reset_statement_built), context);
        Ok(())
    }

    /// Semantic action for production 365:
    ///
    /// IfResetStatementList0 /* Vec<T>::Push */: Else If Expression LBrace IfResetStatementList0List /* Vec */ RBrace IfResetStatementList0;
    ///
    #[parol_runtime::function_name::named]
    fn if_reset_statement_list0_0(
        &mut self,
        _else: &ParseTreeStackEntry<'t>,
        _if: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _l_brace: &ParseTreeStackEntry<'t>,
        _if_reset_statement_list0_list: &ParseTreeStackEntry<'t>,
        _r_brace: &ParseTreeStackEntry<'t>,
        _if_reset_statement_list0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut if_reset_statement_list0 = pop_item!(
            self,
            if_reset_statement_list0,
            IfResetStatementList0,
            context
        );
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let if_reset_statement_list0_list = pop_and_reverse_item!(
            self,
            if_reset_statement_list0_list,
            IfResetStatementList0List,
            context
        );
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let expression = pop_item!(self, expression, Expression, context);
        let r#if = pop_item!(self, r#if, If, context);
        let r#else = pop_item!(self, r#else, Else, context);
        let if_reset_statement_list0_0_built = IfResetStatementList0Builder::default()
            .r_brace(Box::new(r_brace))
            .if_reset_statement_list0_list(if_reset_statement_list0_list)
            .l_brace(Box::new(l_brace))
            .expression(Box::new(expression))
            .r#if(Box::new(r#if))
            .r#else(Box::new(r#else))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        if_reset_statement_list0.push(if_reset_statement_list0_0_built);
        self.push(
            ASTType::IfResetStatementList0(if_reset_statement_list0),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 366:
    ///
    /// IfResetStatementList0List /* Vec<T>::Push */: Statement IfResetStatementList0List;
    ///
    #[parol_runtime::function_name::named]
    fn if_reset_statement_list0_list_0(
        &mut self,
        _statement: &ParseTreeStackEntry<'t>,
        _if_reset_statement_list0_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut if_reset_statement_list0_list = pop_item!(
            self,
            if_reset_statement_list0_list,
            IfResetStatementList0List,
            context
        );
        let statement = pop_item!(self, statement, Statement, context);
        let if_reset_statement_list0_list_0_built = IfResetStatementList0ListBuilder::default()
            .statement(Box::new(statement))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        if_reset_statement_list0_list.push(if_reset_statement_list0_list_0_built);
        self.push(
            ASTType::IfResetStatementList0List(if_reset_statement_list0_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 367:
    ///
    /// IfResetStatementList0List /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn if_reset_statement_list0_list_1(
        &mut self,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_reset_statement_list0_list_1_built = Vec::new();
        self.push(
            ASTType::IfResetStatementList0List(if_reset_statement_list0_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 368:
    ///
    /// IfResetStatementList0 /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn if_reset_statement_list0_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_reset_statement_list0_1_built = Vec::new();
        self.push(
            ASTType::IfResetStatementList0(if_reset_statement_list0_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 369:
    ///
    /// IfResetStatementList /* Vec<T>::Push */: Statement IfResetStatementList;
    ///
    #[parol_runtime::function_name::named]
    fn if_reset_statement_list_0(
        &mut self,
        _statement: &ParseTreeStackEntry<'t>,
        _if_reset_statement_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut if_reset_statement_list =
            pop_item!(self, if_reset_statement_list, IfResetStatementList, context);
        let statement = pop_item!(self, statement, Statement, context);
        let if_reset_statement_list_0_built = IfResetStatementListBuilder::default()
            .statement(Box::new(statement))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        if_reset_statement_list.push(if_reset_statement_list_0_built);
        self.push(
            ASTType::IfResetStatementList(if_reset_statement_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 370:
    ///
    /// IfResetStatementList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn if_reset_statement_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_reset_statement_list_1_built = Vec::new();
        self.push(
            ASTType::IfResetStatementList(if_reset_statement_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 371:
    ///
    /// IfResetStatementOpt /* Option<T>::Some */: Else LBrace IfResetStatementOptList /* Vec */ RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn if_reset_statement_opt_0(
        &mut self,
        _else: &ParseTreeStackEntry<'t>,
        _l_brace: &ParseTreeStackEntry<'t>,
        _if_reset_statement_opt_list: &ParseTreeStackEntry<'t>,
        _r_brace: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let if_reset_statement_opt_list = pop_and_reverse_item!(
            self,
            if_reset_statement_opt_list,
            IfResetStatementOptList,
            context
        );
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let r#else = pop_item!(self, r#else, Else, context);
        let if_reset_statement_opt_0_built = IfResetStatementOptBuilder::default()
            .r#else(Box::new(r#else))
            .l_brace(Box::new(l_brace))
            .if_reset_statement_opt_list(if_reset_statement_opt_list)
            .r_brace(Box::new(r_brace))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::IfResetStatementOpt(Some(Box::new(if_reset_statement_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 372:
    ///
    /// IfResetStatementOptList /* Vec<T>::Push */: Statement IfResetStatementOptList;
    ///
    #[parol_runtime::function_name::named]
    fn if_reset_statement_opt_list_0(
        &mut self,
        _statement: &ParseTreeStackEntry<'t>,
        _if_reset_statement_opt_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut if_reset_statement_opt_list = pop_item!(
            self,
            if_reset_statement_opt_list,
            IfResetStatementOptList,
            context
        );
        let statement = pop_item!(self, statement, Statement, context);
        let if_reset_statement_opt_list_0_built = IfResetStatementOptListBuilder::default()
            .statement(Box::new(statement))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        if_reset_statement_opt_list.push(if_reset_statement_opt_list_0_built);
        self.push(
            ASTType::IfResetStatementOptList(if_reset_statement_opt_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 373:
    ///
    /// IfResetStatementOptList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn if_reset_statement_opt_list_1(
        &mut self,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_reset_statement_opt_list_1_built = Vec::new();
        self.push(
            ASTType::IfResetStatementOptList(if_reset_statement_opt_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 374:
    ///
    /// IfResetStatementOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn if_reset_statement_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::IfResetStatementOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 375:
    ///
    /// ReturnStatement: Return Expression Semicolon;
    ///
    #[parol_runtime::function_name::named]
    fn return_statement(
        &mut self,
        _return: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _semicolon: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon = pop_item!(self, semicolon, Semicolon, context);
        let expression = pop_item!(self, expression, Expression, context);
        let r#return = pop_item!(self, r#return, Return, context);
        let return_statement_built = ReturnStatementBuilder::default()
            .r#return(Box::new(r#return))
            .expression(Box::new(expression))
            .semicolon(Box::new(semicolon))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .return_statement(&return_statement_built)?;
        self.push(ASTType::ReturnStatement(return_statement_built), context);
        Ok(())
    }

    /// Semantic action for production 376:
    ///
    /// ForStatement: For Identifier Colon Type In Expression DotDot Expression ForStatementOpt /* Option */ LBrace ForStatementList /* Vec */ RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn for_statement(
        &mut self,
        _for: &ParseTreeStackEntry<'t>,
        _identifier: &ParseTreeStackEntry<'t>,
        _colon: &ParseTreeStackEntry<'t>,
        _type: &ParseTreeStackEntry<'t>,
        _in: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _dot_dot: &ParseTreeStackEntry<'t>,
        _expression0: &ParseTreeStackEntry<'t>,
        _for_statement_opt: &ParseTreeStackEntry<'t>,
        _l_brace: &ParseTreeStackEntry<'t>,
        _for_statement_list: &ParseTreeStackEntry<'t>,
        _r_brace: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let for_statement_list =
            pop_and_reverse_item!(self, for_statement_list, ForStatementList, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let for_statement_opt = pop_item!(self, for_statement_opt, ForStatementOpt, context);
        let expression0 = pop_item!(self, expression0, Expression, context);
        let dot_dot = pop_item!(self, dot_dot, DotDot, context);
        let expression = pop_item!(self, expression, Expression, context);
        let r#in = pop_item!(self, r#in, In, context);
        let r#type = pop_item!(self, r#type, Type, context);
        let colon = pop_item!(self, colon, Colon, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let r#for = pop_item!(self, r#for, For, context);
        let for_statement_built = ForStatementBuilder::default()
            .r#for(Box::new(r#for))
            .identifier(Box::new(identifier))
            .colon(Box::new(colon))
            .r#type(Box::new(r#type))
            .r#in(Box::new(r#in))
            .expression(Box::new(expression))
            .dot_dot(Box::new(dot_dot))
            .expression0(Box::new(expression0))
            .for_statement_opt(for_statement_opt)
            .l_brace(Box::new(l_brace))
            .for_statement_list(for_statement_list)
            .r_brace(Box::new(r_brace))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.for_statement(&for_statement_built)?;
        self.push(ASTType::ForStatement(for_statement_built), context);
        Ok(())
    }

    /// Semantic action for production 377:
    ///
    /// ForStatementList /* Vec<T>::Push */: Statement ForStatementList;
    ///
    #[parol_runtime::function_name::named]
    fn for_statement_list_0(
        &mut self,
        _statement: &ParseTreeStackEntry<'t>,
        _for_statement_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut for_statement_list = pop_item!(self, for_statement_list, ForStatementList, context);
        let statement = pop_item!(self, statement, Statement, context);
        let for_statement_list_0_built = ForStatementListBuilder::default()
            .statement(Box::new(statement))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        for_statement_list.push(for_statement_list_0_built);
        self.push(ASTType::ForStatementList(for_statement_list), context);
        Ok(())
    }

    /// Semantic action for production 378:
    ///
    /// ForStatementList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn for_statement_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let for_statement_list_1_built = Vec::new();
        self.push(
            ASTType::ForStatementList(for_statement_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 379:
    ///
    /// ForStatementOpt /* Option<T>::Some */: Step AssignmentOperator Expression;
    ///
    #[parol_runtime::function_name::named]
    fn for_statement_opt_0(
        &mut self,
        _step: &ParseTreeStackEntry<'t>,
        _assignment_operator: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = pop_item!(self, expression, Expression, context);
        let assignment_operator = pop_item!(self, assignment_operator, AssignmentOperator, context);
        let step = pop_item!(self, step, Step, context);
        let for_statement_opt_0_built = ForStatementOptBuilder::default()
            .step(Box::new(step))
            .assignment_operator(Box::new(assignment_operator))
            .expression(Box::new(expression))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::ForStatementOpt(Some(Box::new(for_statement_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 380:
    ///
    /// ForStatementOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn for_statement_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ForStatementOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 381:
    ///
    /// CaseStatement: Case Expression LBrace CaseStatementList /* Vec */ RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn case_statement(
        &mut self,
        _case: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _l_brace: &ParseTreeStackEntry<'t>,
        _case_statement_list: &ParseTreeStackEntry<'t>,
        _r_brace: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let case_statement_list =
            pop_and_reverse_item!(self, case_statement_list, CaseStatementList, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let expression = pop_item!(self, expression, Expression, context);
        let case = pop_item!(self, case, Case, context);
        let case_statement_built = CaseStatementBuilder::default()
            .case(Box::new(case))
            .expression(Box::new(expression))
            .l_brace(Box::new(l_brace))
            .case_statement_list(case_statement_list)
            .r_brace(Box::new(r_brace))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.case_statement(&case_statement_built)?;
        self.push(ASTType::CaseStatement(case_statement_built), context);
        Ok(())
    }

    /// Semantic action for production 382:
    ///
    /// CaseStatementList /* Vec<T>::Push */: CaseItem CaseStatementList;
    ///
    #[parol_runtime::function_name::named]
    fn case_statement_list_0(
        &mut self,
        _case_item: &ParseTreeStackEntry<'t>,
        _case_statement_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut case_statement_list =
            pop_item!(self, case_statement_list, CaseStatementList, context);
        let case_item = pop_item!(self, case_item, CaseItem, context);
        let case_statement_list_0_built = CaseStatementListBuilder::default()
            .case_item(Box::new(case_item))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        case_statement_list.push(case_statement_list_0_built);
        self.push(ASTType::CaseStatementList(case_statement_list), context);
        Ok(())
    }

    /// Semantic action for production 383:
    ///
    /// CaseStatementList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn case_statement_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let case_statement_list_1_built = Vec::new();
        self.push(
            ASTType::CaseStatementList(case_statement_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 384:
    ///
    /// CaseItem: CaseItemGroup Colon CaseItemGroup0;
    ///
    #[parol_runtime::function_name::named]
    fn case_item(
        &mut self,
        _case_item_group: &ParseTreeStackEntry<'t>,
        _colon: &ParseTreeStackEntry<'t>,
        _case_item_group0: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let case_item_group0 = pop_item!(self, case_item_group0, CaseItemGroup0, context);
        let colon = pop_item!(self, colon, Colon, context);
        let case_item_group = pop_item!(self, case_item_group, CaseItemGroup, context);
        let case_item_built = CaseItemBuilder::default()
            .case_item_group(Box::new(case_item_group))
            .colon(Box::new(colon))
            .case_item_group0(Box::new(case_item_group0))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.case_item(&case_item_built)?;
        self.push(ASTType::CaseItem(case_item_built), context);
        Ok(())
    }

    /// Semantic action for production 385:
    ///
    /// CaseItemGroup0: Statement;
    ///
    #[parol_runtime::function_name::named]
    fn case_item_group0_0(
        &mut self,
        _statement: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement = pop_item!(self, statement, Statement, context);
        let case_item_group0_0_built = CaseItemGroup0StatementBuilder::default()
            .statement(Box::new(statement))
            .build()
            .into_diagnostic()?;
        let case_item_group0_0_built = CaseItemGroup0::Statement(case_item_group0_0_built);
        self.push(ASTType::CaseItemGroup0(case_item_group0_0_built), context);
        Ok(())
    }

    /// Semantic action for production 386:
    ///
    /// CaseItemGroup0: LBrace CaseItemGroup0List /* Vec */ RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn case_item_group0_1(
        &mut self,
        _l_brace: &ParseTreeStackEntry<'t>,
        _case_item_group0_list: &ParseTreeStackEntry<'t>,
        _r_brace: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let case_item_group0_list =
            pop_and_reverse_item!(self, case_item_group0_list, CaseItemGroup0List, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let case_item_group0_1_built =
            CaseItemGroup0LBraceCaseItemGroup0ListRBraceBuilder::default()
                .l_brace(Box::new(l_brace))
                .case_item_group0_list(case_item_group0_list)
                .r_brace(Box::new(r_brace))
                .build()
                .into_diagnostic()?;
        let case_item_group0_1_built =
            CaseItemGroup0::LBraceCaseItemGroup0ListRBrace(case_item_group0_1_built);
        self.push(ASTType::CaseItemGroup0(case_item_group0_1_built), context);
        Ok(())
    }

    /// Semantic action for production 387:
    ///
    /// CaseItemGroup0List /* Vec<T>::Push */: Statement CaseItemGroup0List;
    ///
    #[parol_runtime::function_name::named]
    fn case_item_group0_list_0(
        &mut self,
        _statement: &ParseTreeStackEntry<'t>,
        _case_item_group0_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut case_item_group0_list =
            pop_item!(self, case_item_group0_list, CaseItemGroup0List, context);
        let statement = pop_item!(self, statement, Statement, context);
        let case_item_group0_list_0_built = CaseItemGroup0ListBuilder::default()
            .statement(Box::new(statement))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        case_item_group0_list.push(case_item_group0_list_0_built);
        self.push(ASTType::CaseItemGroup0List(case_item_group0_list), context);
        Ok(())
    }

    /// Semantic action for production 388:
    ///
    /// CaseItemGroup0List /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn case_item_group0_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let case_item_group0_list_1_built = Vec::new();
        self.push(
            ASTType::CaseItemGroup0List(case_item_group0_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 389:
    ///
    /// CaseItemGroup: Expression;
    ///
    #[parol_runtime::function_name::named]
    fn case_item_group_0(
        &mut self,
        _expression: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = pop_item!(self, expression, Expression, context);
        let case_item_group_0_built = CaseItemGroupExpressionBuilder::default()
            .expression(Box::new(expression))
            .build()
            .into_diagnostic()?;
        let case_item_group_0_built = CaseItemGroup::Expression(case_item_group_0_built);
        self.push(ASTType::CaseItemGroup(case_item_group_0_built), context);
        Ok(())
    }

    /// Semantic action for production 390:
    ///
    /// CaseItemGroup: Defaul;
    ///
    #[parol_runtime::function_name::named]
    fn case_item_group_1(
        &mut self,
        _defaul: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let defaul = pop_item!(self, defaul, Defaul, context);
        let case_item_group_1_built = CaseItemGroupDefaulBuilder::default()
            .defaul(Box::new(defaul))
            .build()
            .into_diagnostic()?;
        let case_item_group_1_built = CaseItemGroup::Defaul(case_item_group_1_built);
        self.push(ASTType::CaseItemGroup(case_item_group_1_built), context);
        Ok(())
    }

    /// Semantic action for production 391:
    ///
    /// VarDeclaration: Var Identifier Colon Type VarDeclarationOpt /* Option */ Semicolon;
    ///
    #[parol_runtime::function_name::named]
    fn var_declaration(
        &mut self,
        _var: &ParseTreeStackEntry<'t>,
        _identifier: &ParseTreeStackEntry<'t>,
        _colon: &ParseTreeStackEntry<'t>,
        _type: &ParseTreeStackEntry<'t>,
        _var_declaration_opt: &ParseTreeStackEntry<'t>,
        _semicolon: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon = pop_item!(self, semicolon, Semicolon, context);
        let var_declaration_opt = pop_item!(self, var_declaration_opt, VarDeclarationOpt, context);
        let r#type = pop_item!(self, r#type, Type, context);
        let colon = pop_item!(self, colon, Colon, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let var = pop_item!(self, var, Var, context);
        let var_declaration_built = VarDeclarationBuilder::default()
            .var(Box::new(var))
            .identifier(Box::new(identifier))
            .colon(Box::new(colon))
            .r#type(Box::new(r#type))
            .var_declaration_opt(var_declaration_opt)
            .semicolon(Box::new(semicolon))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.var_declaration(&var_declaration_built)?;
        self.push(ASTType::VarDeclaration(var_declaration_built), context);
        Ok(())
    }

    /// Semantic action for production 392:
    ///
    /// VarDeclarationOpt /* Option<T>::Some */: Equ Expression;
    ///
    #[parol_runtime::function_name::named]
    fn var_declaration_opt_0(
        &mut self,
        _equ: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = pop_item!(self, expression, Expression, context);
        let equ = pop_item!(self, equ, Equ, context);
        let var_declaration_opt_0_built = VarDeclarationOptBuilder::default()
            .equ(Box::new(equ))
            .expression(Box::new(expression))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::VarDeclarationOpt(Some(Box::new(var_declaration_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 393:
    ///
    /// VarDeclarationOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn var_declaration_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::VarDeclarationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 394:
    ///
    /// LocalparamDeclaration: Localparam Identifier Colon Type Equ Expression Semicolon;
    ///
    #[parol_runtime::function_name::named]
    fn localparam_declaration(
        &mut self,
        _localparam: &ParseTreeStackEntry<'t>,
        _identifier: &ParseTreeStackEntry<'t>,
        _colon: &ParseTreeStackEntry<'t>,
        _type: &ParseTreeStackEntry<'t>,
        _equ: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _semicolon: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon = pop_item!(self, semicolon, Semicolon, context);
        let expression = pop_item!(self, expression, Expression, context);
        let equ = pop_item!(self, equ, Equ, context);
        let r#type = pop_item!(self, r#type, Type, context);
        let colon = pop_item!(self, colon, Colon, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let localparam = pop_item!(self, localparam, Localparam, context);
        let localparam_declaration_built = LocalparamDeclarationBuilder::default()
            .localparam(Box::new(localparam))
            .identifier(Box::new(identifier))
            .colon(Box::new(colon))
            .r#type(Box::new(r#type))
            .equ(Box::new(equ))
            .expression(Box::new(expression))
            .semicolon(Box::new(semicolon))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .localparam_declaration(&localparam_declaration_built)?;
        self.push(
            ASTType::LocalparamDeclaration(localparam_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 395:
    ///
    /// AlwaysFfDeclaration: AlwaysFf LParen AlwaysFfClock AlwaysFfDeclarationOpt /* Option */ RParen LBrace AlwaysFfDeclarationList /* Vec */ RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_declaration(
        &mut self,
        _always_ff: &ParseTreeStackEntry<'t>,
        _l_paren: &ParseTreeStackEntry<'t>,
        _always_ff_clock: &ParseTreeStackEntry<'t>,
        _always_ff_declaration_opt: &ParseTreeStackEntry<'t>,
        _r_paren: &ParseTreeStackEntry<'t>,
        _l_brace: &ParseTreeStackEntry<'t>,
        _always_ff_declaration_list: &ParseTreeStackEntry<'t>,
        _r_brace: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let always_ff_declaration_list = pop_and_reverse_item!(
            self,
            always_ff_declaration_list,
            AlwaysFfDeclarationList,
            context
        );
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let r_paren = pop_item!(self, r_paren, RParen, context);
        let always_ff_declaration_opt = pop_item!(
            self,
            always_ff_declaration_opt,
            AlwaysFfDeclarationOpt,
            context
        );
        let always_ff_clock = pop_item!(self, always_ff_clock, AlwaysFfClock, context);
        let l_paren = pop_item!(self, l_paren, LParen, context);
        let always_ff = pop_item!(self, always_ff, AlwaysFf, context);
        let always_ff_declaration_built = AlwaysFfDeclarationBuilder::default()
            .always_ff(Box::new(always_ff))
            .l_paren(Box::new(l_paren))
            .always_ff_clock(Box::new(always_ff_clock))
            .always_ff_declaration_opt(always_ff_declaration_opt)
            .r_paren(Box::new(r_paren))
            .l_brace(Box::new(l_brace))
            .always_ff_declaration_list(always_ff_declaration_list)
            .r_brace(Box::new(r_brace))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .always_ff_declaration(&always_ff_declaration_built)?;
        self.push(
            ASTType::AlwaysFfDeclaration(always_ff_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 396:
    ///
    /// AlwaysFfDeclarationList /* Vec<T>::Push */: Statement AlwaysFfDeclarationList;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_declaration_list_0(
        &mut self,
        _statement: &ParseTreeStackEntry<'t>,
        _always_ff_declaration_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut always_ff_declaration_list = pop_item!(
            self,
            always_ff_declaration_list,
            AlwaysFfDeclarationList,
            context
        );
        let statement = pop_item!(self, statement, Statement, context);
        let always_ff_declaration_list_0_built = AlwaysFfDeclarationListBuilder::default()
            .statement(Box::new(statement))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        always_ff_declaration_list.push(always_ff_declaration_list_0_built);
        self.push(
            ASTType::AlwaysFfDeclarationList(always_ff_declaration_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 397:
    ///
    /// AlwaysFfDeclarationList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_declaration_list_1(
        &mut self,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let always_ff_declaration_list_1_built = Vec::new();
        self.push(
            ASTType::AlwaysFfDeclarationList(always_ff_declaration_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 398:
    ///
    /// AlwaysFfDeclarationOpt /* Option<T>::Some */: Comma AlwaysFfReset;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_declaration_opt_0(
        &mut self,
        _comma: &ParseTreeStackEntry<'t>,
        _always_ff_reset: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let always_ff_reset = pop_item!(self, always_ff_reset, AlwaysFfReset, context);
        let comma = pop_item!(self, comma, Comma, context);
        let always_ff_declaration_opt_0_built = AlwaysFfDeclarationOptBuilder::default()
            .comma(Box::new(comma))
            .always_ff_reset(Box::new(always_ff_reset))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::AlwaysFfDeclarationOpt(Some(Box::new(always_ff_declaration_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 399:
    ///
    /// AlwaysFfDeclarationOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_declaration_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::AlwaysFfDeclarationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 400:
    ///
    /// AlwaysFfClock: AlwaysFfClockOpt /* Option */ HierarchicalIdentifier;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_clock(
        &mut self,
        _always_ff_clock_opt: &ParseTreeStackEntry<'t>,
        _hierarchical_identifier: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let hierarchical_identifier = pop_item!(
            self,
            hierarchical_identifier,
            HierarchicalIdentifier,
            context
        );
        let always_ff_clock_opt = pop_item!(self, always_ff_clock_opt, AlwaysFfClockOpt, context);
        let always_ff_clock_built = AlwaysFfClockBuilder::default()
            .always_ff_clock_opt(always_ff_clock_opt)
            .hierarchical_identifier(Box::new(hierarchical_identifier))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.always_ff_clock(&always_ff_clock_built)?;
        self.push(ASTType::AlwaysFfClock(always_ff_clock_built), context);
        Ok(())
    }

    /// Semantic action for production 401:
    ///
    /// AlwaysFfClockOpt /* Option<T>::Some */: AlwaysFfClockOptGroup;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_clock_opt_0(
        &mut self,
        _always_ff_clock_opt_group: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let always_ff_clock_opt_group = pop_item!(
            self,
            always_ff_clock_opt_group,
            AlwaysFfClockOptGroup,
            context
        );
        let always_ff_clock_opt_0_built = AlwaysFfClockOptBuilder::default()
            .always_ff_clock_opt_group(Box::new(always_ff_clock_opt_group))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::AlwaysFfClockOpt(Some(Box::new(always_ff_clock_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 402:
    ///
    /// AlwaysFfClockOptGroup: Posedge;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_clock_opt_group_0(
        &mut self,
        _posedge: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let posedge = pop_item!(self, posedge, Posedge, context);
        let always_ff_clock_opt_group_0_built = AlwaysFfClockOptGroupPosedgeBuilder::default()
            .posedge(Box::new(posedge))
            .build()
            .into_diagnostic()?;
        let always_ff_clock_opt_group_0_built =
            AlwaysFfClockOptGroup::Posedge(always_ff_clock_opt_group_0_built);
        self.push(
            ASTType::AlwaysFfClockOptGroup(always_ff_clock_opt_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 403:
    ///
    /// AlwaysFfClockOptGroup: Negedge;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_clock_opt_group_1(
        &mut self,
        _negedge: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let negedge = pop_item!(self, negedge, Negedge, context);
        let always_ff_clock_opt_group_1_built = AlwaysFfClockOptGroupNegedgeBuilder::default()
            .negedge(Box::new(negedge))
            .build()
            .into_diagnostic()?;
        let always_ff_clock_opt_group_1_built =
            AlwaysFfClockOptGroup::Negedge(always_ff_clock_opt_group_1_built);
        self.push(
            ASTType::AlwaysFfClockOptGroup(always_ff_clock_opt_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 404:
    ///
    /// AlwaysFfClockOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_clock_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::AlwaysFfClockOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 405:
    ///
    /// AlwaysFfReset: AlwaysFfResetOpt /* Option */ HierarchicalIdentifier;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_reset(
        &mut self,
        _always_ff_reset_opt: &ParseTreeStackEntry<'t>,
        _hierarchical_identifier: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let hierarchical_identifier = pop_item!(
            self,
            hierarchical_identifier,
            HierarchicalIdentifier,
            context
        );
        let always_ff_reset_opt = pop_item!(self, always_ff_reset_opt, AlwaysFfResetOpt, context);
        let always_ff_reset_built = AlwaysFfResetBuilder::default()
            .always_ff_reset_opt(always_ff_reset_opt)
            .hierarchical_identifier(Box::new(hierarchical_identifier))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.always_ff_reset(&always_ff_reset_built)?;
        self.push(ASTType::AlwaysFfReset(always_ff_reset_built), context);
        Ok(())
    }

    /// Semantic action for production 406:
    ///
    /// AlwaysFfResetOpt /* Option<T>::Some */: AlwaysFfResetOptGroup;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_reset_opt_0(
        &mut self,
        _always_ff_reset_opt_group: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let always_ff_reset_opt_group = pop_item!(
            self,
            always_ff_reset_opt_group,
            AlwaysFfResetOptGroup,
            context
        );
        let always_ff_reset_opt_0_built = AlwaysFfResetOptBuilder::default()
            .always_ff_reset_opt_group(Box::new(always_ff_reset_opt_group))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::AlwaysFfResetOpt(Some(Box::new(always_ff_reset_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 407:
    ///
    /// AlwaysFfResetOptGroup: AsyncLow;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_reset_opt_group_0(
        &mut self,
        _async_low: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let async_low = pop_item!(self, async_low, AsyncLow, context);
        let always_ff_reset_opt_group_0_built = AlwaysFfResetOptGroupAsyncLowBuilder::default()
            .async_low(Box::new(async_low))
            .build()
            .into_diagnostic()?;
        let always_ff_reset_opt_group_0_built =
            AlwaysFfResetOptGroup::AsyncLow(always_ff_reset_opt_group_0_built);
        self.push(
            ASTType::AlwaysFfResetOptGroup(always_ff_reset_opt_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 408:
    ///
    /// AlwaysFfResetOptGroup: AsyncHigh;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_reset_opt_group_1(
        &mut self,
        _async_high: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let async_high = pop_item!(self, async_high, AsyncHigh, context);
        let always_ff_reset_opt_group_1_built = AlwaysFfResetOptGroupAsyncHighBuilder::default()
            .async_high(Box::new(async_high))
            .build()
            .into_diagnostic()?;
        let always_ff_reset_opt_group_1_built =
            AlwaysFfResetOptGroup::AsyncHigh(always_ff_reset_opt_group_1_built);
        self.push(
            ASTType::AlwaysFfResetOptGroup(always_ff_reset_opt_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 409:
    ///
    /// AlwaysFfResetOptGroup: SyncLow;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_reset_opt_group_2(
        &mut self,
        _sync_low: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let sync_low = pop_item!(self, sync_low, SyncLow, context);
        let always_ff_reset_opt_group_2_built = AlwaysFfResetOptGroupSyncLowBuilder::default()
            .sync_low(Box::new(sync_low))
            .build()
            .into_diagnostic()?;
        let always_ff_reset_opt_group_2_built =
            AlwaysFfResetOptGroup::SyncLow(always_ff_reset_opt_group_2_built);
        self.push(
            ASTType::AlwaysFfResetOptGroup(always_ff_reset_opt_group_2_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 410:
    ///
    /// AlwaysFfResetOptGroup: SyncHigh;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_reset_opt_group_3(
        &mut self,
        _sync_high: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let sync_high = pop_item!(self, sync_high, SyncHigh, context);
        let always_ff_reset_opt_group_3_built = AlwaysFfResetOptGroupSyncHighBuilder::default()
            .sync_high(Box::new(sync_high))
            .build()
            .into_diagnostic()?;
        let always_ff_reset_opt_group_3_built =
            AlwaysFfResetOptGroup::SyncHigh(always_ff_reset_opt_group_3_built);
        self.push(
            ASTType::AlwaysFfResetOptGroup(always_ff_reset_opt_group_3_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 411:
    ///
    /// AlwaysFfResetOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_reset_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::AlwaysFfResetOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 412:
    ///
    /// AlwaysCombDeclaration: AlwaysComb LBrace AlwaysCombDeclarationList /* Vec */ RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn always_comb_declaration(
        &mut self,
        _always_comb: &ParseTreeStackEntry<'t>,
        _l_brace: &ParseTreeStackEntry<'t>,
        _always_comb_declaration_list: &ParseTreeStackEntry<'t>,
        _r_brace: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let always_comb_declaration_list = pop_and_reverse_item!(
            self,
            always_comb_declaration_list,
            AlwaysCombDeclarationList,
            context
        );
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let always_comb = pop_item!(self, always_comb, AlwaysComb, context);
        let always_comb_declaration_built = AlwaysCombDeclarationBuilder::default()
            .always_comb(Box::new(always_comb))
            .l_brace(Box::new(l_brace))
            .always_comb_declaration_list(always_comb_declaration_list)
            .r_brace(Box::new(r_brace))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .always_comb_declaration(&always_comb_declaration_built)?;
        self.push(
            ASTType::AlwaysCombDeclaration(always_comb_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 413:
    ///
    /// AlwaysCombDeclarationList /* Vec<T>::Push */: Statement AlwaysCombDeclarationList;
    ///
    #[parol_runtime::function_name::named]
    fn always_comb_declaration_list_0(
        &mut self,
        _statement: &ParseTreeStackEntry<'t>,
        _always_comb_declaration_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut always_comb_declaration_list = pop_item!(
            self,
            always_comb_declaration_list,
            AlwaysCombDeclarationList,
            context
        );
        let statement = pop_item!(self, statement, Statement, context);
        let always_comb_declaration_list_0_built = AlwaysCombDeclarationListBuilder::default()
            .statement(Box::new(statement))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        always_comb_declaration_list.push(always_comb_declaration_list_0_built);
        self.push(
            ASTType::AlwaysCombDeclarationList(always_comb_declaration_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 414:
    ///
    /// AlwaysCombDeclarationList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn always_comb_declaration_list_1(
        &mut self,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let always_comb_declaration_list_1_built = Vec::new();
        self.push(
            ASTType::AlwaysCombDeclarationList(always_comb_declaration_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 415:
    ///
    /// AssignDeclaration: Assign HierarchicalIdentifier Equ Expression Semicolon;
    ///
    #[parol_runtime::function_name::named]
    fn assign_declaration(
        &mut self,
        _assign: &ParseTreeStackEntry<'t>,
        _hierarchical_identifier: &ParseTreeStackEntry<'t>,
        _equ: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _semicolon: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon = pop_item!(self, semicolon, Semicolon, context);
        let expression = pop_item!(self, expression, Expression, context);
        let equ = pop_item!(self, equ, Equ, context);
        let hierarchical_identifier = pop_item!(
            self,
            hierarchical_identifier,
            HierarchicalIdentifier,
            context
        );
        let assign = pop_item!(self, assign, Assign, context);
        let assign_declaration_built = AssignDeclarationBuilder::default()
            .assign(Box::new(assign))
            .hierarchical_identifier(Box::new(hierarchical_identifier))
            .equ(Box::new(equ))
            .expression(Box::new(expression))
            .semicolon(Box::new(semicolon))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .assign_declaration(&assign_declaration_built)?;
        self.push(
            ASTType::AssignDeclaration(assign_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 416:
    ///
    /// ModportDeclaration: Modport Identifier LBrace ModportList RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn modport_declaration(
        &mut self,
        _modport: &ParseTreeStackEntry<'t>,
        _identifier: &ParseTreeStackEntry<'t>,
        _l_brace: &ParseTreeStackEntry<'t>,
        _modport_list: &ParseTreeStackEntry<'t>,
        _r_brace: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let modport_list = pop_item!(self, modport_list, ModportList, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let modport = pop_item!(self, modport, Modport, context);
        let modport_declaration_built = ModportDeclarationBuilder::default()
            .modport(Box::new(modport))
            .identifier(Box::new(identifier))
            .l_brace(Box::new(l_brace))
            .modport_list(Box::new(modport_list))
            .r_brace(Box::new(r_brace))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .modport_declaration(&modport_declaration_built)?;
        self.push(
            ASTType::ModportDeclaration(modport_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 417:
    ///
    /// ModportList: ModportItem ModportListList /* Vec */ ModportListOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn modport_list(
        &mut self,
        _modport_item: &ParseTreeStackEntry<'t>,
        _modport_list_list: &ParseTreeStackEntry<'t>,
        _modport_list_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let modport_list_opt = pop_item!(self, modport_list_opt, ModportListOpt, context);
        let modport_list_list =
            pop_and_reverse_item!(self, modport_list_list, ModportListList, context);
        let modport_item = pop_item!(self, modport_item, ModportItem, context);
        let modport_list_built = ModportListBuilder::default()
            .modport_item(Box::new(modport_item))
            .modport_list_list(modport_list_list)
            .modport_list_opt(modport_list_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.modport_list(&modport_list_built)?;
        self.push(ASTType::ModportList(modport_list_built), context);
        Ok(())
    }

    /// Semantic action for production 418:
    ///
    /// ModportListList /* Vec<T>::Push */: Comma ModportItem ModportListList;
    ///
    #[parol_runtime::function_name::named]
    fn modport_list_list_0(
        &mut self,
        _comma: &ParseTreeStackEntry<'t>,
        _modport_item: &ParseTreeStackEntry<'t>,
        _modport_list_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut modport_list_list = pop_item!(self, modport_list_list, ModportListList, context);
        let modport_item = pop_item!(self, modport_item, ModportItem, context);
        let comma = pop_item!(self, comma, Comma, context);
        let modport_list_list_0_built = ModportListListBuilder::default()
            .modport_item(Box::new(modport_item))
            .comma(Box::new(comma))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        modport_list_list.push(modport_list_list_0_built);
        self.push(ASTType::ModportListList(modport_list_list), context);
        Ok(())
    }

    /// Semantic action for production 419:
    ///
    /// ModportListList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn modport_list_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let modport_list_list_1_built = Vec::new();
        self.push(ASTType::ModportListList(modport_list_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 420:
    ///
    /// ModportListOpt /* Option<T>::Some */: Comma;
    ///
    #[parol_runtime::function_name::named]
    fn modport_list_opt_0(
        &mut self,
        _comma: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = pop_item!(self, comma, Comma, context);
        let modport_list_opt_0_built = ModportListOptBuilder::default()
            .comma(Box::new(comma))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::ModportListOpt(Some(Box::new(modport_list_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 421:
    ///
    /// ModportListOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn modport_list_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ModportListOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 422:
    ///
    /// ModportItem: Identifier Colon Direction;
    ///
    #[parol_runtime::function_name::named]
    fn modport_item(
        &mut self,
        _identifier: &ParseTreeStackEntry<'t>,
        _colon: &ParseTreeStackEntry<'t>,
        _direction: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let direction = pop_item!(self, direction, Direction, context);
        let colon = pop_item!(self, colon, Colon, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let modport_item_built = ModportItemBuilder::default()
            .identifier(Box::new(identifier))
            .colon(Box::new(colon))
            .direction(Box::new(direction))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.modport_item(&modport_item_built)?;
        self.push(ASTType::ModportItem(modport_item_built), context);
        Ok(())
    }

    /// Semantic action for production 423:
    ///
    /// EnumDeclaration: Enum Identifier Colon Type LBrace EnumList RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn enum_declaration(
        &mut self,
        _enum: &ParseTreeStackEntry<'t>,
        _identifier: &ParseTreeStackEntry<'t>,
        _colon: &ParseTreeStackEntry<'t>,
        _type: &ParseTreeStackEntry<'t>,
        _l_brace: &ParseTreeStackEntry<'t>,
        _enum_list: &ParseTreeStackEntry<'t>,
        _r_brace: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let enum_list = pop_item!(self, enum_list, EnumList, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let r#type = pop_item!(self, r#type, Type, context);
        let colon = pop_item!(self, colon, Colon, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let r#enum = pop_item!(self, r#enum, Enum, context);
        let enum_declaration_built = EnumDeclarationBuilder::default()
            .r#enum(Box::new(r#enum))
            .identifier(Box::new(identifier))
            .colon(Box::new(colon))
            .r#type(Box::new(r#type))
            .l_brace(Box::new(l_brace))
            .enum_list(Box::new(enum_list))
            .r_brace(Box::new(r_brace))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .enum_declaration(&enum_declaration_built)?;
        self.push(ASTType::EnumDeclaration(enum_declaration_built), context);
        Ok(())
    }

    /// Semantic action for production 424:
    ///
    /// EnumList: EnumItem EnumListList /* Vec */ EnumListOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn enum_list(
        &mut self,
        _enum_item: &ParseTreeStackEntry<'t>,
        _enum_list_list: &ParseTreeStackEntry<'t>,
        _enum_list_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let enum_list_opt = pop_item!(self, enum_list_opt, EnumListOpt, context);
        let enum_list_list = pop_and_reverse_item!(self, enum_list_list, EnumListList, context);
        let enum_item = pop_item!(self, enum_item, EnumItem, context);
        let enum_list_built = EnumListBuilder::default()
            .enum_item(Box::new(enum_item))
            .enum_list_list(enum_list_list)
            .enum_list_opt(enum_list_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.enum_list(&enum_list_built)?;
        self.push(ASTType::EnumList(enum_list_built), context);
        Ok(())
    }

    /// Semantic action for production 425:
    ///
    /// EnumListList /* Vec<T>::Push */: Comma EnumItem EnumListList;
    ///
    #[parol_runtime::function_name::named]
    fn enum_list_list_0(
        &mut self,
        _comma: &ParseTreeStackEntry<'t>,
        _enum_item: &ParseTreeStackEntry<'t>,
        _enum_list_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut enum_list_list = pop_item!(self, enum_list_list, EnumListList, context);
        let enum_item = pop_item!(self, enum_item, EnumItem, context);
        let comma = pop_item!(self, comma, Comma, context);
        let enum_list_list_0_built = EnumListListBuilder::default()
            .enum_item(Box::new(enum_item))
            .comma(Box::new(comma))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        enum_list_list.push(enum_list_list_0_built);
        self.push(ASTType::EnumListList(enum_list_list), context);
        Ok(())
    }

    /// Semantic action for production 426:
    ///
    /// EnumListList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn enum_list_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let enum_list_list_1_built = Vec::new();
        self.push(ASTType::EnumListList(enum_list_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 427:
    ///
    /// EnumListOpt /* Option<T>::Some */: Comma;
    ///
    #[parol_runtime::function_name::named]
    fn enum_list_opt_0(
        &mut self,
        _comma: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = pop_item!(self, comma, Comma, context);
        let enum_list_opt_0_built = EnumListOptBuilder::default()
            .comma(Box::new(comma))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::EnumListOpt(Some(Box::new(enum_list_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 428:
    ///
    /// EnumListOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn enum_list_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::EnumListOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 429:
    ///
    /// EnumItem: Identifier EnumItemOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn enum_item(
        &mut self,
        _identifier: &ParseTreeStackEntry<'t>,
        _enum_item_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let enum_item_opt = pop_item!(self, enum_item_opt, EnumItemOpt, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let enum_item_built = EnumItemBuilder::default()
            .identifier(Box::new(identifier))
            .enum_item_opt(enum_item_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.enum_item(&enum_item_built)?;
        self.push(ASTType::EnumItem(enum_item_built), context);
        Ok(())
    }

    /// Semantic action for production 430:
    ///
    /// EnumItemOpt /* Option<T>::Some */: Equ Expression;
    ///
    #[parol_runtime::function_name::named]
    fn enum_item_opt_0(
        &mut self,
        _equ: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = pop_item!(self, expression, Expression, context);
        let equ = pop_item!(self, equ, Equ, context);
        let enum_item_opt_0_built = EnumItemOptBuilder::default()
            .equ(Box::new(equ))
            .expression(Box::new(expression))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::EnumItemOpt(Some(Box::new(enum_item_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 431:
    ///
    /// EnumItemOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn enum_item_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::EnumItemOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 432:
    ///
    /// StructDeclaration: Struct Identifier LBrace StructList RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn struct_declaration(
        &mut self,
        _struct: &ParseTreeStackEntry<'t>,
        _identifier: &ParseTreeStackEntry<'t>,
        _l_brace: &ParseTreeStackEntry<'t>,
        _struct_list: &ParseTreeStackEntry<'t>,
        _r_brace: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let struct_list = pop_item!(self, struct_list, StructList, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let r#struct = pop_item!(self, r#struct, Struct, context);
        let struct_declaration_built = StructDeclarationBuilder::default()
            .r#struct(Box::new(r#struct))
            .identifier(Box::new(identifier))
            .l_brace(Box::new(l_brace))
            .struct_list(Box::new(struct_list))
            .r_brace(Box::new(r_brace))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .struct_declaration(&struct_declaration_built)?;
        self.push(
            ASTType::StructDeclaration(struct_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 433:
    ///
    /// StructList: StructItem StructListList /* Vec */ StructListOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn struct_list(
        &mut self,
        _struct_item: &ParseTreeStackEntry<'t>,
        _struct_list_list: &ParseTreeStackEntry<'t>,
        _struct_list_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let struct_list_opt = pop_item!(self, struct_list_opt, StructListOpt, context);
        let struct_list_list =
            pop_and_reverse_item!(self, struct_list_list, StructListList, context);
        let struct_item = pop_item!(self, struct_item, StructItem, context);
        let struct_list_built = StructListBuilder::default()
            .struct_item(Box::new(struct_item))
            .struct_list_list(struct_list_list)
            .struct_list_opt(struct_list_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.struct_list(&struct_list_built)?;
        self.push(ASTType::StructList(struct_list_built), context);
        Ok(())
    }

    /// Semantic action for production 434:
    ///
    /// StructListList /* Vec<T>::Push */: Comma StructItem StructListList;
    ///
    #[parol_runtime::function_name::named]
    fn struct_list_list_0(
        &mut self,
        _comma: &ParseTreeStackEntry<'t>,
        _struct_item: &ParseTreeStackEntry<'t>,
        _struct_list_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut struct_list_list = pop_item!(self, struct_list_list, StructListList, context);
        let struct_item = pop_item!(self, struct_item, StructItem, context);
        let comma = pop_item!(self, comma, Comma, context);
        let struct_list_list_0_built = StructListListBuilder::default()
            .struct_item(Box::new(struct_item))
            .comma(Box::new(comma))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        struct_list_list.push(struct_list_list_0_built);
        self.push(ASTType::StructListList(struct_list_list), context);
        Ok(())
    }

    /// Semantic action for production 435:
    ///
    /// StructListList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn struct_list_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let struct_list_list_1_built = Vec::new();
        self.push(ASTType::StructListList(struct_list_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 436:
    ///
    /// StructListOpt /* Option<T>::Some */: Comma;
    ///
    #[parol_runtime::function_name::named]
    fn struct_list_opt_0(
        &mut self,
        _comma: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = pop_item!(self, comma, Comma, context);
        let struct_list_opt_0_built = StructListOptBuilder::default()
            .comma(Box::new(comma))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::StructListOpt(Some(Box::new(struct_list_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 437:
    ///
    /// StructListOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn struct_list_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::StructListOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 438:
    ///
    /// StructItem: Identifier Colon Type;
    ///
    #[parol_runtime::function_name::named]
    fn struct_item(
        &mut self,
        _identifier: &ParseTreeStackEntry<'t>,
        _colon: &ParseTreeStackEntry<'t>,
        _type: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#type = pop_item!(self, r#type, Type, context);
        let colon = pop_item!(self, colon, Colon, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let struct_item_built = StructItemBuilder::default()
            .identifier(Box::new(identifier))
            .colon(Box::new(colon))
            .r#type(Box::new(r#type))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.struct_item(&struct_item_built)?;
        self.push(ASTType::StructItem(struct_item_built), context);
        Ok(())
    }

    /// Semantic action for production 439:
    ///
    /// InstDeclaration: Inst Identifier Colon Identifier InstDeclarationOpt /* Option */ InstDeclarationOpt0 /* Option */ InstDeclarationOpt1 /* Option */ Semicolon;
    ///
    #[parol_runtime::function_name::named]
    fn inst_declaration(
        &mut self,
        _inst: &ParseTreeStackEntry<'t>,
        _identifier: &ParseTreeStackEntry<'t>,
        _colon: &ParseTreeStackEntry<'t>,
        _identifier0: &ParseTreeStackEntry<'t>,
        _inst_declaration_opt: &ParseTreeStackEntry<'t>,
        _inst_declaration_opt0: &ParseTreeStackEntry<'t>,
        _inst_declaration_opt1: &ParseTreeStackEntry<'t>,
        _semicolon: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon = pop_item!(self, semicolon, Semicolon, context);
        let inst_declaration_opt1 =
            pop_item!(self, inst_declaration_opt1, InstDeclarationOpt1, context);
        let inst_declaration_opt0 =
            pop_item!(self, inst_declaration_opt0, InstDeclarationOpt0, context);
        let inst_declaration_opt =
            pop_item!(self, inst_declaration_opt, InstDeclarationOpt, context);
        let identifier0 = pop_item!(self, identifier0, Identifier, context);
        let colon = pop_item!(self, colon, Colon, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let inst = pop_item!(self, inst, Inst, context);
        let inst_declaration_built = InstDeclarationBuilder::default()
            .inst(Box::new(inst))
            .identifier(Box::new(identifier))
            .colon(Box::new(colon))
            .identifier0(Box::new(identifier0))
            .inst_declaration_opt(inst_declaration_opt)
            .inst_declaration_opt0(inst_declaration_opt0)
            .inst_declaration_opt1(inst_declaration_opt1)
            .semicolon(Box::new(semicolon))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .inst_declaration(&inst_declaration_built)?;
        self.push(ASTType::InstDeclaration(inst_declaration_built), context);
        Ok(())
    }

    /// Semantic action for production 440:
    ///
    /// InstDeclarationOpt1 /* Option<T>::Some */: LBrace InstDeclarationOpt2 /* Option */ RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn inst_declaration_opt1_0(
        &mut self,
        _l_brace: &ParseTreeStackEntry<'t>,
        _inst_declaration_opt2: &ParseTreeStackEntry<'t>,
        _r_brace: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let inst_declaration_opt2 =
            pop_item!(self, inst_declaration_opt2, InstDeclarationOpt2, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let inst_declaration_opt1_0_built = InstDeclarationOpt1Builder::default()
            .l_brace(Box::new(l_brace))
            .inst_declaration_opt2(inst_declaration_opt2)
            .r_brace(Box::new(r_brace))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::InstDeclarationOpt1(Some(Box::new(inst_declaration_opt1_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 441:
    ///
    /// InstDeclarationOpt2 /* Option<T>::Some */: InstPortList;
    ///
    #[parol_runtime::function_name::named]
    fn inst_declaration_opt2_0(
        &mut self,
        _inst_port_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inst_port_list = pop_item!(self, inst_port_list, InstPortList, context);
        let inst_declaration_opt2_0_built = InstDeclarationOpt2Builder::default()
            .inst_port_list(Box::new(inst_port_list))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::InstDeclarationOpt2(Some(Box::new(inst_declaration_opt2_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 442:
    ///
    /// InstDeclarationOpt2 /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn inst_declaration_opt2_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::InstDeclarationOpt2(None), context);
        Ok(())
    }

    /// Semantic action for production 443:
    ///
    /// InstDeclarationOpt1 /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn inst_declaration_opt1_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::InstDeclarationOpt1(None), context);
        Ok(())
    }

    /// Semantic action for production 444:
    ///
    /// InstDeclarationOpt0 /* Option<T>::Some */: InstParameter;
    ///
    #[parol_runtime::function_name::named]
    fn inst_declaration_opt0_0(
        &mut self,
        _inst_parameter: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inst_parameter = pop_item!(self, inst_parameter, InstParameter, context);
        let inst_declaration_opt0_0_built = InstDeclarationOpt0Builder::default()
            .inst_parameter(Box::new(inst_parameter))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::InstDeclarationOpt0(Some(Box::new(inst_declaration_opt0_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 445:
    ///
    /// InstDeclarationOpt0 /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn inst_declaration_opt0_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::InstDeclarationOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 446:
    ///
    /// InstDeclarationOpt /* Option<T>::Some */: Width;
    ///
    #[parol_runtime::function_name::named]
    fn inst_declaration_opt_0(
        &mut self,
        _width: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let width = pop_item!(self, width, Width, context);
        let inst_declaration_opt_0_built = InstDeclarationOptBuilder::default()
            .width(Box::new(width))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::InstDeclarationOpt(Some(Box::new(inst_declaration_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 447:
    ///
    /// InstDeclarationOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn inst_declaration_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::InstDeclarationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 448:
    ///
    /// InstParameter: Hash LParen InstParameterOpt /* Option */ RParen;
    ///
    #[parol_runtime::function_name::named]
    fn inst_parameter(
        &mut self,
        _hash: &ParseTreeStackEntry<'t>,
        _l_paren: &ParseTreeStackEntry<'t>,
        _inst_parameter_opt: &ParseTreeStackEntry<'t>,
        _r_paren: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren = pop_item!(self, r_paren, RParen, context);
        let inst_parameter_opt = pop_item!(self, inst_parameter_opt, InstParameterOpt, context);
        let l_paren = pop_item!(self, l_paren, LParen, context);
        let hash = pop_item!(self, hash, Hash, context);
        let inst_parameter_built = InstParameterBuilder::default()
            .hash(Box::new(hash))
            .l_paren(Box::new(l_paren))
            .inst_parameter_opt(inst_parameter_opt)
            .r_paren(Box::new(r_paren))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.inst_parameter(&inst_parameter_built)?;
        self.push(ASTType::InstParameter(inst_parameter_built), context);
        Ok(())
    }

    /// Semantic action for production 449:
    ///
    /// InstParameterOpt /* Option<T>::Some */: InstParameterList;
    ///
    #[parol_runtime::function_name::named]
    fn inst_parameter_opt_0(
        &mut self,
        _inst_parameter_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inst_parameter_list = pop_item!(self, inst_parameter_list, InstParameterList, context);
        let inst_parameter_opt_0_built = InstParameterOptBuilder::default()
            .inst_parameter_list(Box::new(inst_parameter_list))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::InstParameterOpt(Some(Box::new(inst_parameter_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 450:
    ///
    /// InstParameterOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn inst_parameter_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::InstParameterOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 451:
    ///
    /// InstParameterList: InstParameterItem InstParameterListList /* Vec */ InstParameterListOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn inst_parameter_list(
        &mut self,
        _inst_parameter_item: &ParseTreeStackEntry<'t>,
        _inst_parameter_list_list: &ParseTreeStackEntry<'t>,
        _inst_parameter_list_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inst_parameter_list_opt =
            pop_item!(self, inst_parameter_list_opt, InstParameterListOpt, context);
        let inst_parameter_list_list = pop_and_reverse_item!(
            self,
            inst_parameter_list_list,
            InstParameterListList,
            context
        );
        let inst_parameter_item = pop_item!(self, inst_parameter_item, InstParameterItem, context);
        let inst_parameter_list_built = InstParameterListBuilder::default()
            .inst_parameter_item(Box::new(inst_parameter_item))
            .inst_parameter_list_list(inst_parameter_list_list)
            .inst_parameter_list_opt(inst_parameter_list_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .inst_parameter_list(&inst_parameter_list_built)?;
        self.push(
            ASTType::InstParameterList(inst_parameter_list_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 452:
    ///
    /// InstParameterListList /* Vec<T>::Push */: Comma InstParameterItem InstParameterListList;
    ///
    #[parol_runtime::function_name::named]
    fn inst_parameter_list_list_0(
        &mut self,
        _comma: &ParseTreeStackEntry<'t>,
        _inst_parameter_item: &ParseTreeStackEntry<'t>,
        _inst_parameter_list_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut inst_parameter_list_list = pop_item!(
            self,
            inst_parameter_list_list,
            InstParameterListList,
            context
        );
        let inst_parameter_item = pop_item!(self, inst_parameter_item, InstParameterItem, context);
        let comma = pop_item!(self, comma, Comma, context);
        let inst_parameter_list_list_0_built = InstParameterListListBuilder::default()
            .inst_parameter_item(Box::new(inst_parameter_item))
            .comma(Box::new(comma))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        inst_parameter_list_list.push(inst_parameter_list_list_0_built);
        self.push(
            ASTType::InstParameterListList(inst_parameter_list_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 453:
    ///
    /// InstParameterListList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn inst_parameter_list_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inst_parameter_list_list_1_built = Vec::new();
        self.push(
            ASTType::InstParameterListList(inst_parameter_list_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 454:
    ///
    /// InstParameterListOpt /* Option<T>::Some */: Comma;
    ///
    #[parol_runtime::function_name::named]
    fn inst_parameter_list_opt_0(
        &mut self,
        _comma: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = pop_item!(self, comma, Comma, context);
        let inst_parameter_list_opt_0_built = InstParameterListOptBuilder::default()
            .comma(Box::new(comma))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::InstParameterListOpt(Some(Box::new(inst_parameter_list_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 455:
    ///
    /// InstParameterListOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn inst_parameter_list_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::InstParameterListOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 456:
    ///
    /// InstParameterItem: Identifier InstParameterItemOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn inst_parameter_item(
        &mut self,
        _identifier: &ParseTreeStackEntry<'t>,
        _inst_parameter_item_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inst_parameter_item_opt =
            pop_item!(self, inst_parameter_item_opt, InstParameterItemOpt, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let inst_parameter_item_built = InstParameterItemBuilder::default()
            .identifier(Box::new(identifier))
            .inst_parameter_item_opt(inst_parameter_item_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .inst_parameter_item(&inst_parameter_item_built)?;
        self.push(
            ASTType::InstParameterItem(inst_parameter_item_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 457:
    ///
    /// InstParameterItemOpt /* Option<T>::Some */: Colon Expression;
    ///
    #[parol_runtime::function_name::named]
    fn inst_parameter_item_opt_0(
        &mut self,
        _colon: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = pop_item!(self, expression, Expression, context);
        let colon = pop_item!(self, colon, Colon, context);
        let inst_parameter_item_opt_0_built = InstParameterItemOptBuilder::default()
            .colon(Box::new(colon))
            .expression(Box::new(expression))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::InstParameterItemOpt(Some(Box::new(inst_parameter_item_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 458:
    ///
    /// InstParameterItemOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn inst_parameter_item_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::InstParameterItemOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 459:
    ///
    /// InstPortList: InstPortItem InstPortListList /* Vec */ InstPortListOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn inst_port_list(
        &mut self,
        _inst_port_item: &ParseTreeStackEntry<'t>,
        _inst_port_list_list: &ParseTreeStackEntry<'t>,
        _inst_port_list_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inst_port_list_opt = pop_item!(self, inst_port_list_opt, InstPortListOpt, context);
        let inst_port_list_list =
            pop_and_reverse_item!(self, inst_port_list_list, InstPortListList, context);
        let inst_port_item = pop_item!(self, inst_port_item, InstPortItem, context);
        let inst_port_list_built = InstPortListBuilder::default()
            .inst_port_item(Box::new(inst_port_item))
            .inst_port_list_list(inst_port_list_list)
            .inst_port_list_opt(inst_port_list_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.inst_port_list(&inst_port_list_built)?;
        self.push(ASTType::InstPortList(inst_port_list_built), context);
        Ok(())
    }

    /// Semantic action for production 460:
    ///
    /// InstPortListList /* Vec<T>::Push */: Comma InstPortItem InstPortListList;
    ///
    #[parol_runtime::function_name::named]
    fn inst_port_list_list_0(
        &mut self,
        _comma: &ParseTreeStackEntry<'t>,
        _inst_port_item: &ParseTreeStackEntry<'t>,
        _inst_port_list_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut inst_port_list_list =
            pop_item!(self, inst_port_list_list, InstPortListList, context);
        let inst_port_item = pop_item!(self, inst_port_item, InstPortItem, context);
        let comma = pop_item!(self, comma, Comma, context);
        let inst_port_list_list_0_built = InstPortListListBuilder::default()
            .inst_port_item(Box::new(inst_port_item))
            .comma(Box::new(comma))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        inst_port_list_list.push(inst_port_list_list_0_built);
        self.push(ASTType::InstPortListList(inst_port_list_list), context);
        Ok(())
    }

    /// Semantic action for production 461:
    ///
    /// InstPortListList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn inst_port_list_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inst_port_list_list_1_built = Vec::new();
        self.push(
            ASTType::InstPortListList(inst_port_list_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 462:
    ///
    /// InstPortListOpt /* Option<T>::Some */: Comma;
    ///
    #[parol_runtime::function_name::named]
    fn inst_port_list_opt_0(
        &mut self,
        _comma: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = pop_item!(self, comma, Comma, context);
        let inst_port_list_opt_0_built = InstPortListOptBuilder::default()
            .comma(Box::new(comma))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::InstPortListOpt(Some(Box::new(inst_port_list_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 463:
    ///
    /// InstPortListOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn inst_port_list_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::InstPortListOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 464:
    ///
    /// InstPortItem: Identifier InstPortItemOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn inst_port_item(
        &mut self,
        _identifier: &ParseTreeStackEntry<'t>,
        _inst_port_item_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inst_port_item_opt = pop_item!(self, inst_port_item_opt, InstPortItemOpt, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let inst_port_item_built = InstPortItemBuilder::default()
            .identifier(Box::new(identifier))
            .inst_port_item_opt(inst_port_item_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.inst_port_item(&inst_port_item_built)?;
        self.push(ASTType::InstPortItem(inst_port_item_built), context);
        Ok(())
    }

    /// Semantic action for production 465:
    ///
    /// InstPortItemOpt /* Option<T>::Some */: Colon Expression;
    ///
    #[parol_runtime::function_name::named]
    fn inst_port_item_opt_0(
        &mut self,
        _colon: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = pop_item!(self, expression, Expression, context);
        let colon = pop_item!(self, colon, Colon, context);
        let inst_port_item_opt_0_built = InstPortItemOptBuilder::default()
            .colon(Box::new(colon))
            .expression(Box::new(expression))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::InstPortItemOpt(Some(Box::new(inst_port_item_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 466:
    ///
    /// InstPortItemOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn inst_port_item_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::InstPortItemOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 467:
    ///
    /// WithParameter: Hash LParen WithParameterOpt /* Option */ RParen;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter(
        &mut self,
        _hash: &ParseTreeStackEntry<'t>,
        _l_paren: &ParseTreeStackEntry<'t>,
        _with_parameter_opt: &ParseTreeStackEntry<'t>,
        _r_paren: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren = pop_item!(self, r_paren, RParen, context);
        let with_parameter_opt = pop_item!(self, with_parameter_opt, WithParameterOpt, context);
        let l_paren = pop_item!(self, l_paren, LParen, context);
        let hash = pop_item!(self, hash, Hash, context);
        let with_parameter_built = WithParameterBuilder::default()
            .hash(Box::new(hash))
            .l_paren(Box::new(l_paren))
            .with_parameter_opt(with_parameter_opt)
            .r_paren(Box::new(r_paren))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.with_parameter(&with_parameter_built)?;
        self.push(ASTType::WithParameter(with_parameter_built), context);
        Ok(())
    }

    /// Semantic action for production 468:
    ///
    /// WithParameterOpt /* Option<T>::Some */: WithParameterList;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_opt_0(
        &mut self,
        _with_parameter_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let with_parameter_list = pop_item!(self, with_parameter_list, WithParameterList, context);
        let with_parameter_opt_0_built = WithParameterOptBuilder::default()
            .with_parameter_list(Box::new(with_parameter_list))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::WithParameterOpt(Some(Box::new(with_parameter_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 469:
    ///
    /// WithParameterOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::WithParameterOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 470:
    ///
    /// WithParameterList: WithParameterItem WithParameterListList /* Vec */ WithParameterListOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_list(
        &mut self,
        _with_parameter_item: &ParseTreeStackEntry<'t>,
        _with_parameter_list_list: &ParseTreeStackEntry<'t>,
        _with_parameter_list_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let with_parameter_list_opt =
            pop_item!(self, with_parameter_list_opt, WithParameterListOpt, context);
        let with_parameter_list_list = pop_and_reverse_item!(
            self,
            with_parameter_list_list,
            WithParameterListList,
            context
        );
        let with_parameter_item = pop_item!(self, with_parameter_item, WithParameterItem, context);
        let with_parameter_list_built = WithParameterListBuilder::default()
            .with_parameter_item(Box::new(with_parameter_item))
            .with_parameter_list_list(with_parameter_list_list)
            .with_parameter_list_opt(with_parameter_list_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .with_parameter_list(&with_parameter_list_built)?;
        self.push(
            ASTType::WithParameterList(with_parameter_list_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 471:
    ///
    /// WithParameterListList /* Vec<T>::Push */: Comma WithParameterItem WithParameterListList;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_list_list_0(
        &mut self,
        _comma: &ParseTreeStackEntry<'t>,
        _with_parameter_item: &ParseTreeStackEntry<'t>,
        _with_parameter_list_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut with_parameter_list_list = pop_item!(
            self,
            with_parameter_list_list,
            WithParameterListList,
            context
        );
        let with_parameter_item = pop_item!(self, with_parameter_item, WithParameterItem, context);
        let comma = pop_item!(self, comma, Comma, context);
        let with_parameter_list_list_0_built = WithParameterListListBuilder::default()
            .with_parameter_item(Box::new(with_parameter_item))
            .comma(Box::new(comma))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        with_parameter_list_list.push(with_parameter_list_list_0_built);
        self.push(
            ASTType::WithParameterListList(with_parameter_list_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 472:
    ///
    /// WithParameterListList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_list_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let with_parameter_list_list_1_built = Vec::new();
        self.push(
            ASTType::WithParameterListList(with_parameter_list_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 473:
    ///
    /// WithParameterListOpt /* Option<T>::Some */: Comma;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_list_opt_0(
        &mut self,
        _comma: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = pop_item!(self, comma, Comma, context);
        let with_parameter_list_opt_0_built = WithParameterListOptBuilder::default()
            .comma(Box::new(comma))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::WithParameterListOpt(Some(Box::new(with_parameter_list_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 474:
    ///
    /// WithParameterListOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_list_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::WithParameterListOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 475:
    ///
    /// WithParameterItem: WithParameterItemGroup Identifier Colon Type Equ Expression;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_item(
        &mut self,
        _with_parameter_item_group: &ParseTreeStackEntry<'t>,
        _identifier: &ParseTreeStackEntry<'t>,
        _colon: &ParseTreeStackEntry<'t>,
        _type: &ParseTreeStackEntry<'t>,
        _equ: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = pop_item!(self, expression, Expression, context);
        let equ = pop_item!(self, equ, Equ, context);
        let r#type = pop_item!(self, r#type, Type, context);
        let colon = pop_item!(self, colon, Colon, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let with_parameter_item_group = pop_item!(
            self,
            with_parameter_item_group,
            WithParameterItemGroup,
            context
        );
        let with_parameter_item_built = WithParameterItemBuilder::default()
            .with_parameter_item_group(Box::new(with_parameter_item_group))
            .identifier(Box::new(identifier))
            .colon(Box::new(colon))
            .r#type(Box::new(r#type))
            .equ(Box::new(equ))
            .expression(Box::new(expression))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .with_parameter_item(&with_parameter_item_built)?;
        self.push(
            ASTType::WithParameterItem(with_parameter_item_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 476:
    ///
    /// WithParameterItemGroup: Parameter;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_item_group_0(
        &mut self,
        _parameter: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let parameter = pop_item!(self, parameter, Parameter, context);
        let with_parameter_item_group_0_built = WithParameterItemGroupParameterBuilder::default()
            .parameter(Box::new(parameter))
            .build()
            .into_diagnostic()?;
        let with_parameter_item_group_0_built =
            WithParameterItemGroup::Parameter(with_parameter_item_group_0_built);
        self.push(
            ASTType::WithParameterItemGroup(with_parameter_item_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 477:
    ///
    /// WithParameterItemGroup: Localparam;
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_item_group_1(
        &mut self,
        _localparam: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let localparam = pop_item!(self, localparam, Localparam, context);
        let with_parameter_item_group_1_built = WithParameterItemGroupLocalparamBuilder::default()
            .localparam(Box::new(localparam))
            .build()
            .into_diagnostic()?;
        let with_parameter_item_group_1_built =
            WithParameterItemGroup::Localparam(with_parameter_item_group_1_built);
        self.push(
            ASTType::WithParameterItemGroup(with_parameter_item_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 478:
    ///
    /// PortDeclaration: LParen PortDeclarationOpt /* Option */ RParen;
    ///
    #[parol_runtime::function_name::named]
    fn port_declaration(
        &mut self,
        _l_paren: &ParseTreeStackEntry<'t>,
        _port_declaration_opt: &ParseTreeStackEntry<'t>,
        _r_paren: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren = pop_item!(self, r_paren, RParen, context);
        let port_declaration_opt =
            pop_item!(self, port_declaration_opt, PortDeclarationOpt, context);
        let l_paren = pop_item!(self, l_paren, LParen, context);
        let port_declaration_built = PortDeclarationBuilder::default()
            .l_paren(Box::new(l_paren))
            .port_declaration_opt(port_declaration_opt)
            .r_paren(Box::new(r_paren))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .port_declaration(&port_declaration_built)?;
        self.push(ASTType::PortDeclaration(port_declaration_built), context);
        Ok(())
    }

    /// Semantic action for production 479:
    ///
    /// PortDeclarationOpt /* Option<T>::Some */: PortDeclarationList;
    ///
    #[parol_runtime::function_name::named]
    fn port_declaration_opt_0(
        &mut self,
        _port_declaration_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let port_declaration_list =
            pop_item!(self, port_declaration_list, PortDeclarationList, context);
        let port_declaration_opt_0_built = PortDeclarationOptBuilder::default()
            .port_declaration_list(Box::new(port_declaration_list))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::PortDeclarationOpt(Some(Box::new(port_declaration_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 480:
    ///
    /// PortDeclarationOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn port_declaration_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::PortDeclarationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 481:
    ///
    /// PortDeclarationList: PortDeclarationItem PortDeclarationListList /* Vec */ PortDeclarationListOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn port_declaration_list(
        &mut self,
        _port_declaration_item: &ParseTreeStackEntry<'t>,
        _port_declaration_list_list: &ParseTreeStackEntry<'t>,
        _port_declaration_list_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let port_declaration_list_opt = pop_item!(
            self,
            port_declaration_list_opt,
            PortDeclarationListOpt,
            context
        );
        let port_declaration_list_list = pop_and_reverse_item!(
            self,
            port_declaration_list_list,
            PortDeclarationListList,
            context
        );
        let port_declaration_item =
            pop_item!(self, port_declaration_item, PortDeclarationItem, context);
        let port_declaration_list_built = PortDeclarationListBuilder::default()
            .port_declaration_item(Box::new(port_declaration_item))
            .port_declaration_list_list(port_declaration_list_list)
            .port_declaration_list_opt(port_declaration_list_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .port_declaration_list(&port_declaration_list_built)?;
        self.push(
            ASTType::PortDeclarationList(port_declaration_list_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 482:
    ///
    /// PortDeclarationListList /* Vec<T>::Push */: Comma PortDeclarationItem PortDeclarationListList;
    ///
    #[parol_runtime::function_name::named]
    fn port_declaration_list_list_0(
        &mut self,
        _comma: &ParseTreeStackEntry<'t>,
        _port_declaration_item: &ParseTreeStackEntry<'t>,
        _port_declaration_list_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut port_declaration_list_list = pop_item!(
            self,
            port_declaration_list_list,
            PortDeclarationListList,
            context
        );
        let port_declaration_item =
            pop_item!(self, port_declaration_item, PortDeclarationItem, context);
        let comma = pop_item!(self, comma, Comma, context);
        let port_declaration_list_list_0_built = PortDeclarationListListBuilder::default()
            .port_declaration_item(Box::new(port_declaration_item))
            .comma(Box::new(comma))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        port_declaration_list_list.push(port_declaration_list_list_0_built);
        self.push(
            ASTType::PortDeclarationListList(port_declaration_list_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 483:
    ///
    /// PortDeclarationListList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn port_declaration_list_list_1(
        &mut self,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let port_declaration_list_list_1_built = Vec::new();
        self.push(
            ASTType::PortDeclarationListList(port_declaration_list_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 484:
    ///
    /// PortDeclarationListOpt /* Option<T>::Some */: Comma;
    ///
    #[parol_runtime::function_name::named]
    fn port_declaration_list_opt_0(
        &mut self,
        _comma: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = pop_item!(self, comma, Comma, context);
        let port_declaration_list_opt_0_built = PortDeclarationListOptBuilder::default()
            .comma(Box::new(comma))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::PortDeclarationListOpt(Some(Box::new(port_declaration_list_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 485:
    ///
    /// PortDeclarationListOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn port_declaration_list_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::PortDeclarationListOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 486:
    ///
    /// PortDeclarationItem: Identifier Colon Direction Type;
    ///
    #[parol_runtime::function_name::named]
    fn port_declaration_item(
        &mut self,
        _identifier: &ParseTreeStackEntry<'t>,
        _colon: &ParseTreeStackEntry<'t>,
        _direction: &ParseTreeStackEntry<'t>,
        _type: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#type = pop_item!(self, r#type, Type, context);
        let direction = pop_item!(self, direction, Direction, context);
        let colon = pop_item!(self, colon, Colon, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let port_declaration_item_built = PortDeclarationItemBuilder::default()
            .identifier(Box::new(identifier))
            .colon(Box::new(colon))
            .direction(Box::new(direction))
            .r#type(Box::new(r#type))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .port_declaration_item(&port_declaration_item_built)?;
        self.push(
            ASTType::PortDeclarationItem(port_declaration_item_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 487:
    ///
    /// Direction: Input;
    ///
    #[parol_runtime::function_name::named]
    fn direction_0(
        &mut self,
        _input: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let input = pop_item!(self, input, Input, context);
        let direction_0_built = DirectionInputBuilder::default()
            .input(Box::new(input))
            .build()
            .into_diagnostic()?;
        let direction_0_built = Direction::Input(direction_0_built);
        // Calling user action here
        self.user_grammar.direction(&direction_0_built)?;
        self.push(ASTType::Direction(direction_0_built), context);
        Ok(())
    }

    /// Semantic action for production 488:
    ///
    /// Direction: Output;
    ///
    #[parol_runtime::function_name::named]
    fn direction_1(
        &mut self,
        _output: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let output = pop_item!(self, output, Output, context);
        let direction_1_built = DirectionOutputBuilder::default()
            .output(Box::new(output))
            .build()
            .into_diagnostic()?;
        let direction_1_built = Direction::Output(direction_1_built);
        // Calling user action here
        self.user_grammar.direction(&direction_1_built)?;
        self.push(ASTType::Direction(direction_1_built), context);
        Ok(())
    }

    /// Semantic action for production 489:
    ///
    /// Direction: Inout;
    ///
    #[parol_runtime::function_name::named]
    fn direction_2(
        &mut self,
        _inout: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inout = pop_item!(self, inout, Inout, context);
        let direction_2_built = DirectionInoutBuilder::default()
            .inout(Box::new(inout))
            .build()
            .into_diagnostic()?;
        let direction_2_built = Direction::Inout(direction_2_built);
        // Calling user action here
        self.user_grammar.direction(&direction_2_built)?;
        self.push(ASTType::Direction(direction_2_built), context);
        Ok(())
    }

    /// Semantic action for production 490:
    ///
    /// Direction: Ref;
    ///
    #[parol_runtime::function_name::named]
    fn direction_3(
        &mut self,
        _ref: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#ref = pop_item!(self, r#ref, Ref, context);
        let direction_3_built = DirectionRefBuilder::default()
            .r#ref(Box::new(r#ref))
            .build()
            .into_diagnostic()?;
        let direction_3_built = Direction::Ref(direction_3_built);
        // Calling user action here
        self.user_grammar.direction(&direction_3_built)?;
        self.push(ASTType::Direction(direction_3_built), context);
        Ok(())
    }

    /// Semantic action for production 491:
    ///
    /// FunctionDeclaration: Function Identifier FunctionDeclarationOpt /* Option */ FunctionDeclarationOpt0 /* Option */ MinusGT Type LBrace FunctionDeclarationList /* Vec */ RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn function_declaration(
        &mut self,
        _function: &ParseTreeStackEntry<'t>,
        _identifier: &ParseTreeStackEntry<'t>,
        _function_declaration_opt: &ParseTreeStackEntry<'t>,
        _function_declaration_opt0: &ParseTreeStackEntry<'t>,
        _minus_g_t: &ParseTreeStackEntry<'t>,
        _type: &ParseTreeStackEntry<'t>,
        _l_brace: &ParseTreeStackEntry<'t>,
        _function_declaration_list: &ParseTreeStackEntry<'t>,
        _r_brace: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let function_declaration_list = pop_and_reverse_item!(
            self,
            function_declaration_list,
            FunctionDeclarationList,
            context
        );
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let r#type = pop_item!(self, r#type, Type, context);
        let minus_g_t = pop_item!(self, minus_g_t, MinusGT, context);
        let function_declaration_opt0 = pop_item!(
            self,
            function_declaration_opt0,
            FunctionDeclarationOpt0,
            context
        );
        let function_declaration_opt = pop_item!(
            self,
            function_declaration_opt,
            FunctionDeclarationOpt,
            context
        );
        let identifier = pop_item!(self, identifier, Identifier, context);
        let function = pop_item!(self, function, Function, context);
        let function_declaration_built = FunctionDeclarationBuilder::default()
            .function(Box::new(function))
            .identifier(Box::new(identifier))
            .function_declaration_opt(function_declaration_opt)
            .function_declaration_opt0(function_declaration_opt0)
            .minus_g_t(Box::new(minus_g_t))
            .r#type(Box::new(r#type))
            .l_brace(Box::new(l_brace))
            .function_declaration_list(function_declaration_list)
            .r_brace(Box::new(r_brace))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .function_declaration(&function_declaration_built)?;
        self.push(
            ASTType::FunctionDeclaration(function_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 492:
    ///
    /// FunctionDeclarationList /* Vec<T>::Push */: FunctionItem FunctionDeclarationList;
    ///
    #[parol_runtime::function_name::named]
    fn function_declaration_list_0(
        &mut self,
        _function_item: &ParseTreeStackEntry<'t>,
        _function_declaration_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut function_declaration_list = pop_item!(
            self,
            function_declaration_list,
            FunctionDeclarationList,
            context
        );
        let function_item = pop_item!(self, function_item, FunctionItem, context);
        let function_declaration_list_0_built = FunctionDeclarationListBuilder::default()
            .function_item(Box::new(function_item))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        function_declaration_list.push(function_declaration_list_0_built);
        self.push(
            ASTType::FunctionDeclarationList(function_declaration_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 493:
    ///
    /// FunctionDeclarationList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn function_declaration_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let function_declaration_list_1_built = Vec::new();
        self.push(
            ASTType::FunctionDeclarationList(function_declaration_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 494:
    ///
    /// FunctionDeclarationOpt0 /* Option<T>::Some */: PortDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn function_declaration_opt0_0(
        &mut self,
        _port_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let port_declaration = pop_item!(self, port_declaration, PortDeclaration, context);
        let function_declaration_opt0_0_built = FunctionDeclarationOpt0Builder::default()
            .port_declaration(Box::new(port_declaration))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::FunctionDeclarationOpt0(Some(Box::new(function_declaration_opt0_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 495:
    ///
    /// FunctionDeclarationOpt0 /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn function_declaration_opt0_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::FunctionDeclarationOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 496:
    ///
    /// FunctionDeclarationOpt /* Option<T>::Some */: WithParameter;
    ///
    #[parol_runtime::function_name::named]
    fn function_declaration_opt_0(
        &mut self,
        _with_parameter: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let with_parameter = pop_item!(self, with_parameter, WithParameter, context);
        let function_declaration_opt_0_built = FunctionDeclarationOptBuilder::default()
            .with_parameter(Box::new(with_parameter))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::FunctionDeclarationOpt(Some(Box::new(function_declaration_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 497:
    ///
    /// FunctionDeclarationOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn function_declaration_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::FunctionDeclarationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 498:
    ///
    /// FunctionItem: VarDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn function_item_0(
        &mut self,
        _var_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let var_declaration = pop_item!(self, var_declaration, VarDeclaration, context);
        let function_item_0_built = FunctionItemVarDeclarationBuilder::default()
            .var_declaration(Box::new(var_declaration))
            .build()
            .into_diagnostic()?;
        let function_item_0_built = FunctionItem::VarDeclaration(function_item_0_built);
        // Calling user action here
        self.user_grammar.function_item(&function_item_0_built)?;
        self.push(ASTType::FunctionItem(function_item_0_built), context);
        Ok(())
    }

    /// Semantic action for production 499:
    ///
    /// FunctionItem: Statement;
    ///
    #[parol_runtime::function_name::named]
    fn function_item_1(
        &mut self,
        _statement: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement = pop_item!(self, statement, Statement, context);
        let function_item_1_built = FunctionItemStatementBuilder::default()
            .statement(Box::new(statement))
            .build()
            .into_diagnostic()?;
        let function_item_1_built = FunctionItem::Statement(function_item_1_built);
        // Calling user action here
        self.user_grammar.function_item(&function_item_1_built)?;
        self.push(ASTType::FunctionItem(function_item_1_built), context);
        Ok(())
    }

    /// Semantic action for production 500:
    ///
    /// ModuleDeclaration: Module Identifier ModuleDeclarationOpt /* Option */ ModuleDeclarationOpt0 /* Option */ LBrace ModuleDeclarationList /* Vec */ RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn module_declaration(
        &mut self,
        _module: &ParseTreeStackEntry<'t>,
        _identifier: &ParseTreeStackEntry<'t>,
        _module_declaration_opt: &ParseTreeStackEntry<'t>,
        _module_declaration_opt0: &ParseTreeStackEntry<'t>,
        _l_brace: &ParseTreeStackEntry<'t>,
        _module_declaration_list: &ParseTreeStackEntry<'t>,
        _r_brace: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let module_declaration_list = pop_and_reverse_item!(
            self,
            module_declaration_list,
            ModuleDeclarationList,
            context
        );
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let module_declaration_opt0 = pop_item!(
            self,
            module_declaration_opt0,
            ModuleDeclarationOpt0,
            context
        );
        let module_declaration_opt =
            pop_item!(self, module_declaration_opt, ModuleDeclarationOpt, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let module = pop_item!(self, module, Module, context);
        let module_declaration_built = ModuleDeclarationBuilder::default()
            .module(Box::new(module))
            .identifier(Box::new(identifier))
            .module_declaration_opt(module_declaration_opt)
            .module_declaration_opt0(module_declaration_opt0)
            .l_brace(Box::new(l_brace))
            .module_declaration_list(module_declaration_list)
            .r_brace(Box::new(r_brace))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .module_declaration(&module_declaration_built)?;
        self.push(
            ASTType::ModuleDeclaration(module_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 501:
    ///
    /// ModuleDeclarationList /* Vec<T>::Push */: ModuleItem ModuleDeclarationList;
    ///
    #[parol_runtime::function_name::named]
    fn module_declaration_list_0(
        &mut self,
        _module_item: &ParseTreeStackEntry<'t>,
        _module_declaration_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut module_declaration_list = pop_item!(
            self,
            module_declaration_list,
            ModuleDeclarationList,
            context
        );
        let module_item = pop_item!(self, module_item, ModuleItem, context);
        let module_declaration_list_0_built = ModuleDeclarationListBuilder::default()
            .module_item(Box::new(module_item))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        module_declaration_list.push(module_declaration_list_0_built);
        self.push(
            ASTType::ModuleDeclarationList(module_declaration_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 502:
    ///
    /// ModuleDeclarationList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn module_declaration_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module_declaration_list_1_built = Vec::new();
        self.push(
            ASTType::ModuleDeclarationList(module_declaration_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 503:
    ///
    /// ModuleDeclarationOpt0 /* Option<T>::Some */: PortDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn module_declaration_opt0_0(
        &mut self,
        _port_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let port_declaration = pop_item!(self, port_declaration, PortDeclaration, context);
        let module_declaration_opt0_0_built = ModuleDeclarationOpt0Builder::default()
            .port_declaration(Box::new(port_declaration))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::ModuleDeclarationOpt0(Some(Box::new(module_declaration_opt0_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 504:
    ///
    /// ModuleDeclarationOpt0 /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn module_declaration_opt0_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ModuleDeclarationOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 505:
    ///
    /// ModuleDeclarationOpt /* Option<T>::Some */: WithParameter;
    ///
    #[parol_runtime::function_name::named]
    fn module_declaration_opt_0(
        &mut self,
        _with_parameter: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let with_parameter = pop_item!(self, with_parameter, WithParameter, context);
        let module_declaration_opt_0_built = ModuleDeclarationOptBuilder::default()
            .with_parameter(Box::new(with_parameter))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::ModuleDeclarationOpt(Some(Box::new(module_declaration_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 506:
    ///
    /// ModuleDeclarationOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn module_declaration_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ModuleDeclarationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 507:
    ///
    /// ModuleIfDeclaration: If Expression ModuleNamedBlock ModuleIfDeclarationList /* Vec */ ModuleIfDeclarationOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn module_if_declaration(
        &mut self,
        _if: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _module_named_block: &ParseTreeStackEntry<'t>,
        _module_if_declaration_list: &ParseTreeStackEntry<'t>,
        _module_if_declaration_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module_if_declaration_opt = pop_item!(
            self,
            module_if_declaration_opt,
            ModuleIfDeclarationOpt,
            context
        );
        let module_if_declaration_list = pop_and_reverse_item!(
            self,
            module_if_declaration_list,
            ModuleIfDeclarationList,
            context
        );
        let module_named_block = pop_item!(self, module_named_block, ModuleNamedBlock, context);
        let expression = pop_item!(self, expression, Expression, context);
        let r#if = pop_item!(self, r#if, If, context);
        let module_if_declaration_built = ModuleIfDeclarationBuilder::default()
            .r#if(Box::new(r#if))
            .expression(Box::new(expression))
            .module_named_block(Box::new(module_named_block))
            .module_if_declaration_list(module_if_declaration_list)
            .module_if_declaration_opt(module_if_declaration_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .module_if_declaration(&module_if_declaration_built)?;
        self.push(
            ASTType::ModuleIfDeclaration(module_if_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 508:
    ///
    /// ModuleIfDeclarationList /* Vec<T>::Push */: Else If Expression ModuleOptionalNamedBlock ModuleIfDeclarationList;
    ///
    #[parol_runtime::function_name::named]
    fn module_if_declaration_list_0(
        &mut self,
        _else: &ParseTreeStackEntry<'t>,
        _if: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _module_optional_named_block: &ParseTreeStackEntry<'t>,
        _module_if_declaration_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut module_if_declaration_list = pop_item!(
            self,
            module_if_declaration_list,
            ModuleIfDeclarationList,
            context
        );
        let module_optional_named_block = pop_item!(
            self,
            module_optional_named_block,
            ModuleOptionalNamedBlock,
            context
        );
        let expression = pop_item!(self, expression, Expression, context);
        let r#if = pop_item!(self, r#if, If, context);
        let r#else = pop_item!(self, r#else, Else, context);
        let module_if_declaration_list_0_built = ModuleIfDeclarationListBuilder::default()
            .module_optional_named_block(Box::new(module_optional_named_block))
            .expression(Box::new(expression))
            .r#if(Box::new(r#if))
            .r#else(Box::new(r#else))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        module_if_declaration_list.push(module_if_declaration_list_0_built);
        self.push(
            ASTType::ModuleIfDeclarationList(module_if_declaration_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 509:
    ///
    /// ModuleIfDeclarationList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn module_if_declaration_list_1(
        &mut self,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module_if_declaration_list_1_built = Vec::new();
        self.push(
            ASTType::ModuleIfDeclarationList(module_if_declaration_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 510:
    ///
    /// ModuleIfDeclarationOpt /* Option<T>::Some */: Else ModuleOptionalNamedBlock;
    ///
    #[parol_runtime::function_name::named]
    fn module_if_declaration_opt_0(
        &mut self,
        _else: &ParseTreeStackEntry<'t>,
        _module_optional_named_block: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module_optional_named_block = pop_item!(
            self,
            module_optional_named_block,
            ModuleOptionalNamedBlock,
            context
        );
        let r#else = pop_item!(self, r#else, Else, context);
        let module_if_declaration_opt_0_built = ModuleIfDeclarationOptBuilder::default()
            .r#else(Box::new(r#else))
            .module_optional_named_block(Box::new(module_optional_named_block))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::ModuleIfDeclarationOpt(Some(Box::new(module_if_declaration_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 511:
    ///
    /// ModuleIfDeclarationOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn module_if_declaration_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ModuleIfDeclarationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 512:
    ///
    /// ModuleForDeclaration: For Identifier In Expression DotDot Expression ModuleForDeclarationOpt /* Option */ ModuleNamedBlock;
    ///
    #[parol_runtime::function_name::named]
    fn module_for_declaration(
        &mut self,
        _for: &ParseTreeStackEntry<'t>,
        _identifier: &ParseTreeStackEntry<'t>,
        _in: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _dot_dot: &ParseTreeStackEntry<'t>,
        _expression0: &ParseTreeStackEntry<'t>,
        _module_for_declaration_opt: &ParseTreeStackEntry<'t>,
        _module_named_block: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module_named_block = pop_item!(self, module_named_block, ModuleNamedBlock, context);
        let module_for_declaration_opt = pop_item!(
            self,
            module_for_declaration_opt,
            ModuleForDeclarationOpt,
            context
        );
        let expression0 = pop_item!(self, expression0, Expression, context);
        let dot_dot = pop_item!(self, dot_dot, DotDot, context);
        let expression = pop_item!(self, expression, Expression, context);
        let r#in = pop_item!(self, r#in, In, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let r#for = pop_item!(self, r#for, For, context);
        let module_for_declaration_built = ModuleForDeclarationBuilder::default()
            .r#for(Box::new(r#for))
            .identifier(Box::new(identifier))
            .r#in(Box::new(r#in))
            .expression(Box::new(expression))
            .dot_dot(Box::new(dot_dot))
            .expression0(Box::new(expression0))
            .module_for_declaration_opt(module_for_declaration_opt)
            .module_named_block(Box::new(module_named_block))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .module_for_declaration(&module_for_declaration_built)?;
        self.push(
            ASTType::ModuleForDeclaration(module_for_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 513:
    ///
    /// ModuleForDeclarationOpt /* Option<T>::Some */: Step AssignmentOperator Expression;
    ///
    #[parol_runtime::function_name::named]
    fn module_for_declaration_opt_0(
        &mut self,
        _step: &ParseTreeStackEntry<'t>,
        _assignment_operator: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = pop_item!(self, expression, Expression, context);
        let assignment_operator = pop_item!(self, assignment_operator, AssignmentOperator, context);
        let step = pop_item!(self, step, Step, context);
        let module_for_declaration_opt_0_built = ModuleForDeclarationOptBuilder::default()
            .step(Box::new(step))
            .assignment_operator(Box::new(assignment_operator))
            .expression(Box::new(expression))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::ModuleForDeclarationOpt(Some(Box::new(module_for_declaration_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 514:
    ///
    /// ModuleForDeclarationOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn module_for_declaration_opt_1(
        &mut self,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ModuleForDeclarationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 515:
    ///
    /// ModuleNamedBlock: Colon Identifier LBrace ModuleNamedBlockList /* Vec */ RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn module_named_block(
        &mut self,
        _colon: &ParseTreeStackEntry<'t>,
        _identifier: &ParseTreeStackEntry<'t>,
        _l_brace: &ParseTreeStackEntry<'t>,
        _module_named_block_list: &ParseTreeStackEntry<'t>,
        _r_brace: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let module_named_block_list =
            pop_and_reverse_item!(self, module_named_block_list, ModuleNamedBlockList, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let colon = pop_item!(self, colon, Colon, context);
        let module_named_block_built = ModuleNamedBlockBuilder::default()
            .colon(Box::new(colon))
            .identifier(Box::new(identifier))
            .l_brace(Box::new(l_brace))
            .module_named_block_list(module_named_block_list)
            .r_brace(Box::new(r_brace))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .module_named_block(&module_named_block_built)?;
        self.push(ASTType::ModuleNamedBlock(module_named_block_built), context);
        Ok(())
    }

    /// Semantic action for production 516:
    ///
    /// ModuleNamedBlockList /* Vec<T>::Push */: ModuleItem ModuleNamedBlockList;
    ///
    #[parol_runtime::function_name::named]
    fn module_named_block_list_0(
        &mut self,
        _module_item: &ParseTreeStackEntry<'t>,
        _module_named_block_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut module_named_block_list =
            pop_item!(self, module_named_block_list, ModuleNamedBlockList, context);
        let module_item = pop_item!(self, module_item, ModuleItem, context);
        let module_named_block_list_0_built = ModuleNamedBlockListBuilder::default()
            .module_item(Box::new(module_item))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        module_named_block_list.push(module_named_block_list_0_built);
        self.push(
            ASTType::ModuleNamedBlockList(module_named_block_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 517:
    ///
    /// ModuleNamedBlockList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn module_named_block_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module_named_block_list_1_built = Vec::new();
        self.push(
            ASTType::ModuleNamedBlockList(module_named_block_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 518:
    ///
    /// ModuleOptionalNamedBlock: ModuleOptionalNamedBlockOpt /* Option */ LBrace ModuleOptionalNamedBlockList /* Vec */ RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn module_optional_named_block(
        &mut self,
        _module_optional_named_block_opt: &ParseTreeStackEntry<'t>,
        _l_brace: &ParseTreeStackEntry<'t>,
        _module_optional_named_block_list: &ParseTreeStackEntry<'t>,
        _r_brace: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let module_optional_named_block_list = pop_and_reverse_item!(
            self,
            module_optional_named_block_list,
            ModuleOptionalNamedBlockList,
            context
        );
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let module_optional_named_block_opt = pop_item!(
            self,
            module_optional_named_block_opt,
            ModuleOptionalNamedBlockOpt,
            context
        );
        let module_optional_named_block_built = ModuleOptionalNamedBlockBuilder::default()
            .module_optional_named_block_opt(module_optional_named_block_opt)
            .l_brace(Box::new(l_brace))
            .module_optional_named_block_list(module_optional_named_block_list)
            .r_brace(Box::new(r_brace))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .module_optional_named_block(&module_optional_named_block_built)?;
        self.push(
            ASTType::ModuleOptionalNamedBlock(module_optional_named_block_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 519:
    ///
    /// ModuleOptionalNamedBlockList /* Vec<T>::Push */: ModuleItem ModuleOptionalNamedBlockList;
    ///
    #[parol_runtime::function_name::named]
    fn module_optional_named_block_list_0(
        &mut self,
        _module_item: &ParseTreeStackEntry<'t>,
        _module_optional_named_block_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut module_optional_named_block_list = pop_item!(
            self,
            module_optional_named_block_list,
            ModuleOptionalNamedBlockList,
            context
        );
        let module_item = pop_item!(self, module_item, ModuleItem, context);
        let module_optional_named_block_list_0_built =
            ModuleOptionalNamedBlockListBuilder::default()
                .module_item(Box::new(module_item))
                .build()
                .into_diagnostic()?;
        // Add an element to the vector
        module_optional_named_block_list.push(module_optional_named_block_list_0_built);
        self.push(
            ASTType::ModuleOptionalNamedBlockList(module_optional_named_block_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 520:
    ///
    /// ModuleOptionalNamedBlockList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn module_optional_named_block_list_1(
        &mut self,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module_optional_named_block_list_1_built = Vec::new();
        self.push(
            ASTType::ModuleOptionalNamedBlockList(module_optional_named_block_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 521:
    ///
    /// ModuleOptionalNamedBlockOpt /* Option<T>::Some */: Colon Identifier;
    ///
    #[parol_runtime::function_name::named]
    fn module_optional_named_block_opt_0(
        &mut self,
        _colon: &ParseTreeStackEntry<'t>,
        _identifier: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let identifier = pop_item!(self, identifier, Identifier, context);
        let colon = pop_item!(self, colon, Colon, context);
        let module_optional_named_block_opt_0_built = ModuleOptionalNamedBlockOptBuilder::default()
            .colon(Box::new(colon))
            .identifier(Box::new(identifier))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::ModuleOptionalNamedBlockOpt(Some(Box::new(
                module_optional_named_block_opt_0_built,
            ))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 522:
    ///
    /// ModuleOptionalNamedBlockOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn module_optional_named_block_opt_1(
        &mut self,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ModuleOptionalNamedBlockOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 523:
    ///
    /// ModuleItem: VarDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn module_item_0(
        &mut self,
        _var_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let var_declaration = pop_item!(self, var_declaration, VarDeclaration, context);
        let module_item_0_built = ModuleItemVarDeclarationBuilder::default()
            .var_declaration(Box::new(var_declaration))
            .build()
            .into_diagnostic()?;
        let module_item_0_built = ModuleItem::VarDeclaration(module_item_0_built);
        // Calling user action here
        self.user_grammar.module_item(&module_item_0_built)?;
        self.push(ASTType::ModuleItem(module_item_0_built), context);
        Ok(())
    }

    /// Semantic action for production 524:
    ///
    /// ModuleItem: InstDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn module_item_1(
        &mut self,
        _inst_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inst_declaration = pop_item!(self, inst_declaration, InstDeclaration, context);
        let module_item_1_built = ModuleItemInstDeclarationBuilder::default()
            .inst_declaration(Box::new(inst_declaration))
            .build()
            .into_diagnostic()?;
        let module_item_1_built = ModuleItem::InstDeclaration(module_item_1_built);
        // Calling user action here
        self.user_grammar.module_item(&module_item_1_built)?;
        self.push(ASTType::ModuleItem(module_item_1_built), context);
        Ok(())
    }

    /// Semantic action for production 525:
    ///
    /// ModuleItem: LocalparamDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn module_item_2(
        &mut self,
        _localparam_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let localparam_declaration =
            pop_item!(self, localparam_declaration, LocalparamDeclaration, context);
        let module_item_2_built = ModuleItemLocalparamDeclarationBuilder::default()
            .localparam_declaration(Box::new(localparam_declaration))
            .build()
            .into_diagnostic()?;
        let module_item_2_built = ModuleItem::LocalparamDeclaration(module_item_2_built);
        // Calling user action here
        self.user_grammar.module_item(&module_item_2_built)?;
        self.push(ASTType::ModuleItem(module_item_2_built), context);
        Ok(())
    }

    /// Semantic action for production 526:
    ///
    /// ModuleItem: AlwaysFfDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn module_item_3(
        &mut self,
        _always_ff_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let always_ff_declaration =
            pop_item!(self, always_ff_declaration, AlwaysFfDeclaration, context);
        let module_item_3_built = ModuleItemAlwaysFfDeclarationBuilder::default()
            .always_ff_declaration(Box::new(always_ff_declaration))
            .build()
            .into_diagnostic()?;
        let module_item_3_built = ModuleItem::AlwaysFfDeclaration(module_item_3_built);
        // Calling user action here
        self.user_grammar.module_item(&module_item_3_built)?;
        self.push(ASTType::ModuleItem(module_item_3_built), context);
        Ok(())
    }

    /// Semantic action for production 527:
    ///
    /// ModuleItem: AlwaysCombDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn module_item_4(
        &mut self,
        _always_comb_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let always_comb_declaration = pop_item!(
            self,
            always_comb_declaration,
            AlwaysCombDeclaration,
            context
        );
        let module_item_4_built = ModuleItemAlwaysCombDeclarationBuilder::default()
            .always_comb_declaration(Box::new(always_comb_declaration))
            .build()
            .into_diagnostic()?;
        let module_item_4_built = ModuleItem::AlwaysCombDeclaration(module_item_4_built);
        // Calling user action here
        self.user_grammar.module_item(&module_item_4_built)?;
        self.push(ASTType::ModuleItem(module_item_4_built), context);
        Ok(())
    }

    /// Semantic action for production 528:
    ///
    /// ModuleItem: AssignDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn module_item_5(
        &mut self,
        _assign_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let assign_declaration = pop_item!(self, assign_declaration, AssignDeclaration, context);
        let module_item_5_built = ModuleItemAssignDeclarationBuilder::default()
            .assign_declaration(Box::new(assign_declaration))
            .build()
            .into_diagnostic()?;
        let module_item_5_built = ModuleItem::AssignDeclaration(module_item_5_built);
        // Calling user action here
        self.user_grammar.module_item(&module_item_5_built)?;
        self.push(ASTType::ModuleItem(module_item_5_built), context);
        Ok(())
    }

    /// Semantic action for production 529:
    ///
    /// ModuleItem: FunctionDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn module_item_6(
        &mut self,
        _function_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let function_declaration =
            pop_item!(self, function_declaration, FunctionDeclaration, context);
        let module_item_6_built = ModuleItemFunctionDeclarationBuilder::default()
            .function_declaration(Box::new(function_declaration))
            .build()
            .into_diagnostic()?;
        let module_item_6_built = ModuleItem::FunctionDeclaration(module_item_6_built);
        // Calling user action here
        self.user_grammar.module_item(&module_item_6_built)?;
        self.push(ASTType::ModuleItem(module_item_6_built), context);
        Ok(())
    }

    /// Semantic action for production 530:
    ///
    /// ModuleItem: ModuleIfDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn module_item_7(
        &mut self,
        _module_if_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module_if_declaration =
            pop_item!(self, module_if_declaration, ModuleIfDeclaration, context);
        let module_item_7_built = ModuleItemModuleIfDeclarationBuilder::default()
            .module_if_declaration(Box::new(module_if_declaration))
            .build()
            .into_diagnostic()?;
        let module_item_7_built = ModuleItem::ModuleIfDeclaration(module_item_7_built);
        // Calling user action here
        self.user_grammar.module_item(&module_item_7_built)?;
        self.push(ASTType::ModuleItem(module_item_7_built), context);
        Ok(())
    }

    /// Semantic action for production 531:
    ///
    /// ModuleItem: ModuleForDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn module_item_8(
        &mut self,
        _module_for_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module_for_declaration =
            pop_item!(self, module_for_declaration, ModuleForDeclaration, context);
        let module_item_8_built = ModuleItemModuleForDeclarationBuilder::default()
            .module_for_declaration(Box::new(module_for_declaration))
            .build()
            .into_diagnostic()?;
        let module_item_8_built = ModuleItem::ModuleForDeclaration(module_item_8_built);
        // Calling user action here
        self.user_grammar.module_item(&module_item_8_built)?;
        self.push(ASTType::ModuleItem(module_item_8_built), context);
        Ok(())
    }

    /// Semantic action for production 532:
    ///
    /// ModuleItem: EnumDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn module_item_9(
        &mut self,
        _enum_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let enum_declaration = pop_item!(self, enum_declaration, EnumDeclaration, context);
        let module_item_9_built = ModuleItemEnumDeclarationBuilder::default()
            .enum_declaration(Box::new(enum_declaration))
            .build()
            .into_diagnostic()?;
        let module_item_9_built = ModuleItem::EnumDeclaration(module_item_9_built);
        // Calling user action here
        self.user_grammar.module_item(&module_item_9_built)?;
        self.push(ASTType::ModuleItem(module_item_9_built), context);
        Ok(())
    }

    /// Semantic action for production 533:
    ///
    /// ModuleItem: StructDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn module_item_10(
        &mut self,
        _struct_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let struct_declaration = pop_item!(self, struct_declaration, StructDeclaration, context);
        let module_item_10_built = ModuleItemStructDeclarationBuilder::default()
            .struct_declaration(Box::new(struct_declaration))
            .build()
            .into_diagnostic()?;
        let module_item_10_built = ModuleItem::StructDeclaration(module_item_10_built);
        // Calling user action here
        self.user_grammar.module_item(&module_item_10_built)?;
        self.push(ASTType::ModuleItem(module_item_10_built), context);
        Ok(())
    }

    /// Semantic action for production 534:
    ///
    /// ModuleItem: ModuleNamedBlock;
    ///
    #[parol_runtime::function_name::named]
    fn module_item_11(
        &mut self,
        _module_named_block: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module_named_block = pop_item!(self, module_named_block, ModuleNamedBlock, context);
        let module_item_11_built = ModuleItemModuleNamedBlockBuilder::default()
            .module_named_block(Box::new(module_named_block))
            .build()
            .into_diagnostic()?;
        let module_item_11_built = ModuleItem::ModuleNamedBlock(module_item_11_built);
        // Calling user action here
        self.user_grammar.module_item(&module_item_11_built)?;
        self.push(ASTType::ModuleItem(module_item_11_built), context);
        Ok(())
    }

    /// Semantic action for production 535:
    ///
    /// InterfaceDeclaration: Interface Identifier InterfaceDeclarationOpt /* Option */ LBrace InterfaceDeclarationList /* Vec */ RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn interface_declaration(
        &mut self,
        _interface: &ParseTreeStackEntry<'t>,
        _identifier: &ParseTreeStackEntry<'t>,
        _interface_declaration_opt: &ParseTreeStackEntry<'t>,
        _l_brace: &ParseTreeStackEntry<'t>,
        _interface_declaration_list: &ParseTreeStackEntry<'t>,
        _r_brace: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let interface_declaration_list = pop_and_reverse_item!(
            self,
            interface_declaration_list,
            InterfaceDeclarationList,
            context
        );
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let interface_declaration_opt = pop_item!(
            self,
            interface_declaration_opt,
            InterfaceDeclarationOpt,
            context
        );
        let identifier = pop_item!(self, identifier, Identifier, context);
        let interface = pop_item!(self, interface, Interface, context);
        let interface_declaration_built = InterfaceDeclarationBuilder::default()
            .interface(Box::new(interface))
            .identifier(Box::new(identifier))
            .interface_declaration_opt(interface_declaration_opt)
            .l_brace(Box::new(l_brace))
            .interface_declaration_list(interface_declaration_list)
            .r_brace(Box::new(r_brace))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .interface_declaration(&interface_declaration_built)?;
        self.push(
            ASTType::InterfaceDeclaration(interface_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 536:
    ///
    /// InterfaceDeclarationList /* Vec<T>::Push */: InterfaceItem InterfaceDeclarationList;
    ///
    #[parol_runtime::function_name::named]
    fn interface_declaration_list_0(
        &mut self,
        _interface_item: &ParseTreeStackEntry<'t>,
        _interface_declaration_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut interface_declaration_list = pop_item!(
            self,
            interface_declaration_list,
            InterfaceDeclarationList,
            context
        );
        let interface_item = pop_item!(self, interface_item, InterfaceItem, context);
        let interface_declaration_list_0_built = InterfaceDeclarationListBuilder::default()
            .interface_item(Box::new(interface_item))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        interface_declaration_list.push(interface_declaration_list_0_built);
        self.push(
            ASTType::InterfaceDeclarationList(interface_declaration_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 537:
    ///
    /// InterfaceDeclarationList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn interface_declaration_list_1(
        &mut self,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let interface_declaration_list_1_built = Vec::new();
        self.push(
            ASTType::InterfaceDeclarationList(interface_declaration_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 538:
    ///
    /// InterfaceDeclarationOpt /* Option<T>::Some */: WithParameter;
    ///
    #[parol_runtime::function_name::named]
    fn interface_declaration_opt_0(
        &mut self,
        _with_parameter: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let with_parameter = pop_item!(self, with_parameter, WithParameter, context);
        let interface_declaration_opt_0_built = InterfaceDeclarationOptBuilder::default()
            .with_parameter(Box::new(with_parameter))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::InterfaceDeclarationOpt(Some(Box::new(interface_declaration_opt_0_built))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 539:
    ///
    /// InterfaceDeclarationOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn interface_declaration_opt_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::InterfaceDeclarationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 540:
    ///
    /// InterfaceIfDeclaration: If Expression InterfaceNamedBlock InterfaceIfDeclarationList /* Vec */ InterfaceIfDeclarationOpt /* Option */;
    ///
    #[parol_runtime::function_name::named]
    fn interface_if_declaration(
        &mut self,
        _if: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _interface_named_block: &ParseTreeStackEntry<'t>,
        _interface_if_declaration_list: &ParseTreeStackEntry<'t>,
        _interface_if_declaration_opt: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let interface_if_declaration_opt = pop_item!(
            self,
            interface_if_declaration_opt,
            InterfaceIfDeclarationOpt,
            context
        );
        let interface_if_declaration_list = pop_and_reverse_item!(
            self,
            interface_if_declaration_list,
            InterfaceIfDeclarationList,
            context
        );
        let interface_named_block =
            pop_item!(self, interface_named_block, InterfaceNamedBlock, context);
        let expression = pop_item!(self, expression, Expression, context);
        let r#if = pop_item!(self, r#if, If, context);
        let interface_if_declaration_built = InterfaceIfDeclarationBuilder::default()
            .r#if(Box::new(r#if))
            .expression(Box::new(expression))
            .interface_named_block(Box::new(interface_named_block))
            .interface_if_declaration_list(interface_if_declaration_list)
            .interface_if_declaration_opt(interface_if_declaration_opt)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .interface_if_declaration(&interface_if_declaration_built)?;
        self.push(
            ASTType::InterfaceIfDeclaration(interface_if_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 541:
    ///
    /// InterfaceIfDeclarationList /* Vec<T>::Push */: Else If Expression InterfaceOptionalNamedBlock InterfaceIfDeclarationList;
    ///
    #[parol_runtime::function_name::named]
    fn interface_if_declaration_list_0(
        &mut self,
        _else: &ParseTreeStackEntry<'t>,
        _if: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _interface_optional_named_block: &ParseTreeStackEntry<'t>,
        _interface_if_declaration_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut interface_if_declaration_list = pop_item!(
            self,
            interface_if_declaration_list,
            InterfaceIfDeclarationList,
            context
        );
        let interface_optional_named_block = pop_item!(
            self,
            interface_optional_named_block,
            InterfaceOptionalNamedBlock,
            context
        );
        let expression = pop_item!(self, expression, Expression, context);
        let r#if = pop_item!(self, r#if, If, context);
        let r#else = pop_item!(self, r#else, Else, context);
        let interface_if_declaration_list_0_built = InterfaceIfDeclarationListBuilder::default()
            .interface_optional_named_block(Box::new(interface_optional_named_block))
            .expression(Box::new(expression))
            .r#if(Box::new(r#if))
            .r#else(Box::new(r#else))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        interface_if_declaration_list.push(interface_if_declaration_list_0_built);
        self.push(
            ASTType::InterfaceIfDeclarationList(interface_if_declaration_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 542:
    ///
    /// InterfaceIfDeclarationList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn interface_if_declaration_list_1(
        &mut self,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let interface_if_declaration_list_1_built = Vec::new();
        self.push(
            ASTType::InterfaceIfDeclarationList(interface_if_declaration_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 543:
    ///
    /// InterfaceIfDeclarationOpt /* Option<T>::Some */: Else InterfaceOptionalNamedBlock;
    ///
    #[parol_runtime::function_name::named]
    fn interface_if_declaration_opt_0(
        &mut self,
        _else: &ParseTreeStackEntry<'t>,
        _interface_optional_named_block: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let interface_optional_named_block = pop_item!(
            self,
            interface_optional_named_block,
            InterfaceOptionalNamedBlock,
            context
        );
        let r#else = pop_item!(self, r#else, Else, context);
        let interface_if_declaration_opt_0_built = InterfaceIfDeclarationOptBuilder::default()
            .r#else(Box::new(r#else))
            .interface_optional_named_block(Box::new(interface_optional_named_block))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::InterfaceIfDeclarationOpt(Some(Box::new(
                interface_if_declaration_opt_0_built,
            ))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 544:
    ///
    /// InterfaceIfDeclarationOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn interface_if_declaration_opt_1(
        &mut self,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::InterfaceIfDeclarationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 545:
    ///
    /// InterfaceForDeclaration: For Identifier In Expression DotDot Expression InterfaceForDeclarationOpt /* Option */ InterfaceNamedBlock;
    ///
    #[parol_runtime::function_name::named]
    fn interface_for_declaration(
        &mut self,
        _for: &ParseTreeStackEntry<'t>,
        _identifier: &ParseTreeStackEntry<'t>,
        _in: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _dot_dot: &ParseTreeStackEntry<'t>,
        _expression0: &ParseTreeStackEntry<'t>,
        _interface_for_declaration_opt: &ParseTreeStackEntry<'t>,
        _interface_named_block: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let interface_named_block =
            pop_item!(self, interface_named_block, InterfaceNamedBlock, context);
        let interface_for_declaration_opt = pop_item!(
            self,
            interface_for_declaration_opt,
            InterfaceForDeclarationOpt,
            context
        );
        let expression0 = pop_item!(self, expression0, Expression, context);
        let dot_dot = pop_item!(self, dot_dot, DotDot, context);
        let expression = pop_item!(self, expression, Expression, context);
        let r#in = pop_item!(self, r#in, In, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let r#for = pop_item!(self, r#for, For, context);
        let interface_for_declaration_built = InterfaceForDeclarationBuilder::default()
            .r#for(Box::new(r#for))
            .identifier(Box::new(identifier))
            .r#in(Box::new(r#in))
            .expression(Box::new(expression))
            .dot_dot(Box::new(dot_dot))
            .expression0(Box::new(expression0))
            .interface_for_declaration_opt(interface_for_declaration_opt)
            .interface_named_block(Box::new(interface_named_block))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .interface_for_declaration(&interface_for_declaration_built)?;
        self.push(
            ASTType::InterfaceForDeclaration(interface_for_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 546:
    ///
    /// InterfaceForDeclarationOpt /* Option<T>::Some */: Step AssignmentOperator Expression;
    ///
    #[parol_runtime::function_name::named]
    fn interface_for_declaration_opt_0(
        &mut self,
        _step: &ParseTreeStackEntry<'t>,
        _assignment_operator: &ParseTreeStackEntry<'t>,
        _expression: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = pop_item!(self, expression, Expression, context);
        let assignment_operator = pop_item!(self, assignment_operator, AssignmentOperator, context);
        let step = pop_item!(self, step, Step, context);
        let interface_for_declaration_opt_0_built = InterfaceForDeclarationOptBuilder::default()
            .step(Box::new(step))
            .assignment_operator(Box::new(assignment_operator))
            .expression(Box::new(expression))
            .build()
            .into_diagnostic()?;
        self.push(
            ASTType::InterfaceForDeclarationOpt(Some(Box::new(
                interface_for_declaration_opt_0_built,
            ))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 547:
    ///
    /// InterfaceForDeclarationOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn interface_for_declaration_opt_1(
        &mut self,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::InterfaceForDeclarationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 548:
    ///
    /// InterfaceNamedBlock: Colon Identifier LBrace InterfaceNamedBlockList /* Vec */ RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn interface_named_block(
        &mut self,
        _colon: &ParseTreeStackEntry<'t>,
        _identifier: &ParseTreeStackEntry<'t>,
        _l_brace: &ParseTreeStackEntry<'t>,
        _interface_named_block_list: &ParseTreeStackEntry<'t>,
        _r_brace: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let interface_named_block_list = pop_and_reverse_item!(
            self,
            interface_named_block_list,
            InterfaceNamedBlockList,
            context
        );
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let colon = pop_item!(self, colon, Colon, context);
        let interface_named_block_built = InterfaceNamedBlockBuilder::default()
            .colon(Box::new(colon))
            .identifier(Box::new(identifier))
            .l_brace(Box::new(l_brace))
            .interface_named_block_list(interface_named_block_list)
            .r_brace(Box::new(r_brace))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .interface_named_block(&interface_named_block_built)?;
        self.push(
            ASTType::InterfaceNamedBlock(interface_named_block_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 549:
    ///
    /// InterfaceNamedBlockList /* Vec<T>::Push */: InterfaceItem InterfaceNamedBlockList;
    ///
    #[parol_runtime::function_name::named]
    fn interface_named_block_list_0(
        &mut self,
        _interface_item: &ParseTreeStackEntry<'t>,
        _interface_named_block_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut interface_named_block_list = pop_item!(
            self,
            interface_named_block_list,
            InterfaceNamedBlockList,
            context
        );
        let interface_item = pop_item!(self, interface_item, InterfaceItem, context);
        let interface_named_block_list_0_built = InterfaceNamedBlockListBuilder::default()
            .interface_item(Box::new(interface_item))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        interface_named_block_list.push(interface_named_block_list_0_built);
        self.push(
            ASTType::InterfaceNamedBlockList(interface_named_block_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 550:
    ///
    /// InterfaceNamedBlockList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn interface_named_block_list_1(
        &mut self,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let interface_named_block_list_1_built = Vec::new();
        self.push(
            ASTType::InterfaceNamedBlockList(interface_named_block_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 551:
    ///
    /// InterfaceOptionalNamedBlock: InterfaceOptionalNamedBlockOpt /* Option */ LBrace InterfaceOptionalNamedBlockList /* Vec */ RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn interface_optional_named_block(
        &mut self,
        _interface_optional_named_block_opt: &ParseTreeStackEntry<'t>,
        _l_brace: &ParseTreeStackEntry<'t>,
        _interface_optional_named_block_list: &ParseTreeStackEntry<'t>,
        _r_brace: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let interface_optional_named_block_list = pop_and_reverse_item!(
            self,
            interface_optional_named_block_list,
            InterfaceOptionalNamedBlockList,
            context
        );
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let interface_optional_named_block_opt = pop_item!(
            self,
            interface_optional_named_block_opt,
            InterfaceOptionalNamedBlockOpt,
            context
        );
        let interface_optional_named_block_built = InterfaceOptionalNamedBlockBuilder::default()
            .interface_optional_named_block_opt(interface_optional_named_block_opt)
            .l_brace(Box::new(l_brace))
            .interface_optional_named_block_list(interface_optional_named_block_list)
            .r_brace(Box::new(r_brace))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .interface_optional_named_block(&interface_optional_named_block_built)?;
        self.push(
            ASTType::InterfaceOptionalNamedBlock(interface_optional_named_block_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 552:
    ///
    /// InterfaceOptionalNamedBlockList /* Vec<T>::Push */: InterfaceItem InterfaceOptionalNamedBlockList;
    ///
    #[parol_runtime::function_name::named]
    fn interface_optional_named_block_list_0(
        &mut self,
        _interface_item: &ParseTreeStackEntry<'t>,
        _interface_optional_named_block_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut interface_optional_named_block_list = pop_item!(
            self,
            interface_optional_named_block_list,
            InterfaceOptionalNamedBlockList,
            context
        );
        let interface_item = pop_item!(self, interface_item, InterfaceItem, context);
        let interface_optional_named_block_list_0_built =
            InterfaceOptionalNamedBlockListBuilder::default()
                .interface_item(Box::new(interface_item))
                .build()
                .into_diagnostic()?;
        // Add an element to the vector
        interface_optional_named_block_list.push(interface_optional_named_block_list_0_built);
        self.push(
            ASTType::InterfaceOptionalNamedBlockList(interface_optional_named_block_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 553:
    ///
    /// InterfaceOptionalNamedBlockList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn interface_optional_named_block_list_1(
        &mut self,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let interface_optional_named_block_list_1_built = Vec::new();
        self.push(
            ASTType::InterfaceOptionalNamedBlockList(interface_optional_named_block_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 554:
    ///
    /// InterfaceOptionalNamedBlockOpt /* Option<T>::Some */: Colon Identifier;
    ///
    #[parol_runtime::function_name::named]
    fn interface_optional_named_block_opt_0(
        &mut self,
        _colon: &ParseTreeStackEntry<'t>,
        _identifier: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let identifier = pop_item!(self, identifier, Identifier, context);
        let colon = pop_item!(self, colon, Colon, context);
        let interface_optional_named_block_opt_0_built =
            InterfaceOptionalNamedBlockOptBuilder::default()
                .colon(Box::new(colon))
                .identifier(Box::new(identifier))
                .build()
                .into_diagnostic()?;
        self.push(
            ASTType::InterfaceOptionalNamedBlockOpt(Some(Box::new(
                interface_optional_named_block_opt_0_built,
            ))),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 555:
    ///
    /// InterfaceOptionalNamedBlockOpt /* Option<T>::None */: ;
    ///
    #[parol_runtime::function_name::named]
    fn interface_optional_named_block_opt_1(
        &mut self,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::InterfaceOptionalNamedBlockOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 556:
    ///
    /// InterfaceItem: VarDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn interface_item_0(
        &mut self,
        _var_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let var_declaration = pop_item!(self, var_declaration, VarDeclaration, context);
        let interface_item_0_built = InterfaceItemVarDeclarationBuilder::default()
            .var_declaration(Box::new(var_declaration))
            .build()
            .into_diagnostic()?;
        let interface_item_0_built = InterfaceItem::VarDeclaration(interface_item_0_built);
        // Calling user action here
        self.user_grammar.interface_item(&interface_item_0_built)?;
        self.push(ASTType::InterfaceItem(interface_item_0_built), context);
        Ok(())
    }

    /// Semantic action for production 557:
    ///
    /// InterfaceItem: LocalparamDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn interface_item_1(
        &mut self,
        _localparam_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let localparam_declaration =
            pop_item!(self, localparam_declaration, LocalparamDeclaration, context);
        let interface_item_1_built = InterfaceItemLocalparamDeclarationBuilder::default()
            .localparam_declaration(Box::new(localparam_declaration))
            .build()
            .into_diagnostic()?;
        let interface_item_1_built = InterfaceItem::LocalparamDeclaration(interface_item_1_built);
        // Calling user action here
        self.user_grammar.interface_item(&interface_item_1_built)?;
        self.push(ASTType::InterfaceItem(interface_item_1_built), context);
        Ok(())
    }

    /// Semantic action for production 558:
    ///
    /// InterfaceItem: ModportDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn interface_item_2(
        &mut self,
        _modport_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let modport_declaration = pop_item!(self, modport_declaration, ModportDeclaration, context);
        let interface_item_2_built = InterfaceItemModportDeclarationBuilder::default()
            .modport_declaration(Box::new(modport_declaration))
            .build()
            .into_diagnostic()?;
        let interface_item_2_built = InterfaceItem::ModportDeclaration(interface_item_2_built);
        // Calling user action here
        self.user_grammar.interface_item(&interface_item_2_built)?;
        self.push(ASTType::InterfaceItem(interface_item_2_built), context);
        Ok(())
    }

    /// Semantic action for production 559:
    ///
    /// InterfaceItem: InterfaceIfDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn interface_item_3(
        &mut self,
        _interface_if_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let interface_if_declaration = pop_item!(
            self,
            interface_if_declaration,
            InterfaceIfDeclaration,
            context
        );
        let interface_item_3_built = InterfaceItemInterfaceIfDeclarationBuilder::default()
            .interface_if_declaration(Box::new(interface_if_declaration))
            .build()
            .into_diagnostic()?;
        let interface_item_3_built = InterfaceItem::InterfaceIfDeclaration(interface_item_3_built);
        // Calling user action here
        self.user_grammar.interface_item(&interface_item_3_built)?;
        self.push(ASTType::InterfaceItem(interface_item_3_built), context);
        Ok(())
    }

    /// Semantic action for production 560:
    ///
    /// InterfaceItem: InterfaceForDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn interface_item_4(
        &mut self,
        _interface_for_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let interface_for_declaration = pop_item!(
            self,
            interface_for_declaration,
            InterfaceForDeclaration,
            context
        );
        let interface_item_4_built = InterfaceItemInterfaceForDeclarationBuilder::default()
            .interface_for_declaration(Box::new(interface_for_declaration))
            .build()
            .into_diagnostic()?;
        let interface_item_4_built = InterfaceItem::InterfaceForDeclaration(interface_item_4_built);
        // Calling user action here
        self.user_grammar.interface_item(&interface_item_4_built)?;
        self.push(ASTType::InterfaceItem(interface_item_4_built), context);
        Ok(())
    }

    /// Semantic action for production 561:
    ///
    /// InterfaceItem: EnumDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn interface_item_5(
        &mut self,
        _enum_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let enum_declaration = pop_item!(self, enum_declaration, EnumDeclaration, context);
        let interface_item_5_built = InterfaceItemEnumDeclarationBuilder::default()
            .enum_declaration(Box::new(enum_declaration))
            .build()
            .into_diagnostic()?;
        let interface_item_5_built = InterfaceItem::EnumDeclaration(interface_item_5_built);
        // Calling user action here
        self.user_grammar.interface_item(&interface_item_5_built)?;
        self.push(ASTType::InterfaceItem(interface_item_5_built), context);
        Ok(())
    }

    /// Semantic action for production 562:
    ///
    /// InterfaceItem: StructDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn interface_item_6(
        &mut self,
        _struct_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let struct_declaration = pop_item!(self, struct_declaration, StructDeclaration, context);
        let interface_item_6_built = InterfaceItemStructDeclarationBuilder::default()
            .struct_declaration(Box::new(struct_declaration))
            .build()
            .into_diagnostic()?;
        let interface_item_6_built = InterfaceItem::StructDeclaration(interface_item_6_built);
        // Calling user action here
        self.user_grammar.interface_item(&interface_item_6_built)?;
        self.push(ASTType::InterfaceItem(interface_item_6_built), context);
        Ok(())
    }

    /// Semantic action for production 563:
    ///
    /// InterfaceItem: InterfaceNamedBlock;
    ///
    #[parol_runtime::function_name::named]
    fn interface_item_7(
        &mut self,
        _interface_named_block: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let interface_named_block =
            pop_item!(self, interface_named_block, InterfaceNamedBlock, context);
        let interface_item_7_built = InterfaceItemInterfaceNamedBlockBuilder::default()
            .interface_named_block(Box::new(interface_named_block))
            .build()
            .into_diagnostic()?;
        let interface_item_7_built = InterfaceItem::InterfaceNamedBlock(interface_item_7_built);
        // Calling user action here
        self.user_grammar.interface_item(&interface_item_7_built)?;
        self.push(ASTType::InterfaceItem(interface_item_7_built), context);
        Ok(())
    }

    /// Semantic action for production 564:
    ///
    /// InterfaceItem: FunctionDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn interface_item_8(
        &mut self,
        _function_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let function_declaration =
            pop_item!(self, function_declaration, FunctionDeclaration, context);
        let interface_item_8_built = InterfaceItemFunctionDeclarationBuilder::default()
            .function_declaration(Box::new(function_declaration))
            .build()
            .into_diagnostic()?;
        let interface_item_8_built = InterfaceItem::FunctionDeclaration(interface_item_8_built);
        // Calling user action here
        self.user_grammar.interface_item(&interface_item_8_built)?;
        self.push(ASTType::InterfaceItem(interface_item_8_built), context);
        Ok(())
    }

    /// Semantic action for production 565:
    ///
    /// PackageDeclaration: Package Identifier LBrace PackageDeclarationList /* Vec */ RBrace;
    ///
    #[parol_runtime::function_name::named]
    fn package_declaration(
        &mut self,
        _package: &ParseTreeStackEntry<'t>,
        _identifier: &ParseTreeStackEntry<'t>,
        _l_brace: &ParseTreeStackEntry<'t>,
        _package_declaration_list: &ParseTreeStackEntry<'t>,
        _r_brace: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let package_declaration_list = pop_and_reverse_item!(
            self,
            package_declaration_list,
            PackageDeclarationList,
            context
        );
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let package = pop_item!(self, package, Package, context);
        let package_declaration_built = PackageDeclarationBuilder::default()
            .package(Box::new(package))
            .identifier(Box::new(identifier))
            .l_brace(Box::new(l_brace))
            .package_declaration_list(package_declaration_list)
            .r_brace(Box::new(r_brace))
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar
            .package_declaration(&package_declaration_built)?;
        self.push(
            ASTType::PackageDeclaration(package_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 566:
    ///
    /// PackageDeclarationList /* Vec<T>::Push */: PackageItem PackageDeclarationList;
    ///
    #[parol_runtime::function_name::named]
    fn package_declaration_list_0(
        &mut self,
        _package_item: &ParseTreeStackEntry<'t>,
        _package_declaration_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut package_declaration_list = pop_item!(
            self,
            package_declaration_list,
            PackageDeclarationList,
            context
        );
        let package_item = pop_item!(self, package_item, PackageItem, context);
        let package_declaration_list_0_built = PackageDeclarationListBuilder::default()
            .package_item(Box::new(package_item))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        package_declaration_list.push(package_declaration_list_0_built);
        self.push(
            ASTType::PackageDeclarationList(package_declaration_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 567:
    ///
    /// PackageDeclarationList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn package_declaration_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let package_declaration_list_1_built = Vec::new();
        self.push(
            ASTType::PackageDeclarationList(package_declaration_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 568:
    ///
    /// PackageItem: VarDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn package_item_0(
        &mut self,
        _var_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let var_declaration = pop_item!(self, var_declaration, VarDeclaration, context);
        let package_item_0_built = PackageItemVarDeclarationBuilder::default()
            .var_declaration(Box::new(var_declaration))
            .build()
            .into_diagnostic()?;
        let package_item_0_built = PackageItem::VarDeclaration(package_item_0_built);
        // Calling user action here
        self.user_grammar.package_item(&package_item_0_built)?;
        self.push(ASTType::PackageItem(package_item_0_built), context);
        Ok(())
    }

    /// Semantic action for production 569:
    ///
    /// PackageItem: LocalparamDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn package_item_1(
        &mut self,
        _localparam_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let localparam_declaration =
            pop_item!(self, localparam_declaration, LocalparamDeclaration, context);
        let package_item_1_built = PackageItemLocalparamDeclarationBuilder::default()
            .localparam_declaration(Box::new(localparam_declaration))
            .build()
            .into_diagnostic()?;
        let package_item_1_built = PackageItem::LocalparamDeclaration(package_item_1_built);
        // Calling user action here
        self.user_grammar.package_item(&package_item_1_built)?;
        self.push(ASTType::PackageItem(package_item_1_built), context);
        Ok(())
    }

    /// Semantic action for production 570:
    ///
    /// PackageItem: EnumDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn package_item_2(
        &mut self,
        _enum_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let enum_declaration = pop_item!(self, enum_declaration, EnumDeclaration, context);
        let package_item_2_built = PackageItemEnumDeclarationBuilder::default()
            .enum_declaration(Box::new(enum_declaration))
            .build()
            .into_diagnostic()?;
        let package_item_2_built = PackageItem::EnumDeclaration(package_item_2_built);
        // Calling user action here
        self.user_grammar.package_item(&package_item_2_built)?;
        self.push(ASTType::PackageItem(package_item_2_built), context);
        Ok(())
    }

    /// Semantic action for production 571:
    ///
    /// PackageItem: StructDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn package_item_3(
        &mut self,
        _struct_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let struct_declaration = pop_item!(self, struct_declaration, StructDeclaration, context);
        let package_item_3_built = PackageItemStructDeclarationBuilder::default()
            .struct_declaration(Box::new(struct_declaration))
            .build()
            .into_diagnostic()?;
        let package_item_3_built = PackageItem::StructDeclaration(package_item_3_built);
        // Calling user action here
        self.user_grammar.package_item(&package_item_3_built)?;
        self.push(ASTType::PackageItem(package_item_3_built), context);
        Ok(())
    }

    /// Semantic action for production 572:
    ///
    /// PackageItem: FunctionDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn package_item_4(
        &mut self,
        _function_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let function_declaration =
            pop_item!(self, function_declaration, FunctionDeclaration, context);
        let package_item_4_built = PackageItemFunctionDeclarationBuilder::default()
            .function_declaration(Box::new(function_declaration))
            .build()
            .into_diagnostic()?;
        let package_item_4_built = PackageItem::FunctionDeclaration(package_item_4_built);
        // Calling user action here
        self.user_grammar.package_item(&package_item_4_built)?;
        self.push(ASTType::PackageItem(package_item_4_built), context);
        Ok(())
    }

    /// Semantic action for production 573:
    ///
    /// Description: ModuleDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn description_0(
        &mut self,
        _module_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module_declaration = pop_item!(self, module_declaration, ModuleDeclaration, context);
        let description_0_built = DescriptionModuleDeclarationBuilder::default()
            .module_declaration(Box::new(module_declaration))
            .build()
            .into_diagnostic()?;
        let description_0_built = Description::ModuleDeclaration(description_0_built);
        // Calling user action here
        self.user_grammar.description(&description_0_built)?;
        self.push(ASTType::Description(description_0_built), context);
        Ok(())
    }

    /// Semantic action for production 574:
    ///
    /// Description: InterfaceDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn description_1(
        &mut self,
        _interface_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let interface_declaration =
            pop_item!(self, interface_declaration, InterfaceDeclaration, context);
        let description_1_built = DescriptionInterfaceDeclarationBuilder::default()
            .interface_declaration(Box::new(interface_declaration))
            .build()
            .into_diagnostic()?;
        let description_1_built = Description::InterfaceDeclaration(description_1_built);
        // Calling user action here
        self.user_grammar.description(&description_1_built)?;
        self.push(ASTType::Description(description_1_built), context);
        Ok(())
    }

    /// Semantic action for production 575:
    ///
    /// Description: PackageDeclaration;
    ///
    #[parol_runtime::function_name::named]
    fn description_2(
        &mut self,
        _package_declaration: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let package_declaration = pop_item!(self, package_declaration, PackageDeclaration, context);
        let description_2_built = DescriptionPackageDeclarationBuilder::default()
            .package_declaration(Box::new(package_declaration))
            .build()
            .into_diagnostic()?;
        let description_2_built = Description::PackageDeclaration(description_2_built);
        // Calling user action here
        self.user_grammar.description(&description_2_built)?;
        self.push(ASTType::Description(description_2_built), context);
        Ok(())
    }

    /// Semantic action for production 576:
    ///
    /// Veryl: Start VerylList /* Vec */;
    ///
    #[parol_runtime::function_name::named]
    fn veryl(
        &mut self,
        _start: &ParseTreeStackEntry<'t>,
        _veryl_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let veryl_list = pop_and_reverse_item!(self, veryl_list, VerylList, context);
        let start = pop_item!(self, start, Start, context);
        let veryl_built = VerylBuilder::default()
            .start(Box::new(start))
            .veryl_list(veryl_list)
            .build()
            .into_diagnostic()?;
        // Calling user action here
        self.user_grammar.veryl(&veryl_built)?;
        self.push(ASTType::Veryl(veryl_built), context);
        Ok(())
    }

    /// Semantic action for production 577:
    ///
    /// VerylList /* Vec<T>::Push */: Description VerylList;
    ///
    #[parol_runtime::function_name::named]
    fn veryl_list_0(
        &mut self,
        _description: &ParseTreeStackEntry<'t>,
        _veryl_list: &ParseTreeStackEntry<'t>,
        _parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut veryl_list = pop_item!(self, veryl_list, VerylList, context);
        let description = pop_item!(self, description, Description, context);
        let veryl_list_0_built = VerylListBuilder::default()
            .description(Box::new(description))
            .build()
            .into_diagnostic()?;
        // Add an element to the vector
        veryl_list.push(veryl_list_0_built);
        self.push(ASTType::VerylList(veryl_list), context);
        Ok(())
    }

    /// Semantic action for production 578:
    ///
    /// VerylList /* Vec<T>::New */: ;
    ///
    #[parol_runtime::function_name::named]
    fn veryl_list_1(&mut self, _parse_tree: &Tree<ParseTreeType<'t>>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let veryl_list_1_built = Vec::new();
        self.push(ASTType::VerylList(veryl_list_1_built), context);
        Ok(())
    }
}

impl<'t> UserActionsTrait<'t> for VerylGrammarAuto<'t, '_> {
    ///
    /// This function is implemented automatically for the user's item VerylGrammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeStackEntry<'t>],
        parse_tree: &Tree<ParseTreeType<'t>>,
    ) -> Result<()> {
        match prod_num {
            0 => self.comments_term(&children[0], parse_tree),
            1 => self.exponent_term(&children[0], parse_tree),
            2 => self.fixed_point_term(&children[0], parse_tree),
            3 => self.based_term(&children[0], parse_tree),
            4 => self.base_less_term(&children[0], parse_tree),
            5 => self.all_bit_term(&children[0], parse_tree),
            6 => self.minus_colon_term(&children[0], parse_tree),
            7 => self.minus_g_t_term(&children[0], parse_tree),
            8 => self.plus_colon_term(&children[0], parse_tree),
            9 => self.assignment_operator_term(&children[0], parse_tree),
            10 => self.operator11_term(&children[0], parse_tree),
            11 => self.operator10_term(&children[0], parse_tree),
            12 => self.operator09_term(&children[0], parse_tree),
            13 => self.operator08_term(&children[0], parse_tree),
            14 => self.operator07_term(&children[0], parse_tree),
            15 => self.operator06_term(&children[0], parse_tree),
            16 => self.operator02_term(&children[0], parse_tree),
            17 => self.operator01_term(&children[0], parse_tree),
            18 => self.operator05_term(&children[0], parse_tree),
            19 => self.operator04_term(&children[0], parse_tree),
            20 => self.operator03_term(&children[0], parse_tree),
            21 => self.unary_operator_term(&children[0], parse_tree),
            22 => self.colon_colon_term(&children[0], parse_tree),
            23 => self.colon_term(&children[0], parse_tree),
            24 => self.comma_term(&children[0], parse_tree),
            25 => self.dollar_term(&children[0], parse_tree),
            26 => self.dot_dot_term(&children[0], parse_tree),
            27 => self.dot_term(&children[0], parse_tree),
            28 => self.equ_term(&children[0], parse_tree),
            29 => self.hash_term(&children[0], parse_tree),
            30 => self.l_brace_term(&children[0], parse_tree),
            31 => self.l_bracket_term(&children[0], parse_tree),
            32 => self.l_paren_term(&children[0], parse_tree),
            33 => self.r_brace_term(&children[0], parse_tree),
            34 => self.r_bracket_term(&children[0], parse_tree),
            35 => self.r_paren_term(&children[0], parse_tree),
            36 => self.semicolon_term(&children[0], parse_tree),
            37 => self.always_comb_term(&children[0], parse_tree),
            38 => self.always_ff_term(&children[0], parse_tree),
            39 => self.assign_term(&children[0], parse_tree),
            40 => self.async_high_term(&children[0], parse_tree),
            41 => self.async_low_term(&children[0], parse_tree),
            42 => self.bit_term(&children[0], parse_tree),
            43 => self.case_term(&children[0], parse_tree),
            44 => self.default_term(&children[0], parse_tree),
            45 => self.else_term(&children[0], parse_tree),
            46 => self.enum_term(&children[0], parse_tree),
            47 => self.f32_term(&children[0], parse_tree),
            48 => self.f64_term(&children[0], parse_tree),
            49 => self.for_term(&children[0], parse_tree),
            50 => self.function_term(&children[0], parse_tree),
            51 => self.i32_term(&children[0], parse_tree),
            52 => self.i64_term(&children[0], parse_tree),
            53 => self.if_reset_term(&children[0], parse_tree),
            54 => self.if_term(&children[0], parse_tree),
            55 => self.inout_term(&children[0], parse_tree),
            56 => self.input_term(&children[0], parse_tree),
            57 => self.inst_term(&children[0], parse_tree),
            58 => self.interface_term(&children[0], parse_tree),
            59 => self.in_term(&children[0], parse_tree),
            60 => self.localparam_term(&children[0], parse_tree),
            61 => self.logic_term(&children[0], parse_tree),
            62 => self.modport_term(&children[0], parse_tree),
            63 => self.module_term(&children[0], parse_tree),
            64 => self.negedge_term(&children[0], parse_tree),
            65 => self.output_term(&children[0], parse_tree),
            66 => self.package_term(&children[0], parse_tree),
            67 => self.parameter_term(&children[0], parse_tree),
            68 => self.posedge_term(&children[0], parse_tree),
            69 => self.ref_term(&children[0], parse_tree),
            70 => self.return_term(&children[0], parse_tree),
            71 => self.step_term(&children[0], parse_tree),
            72 => self.struct_term(&children[0], parse_tree),
            73 => self.sync_high_term(&children[0], parse_tree),
            74 => self.sync_low_term(&children[0], parse_tree),
            75 => self.u32_term(&children[0], parse_tree),
            76 => self.u64_term(&children[0], parse_tree),
            77 => self.var_term(&children[0], parse_tree),
            78 => self.identifier_term(&children[0], parse_tree),
            79 => self.comments(&children[0], parse_tree),
            80 => self.comments_opt_0(&children[0], parse_tree),
            81 => self.comments_opt_1(parse_tree),
            82 => self.start_token(&children[0], parse_tree),
            83 => self.exponent_token(&children[0], &children[1], parse_tree),
            84 => self.fixed_point_token(&children[0], &children[1], parse_tree),
            85 => self.based_token(&children[0], &children[1], parse_tree),
            86 => self.base_less_token(&children[0], &children[1], parse_tree),
            87 => self.all_bit_token(&children[0], &children[1], parse_tree),
            88 => self.assignment_operator_token(&children[0], &children[1], parse_tree),
            89 => self.operator01_token(&children[0], &children[1], parse_tree),
            90 => self.operator02_token(&children[0], &children[1], parse_tree),
            91 => self.operator03_token(&children[0], &children[1], parse_tree),
            92 => self.operator04_token(&children[0], &children[1], parse_tree),
            93 => self.operator05_token(&children[0], &children[1], parse_tree),
            94 => self.operator06_token(&children[0], &children[1], parse_tree),
            95 => self.operator07_token(&children[0], &children[1], parse_tree),
            96 => self.operator08_token(&children[0], &children[1], parse_tree),
            97 => self.operator09_token(&children[0], &children[1], parse_tree),
            98 => self.operator10_token(&children[0], &children[1], parse_tree),
            99 => self.operator11_token(&children[0], &children[1], parse_tree),
            100 => self.unary_operator_token(&children[0], &children[1], parse_tree),
            101 => self.colon_token(&children[0], &children[1], parse_tree),
            102 => self.colon_colon_token(&children[0], &children[1], parse_tree),
            103 => self.comma_token(&children[0], &children[1], parse_tree),
            104 => self.dollar_token(&children[0], &children[1], parse_tree),
            105 => self.dot_dot_token(&children[0], &children[1], parse_tree),
            106 => self.dot_token(&children[0], &children[1], parse_tree),
            107 => self.equ_token(&children[0], &children[1], parse_tree),
            108 => self.hash_token(&children[0], &children[1], parse_tree),
            109 => self.l_brace_token(&children[0], &children[1], parse_tree),
            110 => self.l_bracket_token(&children[0], &children[1], parse_tree),
            111 => self.l_paren_token(&children[0], &children[1], parse_tree),
            112 => self.minus_colon_token(&children[0], &children[1], parse_tree),
            113 => self.minus_g_t_token(&children[0], &children[1], parse_tree),
            114 => self.plus_colon_token(&children[0], &children[1], parse_tree),
            115 => self.r_brace_token(&children[0], &children[1], parse_tree),
            116 => self.r_bracket_token(&children[0], &children[1], parse_tree),
            117 => self.r_paren_token(&children[0], &children[1], parse_tree),
            118 => self.semicolon_token(&children[0], &children[1], parse_tree),
            119 => self.always_comb_token(&children[0], &children[1], parse_tree),
            120 => self.always_ff_token(&children[0], &children[1], parse_tree),
            121 => self.assign_token(&children[0], &children[1], parse_tree),
            122 => self.async_high_token(&children[0], &children[1], parse_tree),
            123 => self.async_low_token(&children[0], &children[1], parse_tree),
            124 => self.bit_token(&children[0], &children[1], parse_tree),
            125 => self.case_token(&children[0], &children[1], parse_tree),
            126 => self.default_token(&children[0], &children[1], parse_tree),
            127 => self.else_token(&children[0], &children[1], parse_tree),
            128 => self.enum_token(&children[0], &children[1], parse_tree),
            129 => self.f32_token(&children[0], &children[1], parse_tree),
            130 => self.f64_token(&children[0], &children[1], parse_tree),
            131 => self.for_token(&children[0], &children[1], parse_tree),
            132 => self.function_token(&children[0], &children[1], parse_tree),
            133 => self.i32_token(&children[0], &children[1], parse_tree),
            134 => self.i64_token(&children[0], &children[1], parse_tree),
            135 => self.if_reset_token(&children[0], &children[1], parse_tree),
            136 => self.if_token(&children[0], &children[1], parse_tree),
            137 => self.inout_token(&children[0], &children[1], parse_tree),
            138 => self.input_token(&children[0], &children[1], parse_tree),
            139 => self.inst_token(&children[0], &children[1], parse_tree),
            140 => self.interface_token(&children[0], &children[1], parse_tree),
            141 => self.in_token(&children[0], &children[1], parse_tree),
            142 => self.localparam_token(&children[0], &children[1], parse_tree),
            143 => self.logic_token(&children[0], &children[1], parse_tree),
            144 => self.modport_token(&children[0], &children[1], parse_tree),
            145 => self.module_token(&children[0], &children[1], parse_tree),
            146 => self.negedge_token(&children[0], &children[1], parse_tree),
            147 => self.output_token(&children[0], &children[1], parse_tree),
            148 => self.package_token(&children[0], &children[1], parse_tree),
            149 => self.parameter_token(&children[0], &children[1], parse_tree),
            150 => self.posedge_token(&children[0], &children[1], parse_tree),
            151 => self.ref_token(&children[0], &children[1], parse_tree),
            152 => self.return_token(&children[0], &children[1], parse_tree),
            153 => self.step_token(&children[0], &children[1], parse_tree),
            154 => self.struct_token(&children[0], &children[1], parse_tree),
            155 => self.sync_high_token(&children[0], &children[1], parse_tree),
            156 => self.sync_low_token(&children[0], &children[1], parse_tree),
            157 => self.u32_token(&children[0], &children[1], parse_tree),
            158 => self.u64_token(&children[0], &children[1], parse_tree),
            159 => self.var_token(&children[0], &children[1], parse_tree),
            160 => self.identifier_token(&children[0], &children[1], parse_tree),
            161 => self.start(&children[0], parse_tree),
            162 => self.exponent(&children[0], parse_tree),
            163 => self.fixed_point(&children[0], parse_tree),
            164 => self.based(&children[0], parse_tree),
            165 => self.base_less(&children[0], parse_tree),
            166 => self.all_bit(&children[0], parse_tree),
            167 => self.assignment_operator(&children[0], parse_tree),
            168 => self.operator01(&children[0], parse_tree),
            169 => self.operator02(&children[0], parse_tree),
            170 => self.operator03(&children[0], parse_tree),
            171 => self.operator04(&children[0], parse_tree),
            172 => self.operator05(&children[0], parse_tree),
            173 => self.operator06(&children[0], parse_tree),
            174 => self.operator07(&children[0], parse_tree),
            175 => self.operator08(&children[0], parse_tree),
            176 => self.operator09(&children[0], parse_tree),
            177 => self.operator10(&children[0], parse_tree),
            178 => self.operator11(&children[0], parse_tree),
            179 => self.unary_operator(&children[0], parse_tree),
            180 => self.colon(&children[0], parse_tree),
            181 => self.colon_colon(&children[0], parse_tree),
            182 => self.comma(&children[0], parse_tree),
            183 => self.dollar(&children[0], parse_tree),
            184 => self.dot_dot(&children[0], parse_tree),
            185 => self.dot(&children[0], parse_tree),
            186 => self.equ(&children[0], parse_tree),
            187 => self.hash(&children[0], parse_tree),
            188 => self.l_brace(&children[0], parse_tree),
            189 => self.l_bracket(&children[0], parse_tree),
            190 => self.l_paren(&children[0], parse_tree),
            191 => self.minus_colon(&children[0], parse_tree),
            192 => self.minus_g_t(&children[0], parse_tree),
            193 => self.plus_colon(&children[0], parse_tree),
            194 => self.r_brace(&children[0], parse_tree),
            195 => self.r_bracket(&children[0], parse_tree),
            196 => self.r_paren(&children[0], parse_tree),
            197 => self.semicolon(&children[0], parse_tree),
            198 => self.always_comb(&children[0], parse_tree),
            199 => self.always_ff(&children[0], parse_tree),
            200 => self.assign(&children[0], parse_tree),
            201 => self.async_high(&children[0], parse_tree),
            202 => self.async_low(&children[0], parse_tree),
            203 => self.bit(&children[0], parse_tree),
            204 => self.case(&children[0], parse_tree),
            205 => self.defaul(&children[0], parse_tree),
            206 => self.r#else(&children[0], parse_tree),
            207 => self.r#enum(&children[0], parse_tree),
            208 => self.f32(&children[0], parse_tree),
            209 => self.f64(&children[0], parse_tree),
            210 => self.r#for(&children[0], parse_tree),
            211 => self.function(&children[0], parse_tree),
            212 => self.i32(&children[0], parse_tree),
            213 => self.i64(&children[0], parse_tree),
            214 => self.r#if(&children[0], parse_tree),
            215 => self.if_reset(&children[0], parse_tree),
            216 => self.r#in(&children[0], parse_tree),
            217 => self.inout(&children[0], parse_tree),
            218 => self.input(&children[0], parse_tree),
            219 => self.inst(&children[0], parse_tree),
            220 => self.interface(&children[0], parse_tree),
            221 => self.localparam(&children[0], parse_tree),
            222 => self.logic(&children[0], parse_tree),
            223 => self.modport(&children[0], parse_tree),
            224 => self.module(&children[0], parse_tree),
            225 => self.negedge(&children[0], parse_tree),
            226 => self.output(&children[0], parse_tree),
            227 => self.package(&children[0], parse_tree),
            228 => self.parameter(&children[0], parse_tree),
            229 => self.posedge(&children[0], parse_tree),
            230 => self.r#ref(&children[0], parse_tree),
            231 => self.r#return(&children[0], parse_tree),
            232 => self.step(&children[0], parse_tree),
            233 => self.r#struct(&children[0], parse_tree),
            234 => self.sync_high(&children[0], parse_tree),
            235 => self.sync_low(&children[0], parse_tree),
            236 => self.u32(&children[0], parse_tree),
            237 => self.u64(&children[0], parse_tree),
            238 => self.var(&children[0], parse_tree),
            239 => self.identifier(&children[0], parse_tree),
            240 => self.number_0(&children[0], parse_tree),
            241 => self.number_1(&children[0], parse_tree),
            242 => self.integral_number_0(&children[0], parse_tree),
            243 => self.integral_number_1(&children[0], parse_tree),
            244 => self.integral_number_2(&children[0], parse_tree),
            245 => self.real_number_0(&children[0], parse_tree),
            246 => self.real_number_1(&children[0], parse_tree),
            247 => {
                self.hierarchical_identifier(&children[0], &children[1], &children[2], parse_tree)
            }
            248 => self.hierarchical_identifier_list0_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            249 => {
                self.hierarchical_identifier_list0_list_0(&children[0], &children[1], parse_tree)
            }
            250 => self.hierarchical_identifier_list0_list_1(parse_tree),
            251 => self.hierarchical_identifier_list0_1(parse_tree),
            252 => self.hierarchical_identifier_list_0(&children[0], &children[1], parse_tree),
            253 => self.hierarchical_identifier_list_1(parse_tree),
            254 => self.scoped_identifier(&children[0], &children[1], parse_tree),
            255 => {
                self.scoped_identifier_list_0(&children[0], &children[1], &children[2], parse_tree)
            }
            256 => self.scoped_identifier_list_1(parse_tree),
            257 => self.scoped_or_hier_identifier(&children[0], &children[1], parse_tree),
            258 => self.scoped_or_hier_identifier_group_0(
                &children[0],
                &children[1],
                &children[2],
                parse_tree,
            ),
            259 => self.scoped_or_hier_identifier_group_list_0(
                &children[0],
                &children[1],
                &children[2],
                parse_tree,
            ),
            260 => self.scoped_or_hier_identifier_group_list_1(parse_tree),
            261 => self.scoped_or_hier_identifier_group_1(&children[0], &children[1], parse_tree),
            262 => self.scoped_or_hier_identifier_group_list1_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            263 => self.scoped_or_hier_identifier_group_list1_list_0(
                &children[0],
                &children[1],
                parse_tree,
            ),
            264 => self.scoped_or_hier_identifier_group_list1_list_1(parse_tree),
            265 => self.scoped_or_hier_identifier_group_list1_1(parse_tree),
            266 => {
                self.scoped_or_hier_identifier_group_list0_0(&children[0], &children[1], parse_tree)
            }
            267 => self.scoped_or_hier_identifier_group_list0_1(parse_tree),
            268 => self.expression(&children[0], &children[1], parse_tree),
            269 => self.expression_list_0(&children[0], &children[1], &children[2], parse_tree),
            270 => self.expression_list_1(parse_tree),
            271 => self.expression01(&children[0], &children[1], parse_tree),
            272 => self.expression01_list_0(&children[0], &children[1], &children[2], parse_tree),
            273 => self.expression01_list_1(parse_tree),
            274 => self.expression02(&children[0], &children[1], parse_tree),
            275 => self.expression02_list_0(&children[0], &children[1], &children[2], parse_tree),
            276 => self.expression02_list_1(parse_tree),
            277 => self.expression03(&children[0], &children[1], parse_tree),
            278 => self.expression03_list_0(&children[0], &children[1], &children[2], parse_tree),
            279 => self.expression03_list_1(parse_tree),
            280 => self.expression04(&children[0], &children[1], parse_tree),
            281 => self.expression04_list_0(&children[0], &children[1], &children[2], parse_tree),
            282 => self.expression04_list_1(parse_tree),
            283 => self.expression05(&children[0], &children[1], parse_tree),
            284 => self.expression05_list_0(&children[0], &children[1], &children[2], parse_tree),
            285 => self.expression05_list_1(parse_tree),
            286 => self.expression06(&children[0], &children[1], parse_tree),
            287 => self.expression06_list_0(&children[0], &children[1], &children[2], parse_tree),
            288 => self.expression06_list_1(parse_tree),
            289 => self.expression07(&children[0], &children[1], parse_tree),
            290 => self.expression07_list_0(&children[0], &children[1], &children[2], parse_tree),
            291 => self.expression07_list_1(parse_tree),
            292 => self.expression08(&children[0], &children[1], parse_tree),
            293 => self.expression08_list_0(&children[0], &children[1], &children[2], parse_tree),
            294 => self.expression08_list_1(parse_tree),
            295 => self.expression09(&children[0], &children[1], parse_tree),
            296 => self.expression09_list_0(&children[0], &children[1], &children[2], parse_tree),
            297 => self.expression09_list_1(parse_tree),
            298 => self.expression10(&children[0], &children[1], parse_tree),
            299 => self.expression10_list_0(&children[0], &children[1], &children[2], parse_tree),
            300 => self.expression10_list_1(parse_tree),
            301 => self.expression11(&children[0], &children[1], parse_tree),
            302 => self.expression11_list_0(&children[0], &children[1], parse_tree),
            303 => self.expression11_list_group_0(&children[0], parse_tree),
            304 => self.expression11_list_group_1(&children[0], parse_tree),
            305 => self.expression11_list_group_2(&children[0], parse_tree),
            306 => self.expression11_list_group_3(&children[0], parse_tree),
            307 => self.expression11_list_group_4(&children[0], parse_tree),
            308 => self.expression11_list_1(parse_tree),
            309 => self.factor_0(&children[0], parse_tree),
            310 => self.factor_1(&children[0], &children[1], &children[2], parse_tree),
            311 => self.factor_2(&children[0], &children[1], &children[2], parse_tree),
            312 => self.factor_opt0_0(&children[0], &children[1], &children[2], parse_tree),
            313 => self.factor_opt1_0(&children[0], parse_tree),
            314 => self.factor_opt1_1(parse_tree),
            315 => self.factor_opt0_1(parse_tree),
            316 => self.factor_opt_0(&children[0], parse_tree),
            317 => self.factor_opt_1(parse_tree),
            318 => self.function_call_arg(&children[0], &children[1], &children[2], parse_tree),
            319 => {
                self.function_call_arg_list_0(&children[0], &children[1], &children[2], parse_tree)
            }
            320 => self.function_call_arg_list_1(parse_tree),
            321 => self.function_call_arg_opt_0(&children[0], parse_tree),
            322 => self.function_call_arg_opt_1(parse_tree),
            323 => self.range(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            324 => self.range_opt_0(&children[0], &children[1], parse_tree),
            325 => self.range_opt_1(parse_tree),
            326 => self.range_operator_0(&children[0], parse_tree),
            327 => self.range_operator_1(&children[0], parse_tree),
            328 => self.range_operator_2(&children[0], parse_tree),
            329 => self.range_operator_3(&children[0], parse_tree),
            330 => self.width(&children[0], &children[1], &children[2], parse_tree),
            331 => self.builtin_type_0(&children[0], parse_tree),
            332 => self.builtin_type_1(&children[0], parse_tree),
            333 => self.builtin_type_2(&children[0], parse_tree),
            334 => self.builtin_type_3(&children[0], parse_tree),
            335 => self.builtin_type_4(&children[0], parse_tree),
            336 => self.builtin_type_5(&children[0], parse_tree),
            337 => self.builtin_type_6(&children[0], parse_tree),
            338 => self.builtin_type_7(&children[0], parse_tree),
            339 => self.r#type(&children[0], &children[1], parse_tree),
            340 => self.type_group_0(&children[0], parse_tree),
            341 => self.type_group_1(&children[0], parse_tree),
            342 => self.type_list_0(&children[0], &children[1], parse_tree),
            343 => self.type_list_1(parse_tree),
            344 => self.statement_0(&children[0], parse_tree),
            345 => self.statement_1(&children[0], parse_tree),
            346 => self.statement_2(&children[0], parse_tree),
            347 => self.statement_3(&children[0], parse_tree),
            348 => self.statement_4(&children[0], parse_tree),
            349 => self.statement_5(&children[0], parse_tree),
            350 => self.assignment_statement(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            351 => self.assignment_statement_group_0(&children[0], parse_tree),
            352 => self.assignment_statement_group_1(&children[0], parse_tree),
            353 => self.if_statement(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
                parse_tree,
            ),
            354 => self.if_statement_list0_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
                parse_tree,
            ),
            355 => self.if_statement_list0_list_0(&children[0], &children[1], parse_tree),
            356 => self.if_statement_list0_list_1(parse_tree),
            357 => self.if_statement_list0_1(parse_tree),
            358 => self.if_statement_list_0(&children[0], &children[1], parse_tree),
            359 => self.if_statement_list_1(parse_tree),
            360 => self.if_statement_opt_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            361 => self.if_statement_opt_list_0(&children[0], &children[1], parse_tree),
            362 => self.if_statement_opt_list_1(parse_tree),
            363 => self.if_statement_opt_1(parse_tree),
            364 => self.if_reset_statement(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                parse_tree,
            ),
            365 => self.if_reset_statement_list0_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
                parse_tree,
            ),
            366 => self.if_reset_statement_list0_list_0(&children[0], &children[1], parse_tree),
            367 => self.if_reset_statement_list0_list_1(parse_tree),
            368 => self.if_reset_statement_list0_1(parse_tree),
            369 => self.if_reset_statement_list_0(&children[0], &children[1], parse_tree),
            370 => self.if_reset_statement_list_1(parse_tree),
            371 => self.if_reset_statement_opt_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            372 => self.if_reset_statement_opt_list_0(&children[0], &children[1], parse_tree),
            373 => self.if_reset_statement_opt_list_1(parse_tree),
            374 => self.if_reset_statement_opt_1(parse_tree),
            375 => self.return_statement(&children[0], &children[1], &children[2], parse_tree),
            376 => self.for_statement(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
                &children[7],
                &children[8],
                &children[9],
                &children[10],
                &children[11],
                parse_tree,
            ),
            377 => self.for_statement_list_0(&children[0], &children[1], parse_tree),
            378 => self.for_statement_list_1(parse_tree),
            379 => self.for_statement_opt_0(&children[0], &children[1], &children[2], parse_tree),
            380 => self.for_statement_opt_1(parse_tree),
            381 => self.case_statement(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                parse_tree,
            ),
            382 => self.case_statement_list_0(&children[0], &children[1], parse_tree),
            383 => self.case_statement_list_1(parse_tree),
            384 => self.case_item(&children[0], &children[1], &children[2], parse_tree),
            385 => self.case_item_group0_0(&children[0], parse_tree),
            386 => self.case_item_group0_1(&children[0], &children[1], &children[2], parse_tree),
            387 => self.case_item_group0_list_0(&children[0], &children[1], parse_tree),
            388 => self.case_item_group0_list_1(parse_tree),
            389 => self.case_item_group_0(&children[0], parse_tree),
            390 => self.case_item_group_1(&children[0], parse_tree),
            391 => self.var_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                parse_tree,
            ),
            392 => self.var_declaration_opt_0(&children[0], &children[1], parse_tree),
            393 => self.var_declaration_opt_1(parse_tree),
            394 => self.localparam_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
                parse_tree,
            ),
            395 => self.always_ff_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
                &children[7],
                parse_tree,
            ),
            396 => self.always_ff_declaration_list_0(&children[0], &children[1], parse_tree),
            397 => self.always_ff_declaration_list_1(parse_tree),
            398 => self.always_ff_declaration_opt_0(&children[0], &children[1], parse_tree),
            399 => self.always_ff_declaration_opt_1(parse_tree),
            400 => self.always_ff_clock(&children[0], &children[1], parse_tree),
            401 => self.always_ff_clock_opt_0(&children[0], parse_tree),
            402 => self.always_ff_clock_opt_group_0(&children[0], parse_tree),
            403 => self.always_ff_clock_opt_group_1(&children[0], parse_tree),
            404 => self.always_ff_clock_opt_1(parse_tree),
            405 => self.always_ff_reset(&children[0], &children[1], parse_tree),
            406 => self.always_ff_reset_opt_0(&children[0], parse_tree),
            407 => self.always_ff_reset_opt_group_0(&children[0], parse_tree),
            408 => self.always_ff_reset_opt_group_1(&children[0], parse_tree),
            409 => self.always_ff_reset_opt_group_2(&children[0], parse_tree),
            410 => self.always_ff_reset_opt_group_3(&children[0], parse_tree),
            411 => self.always_ff_reset_opt_1(parse_tree),
            412 => self.always_comb_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            413 => self.always_comb_declaration_list_0(&children[0], &children[1], parse_tree),
            414 => self.always_comb_declaration_list_1(parse_tree),
            415 => self.assign_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                parse_tree,
            ),
            416 => self.modport_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                parse_tree,
            ),
            417 => self.modport_list(&children[0], &children[1], &children[2], parse_tree),
            418 => self.modport_list_list_0(&children[0], &children[1], &children[2], parse_tree),
            419 => self.modport_list_list_1(parse_tree),
            420 => self.modport_list_opt_0(&children[0], parse_tree),
            421 => self.modport_list_opt_1(parse_tree),
            422 => self.modport_item(&children[0], &children[1], &children[2], parse_tree),
            423 => self.enum_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
                parse_tree,
            ),
            424 => self.enum_list(&children[0], &children[1], &children[2], parse_tree),
            425 => self.enum_list_list_0(&children[0], &children[1], &children[2], parse_tree),
            426 => self.enum_list_list_1(parse_tree),
            427 => self.enum_list_opt_0(&children[0], parse_tree),
            428 => self.enum_list_opt_1(parse_tree),
            429 => self.enum_item(&children[0], &children[1], parse_tree),
            430 => self.enum_item_opt_0(&children[0], &children[1], parse_tree),
            431 => self.enum_item_opt_1(parse_tree),
            432 => self.struct_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                parse_tree,
            ),
            433 => self.struct_list(&children[0], &children[1], &children[2], parse_tree),
            434 => self.struct_list_list_0(&children[0], &children[1], &children[2], parse_tree),
            435 => self.struct_list_list_1(parse_tree),
            436 => self.struct_list_opt_0(&children[0], parse_tree),
            437 => self.struct_list_opt_1(parse_tree),
            438 => self.struct_item(&children[0], &children[1], &children[2], parse_tree),
            439 => self.inst_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
                &children[7],
                parse_tree,
            ),
            440 => {
                self.inst_declaration_opt1_0(&children[0], &children[1], &children[2], parse_tree)
            }
            441 => self.inst_declaration_opt2_0(&children[0], parse_tree),
            442 => self.inst_declaration_opt2_1(parse_tree),
            443 => self.inst_declaration_opt1_1(parse_tree),
            444 => self.inst_declaration_opt0_0(&children[0], parse_tree),
            445 => self.inst_declaration_opt0_1(parse_tree),
            446 => self.inst_declaration_opt_0(&children[0], parse_tree),
            447 => self.inst_declaration_opt_1(parse_tree),
            448 => self.inst_parameter(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            449 => self.inst_parameter_opt_0(&children[0], parse_tree),
            450 => self.inst_parameter_opt_1(parse_tree),
            451 => self.inst_parameter_list(&children[0], &children[1], &children[2], parse_tree),
            452 => self.inst_parameter_list_list_0(
                &children[0],
                &children[1],
                &children[2],
                parse_tree,
            ),
            453 => self.inst_parameter_list_list_1(parse_tree),
            454 => self.inst_parameter_list_opt_0(&children[0], parse_tree),
            455 => self.inst_parameter_list_opt_1(parse_tree),
            456 => self.inst_parameter_item(&children[0], &children[1], parse_tree),
            457 => self.inst_parameter_item_opt_0(&children[0], &children[1], parse_tree),
            458 => self.inst_parameter_item_opt_1(parse_tree),
            459 => self.inst_port_list(&children[0], &children[1], &children[2], parse_tree),
            460 => self.inst_port_list_list_0(&children[0], &children[1], &children[2], parse_tree),
            461 => self.inst_port_list_list_1(parse_tree),
            462 => self.inst_port_list_opt_0(&children[0], parse_tree),
            463 => self.inst_port_list_opt_1(parse_tree),
            464 => self.inst_port_item(&children[0], &children[1], parse_tree),
            465 => self.inst_port_item_opt_0(&children[0], &children[1], parse_tree),
            466 => self.inst_port_item_opt_1(parse_tree),
            467 => self.with_parameter(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            468 => self.with_parameter_opt_0(&children[0], parse_tree),
            469 => self.with_parameter_opt_1(parse_tree),
            470 => self.with_parameter_list(&children[0], &children[1], &children[2], parse_tree),
            471 => self.with_parameter_list_list_0(
                &children[0],
                &children[1],
                &children[2],
                parse_tree,
            ),
            472 => self.with_parameter_list_list_1(parse_tree),
            473 => self.with_parameter_list_opt_0(&children[0], parse_tree),
            474 => self.with_parameter_list_opt_1(parse_tree),
            475 => self.with_parameter_item(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                parse_tree,
            ),
            476 => self.with_parameter_item_group_0(&children[0], parse_tree),
            477 => self.with_parameter_item_group_1(&children[0], parse_tree),
            478 => self.port_declaration(&children[0], &children[1], &children[2], parse_tree),
            479 => self.port_declaration_opt_0(&children[0], parse_tree),
            480 => self.port_declaration_opt_1(parse_tree),
            481 => self.port_declaration_list(&children[0], &children[1], &children[2], parse_tree),
            482 => self.port_declaration_list_list_0(
                &children[0],
                &children[1],
                &children[2],
                parse_tree,
            ),
            483 => self.port_declaration_list_list_1(parse_tree),
            484 => self.port_declaration_list_opt_0(&children[0], parse_tree),
            485 => self.port_declaration_list_opt_1(parse_tree),
            486 => self.port_declaration_item(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            487 => self.direction_0(&children[0], parse_tree),
            488 => self.direction_1(&children[0], parse_tree),
            489 => self.direction_2(&children[0], parse_tree),
            490 => self.direction_3(&children[0], parse_tree),
            491 => self.function_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
                &children[7],
                &children[8],
                parse_tree,
            ),
            492 => self.function_declaration_list_0(&children[0], &children[1], parse_tree),
            493 => self.function_declaration_list_1(parse_tree),
            494 => self.function_declaration_opt0_0(&children[0], parse_tree),
            495 => self.function_declaration_opt0_1(parse_tree),
            496 => self.function_declaration_opt_0(&children[0], parse_tree),
            497 => self.function_declaration_opt_1(parse_tree),
            498 => self.function_item_0(&children[0], parse_tree),
            499 => self.function_item_1(&children[0], parse_tree),
            500 => self.module_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
                parse_tree,
            ),
            501 => self.module_declaration_list_0(&children[0], &children[1], parse_tree),
            502 => self.module_declaration_list_1(parse_tree),
            503 => self.module_declaration_opt0_0(&children[0], parse_tree),
            504 => self.module_declaration_opt0_1(parse_tree),
            505 => self.module_declaration_opt_0(&children[0], parse_tree),
            506 => self.module_declaration_opt_1(parse_tree),
            507 => self.module_if_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                parse_tree,
            ),
            508 => self.module_if_declaration_list_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                parse_tree,
            ),
            509 => self.module_if_declaration_list_1(parse_tree),
            510 => self.module_if_declaration_opt_0(&children[0], &children[1], parse_tree),
            511 => self.module_if_declaration_opt_1(parse_tree),
            512 => self.module_for_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
                &children[7],
                parse_tree,
            ),
            513 => self.module_for_declaration_opt_0(
                &children[0],
                &children[1],
                &children[2],
                parse_tree,
            ),
            514 => self.module_for_declaration_opt_1(parse_tree),
            515 => self.module_named_block(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                parse_tree,
            ),
            516 => self.module_named_block_list_0(&children[0], &children[1], parse_tree),
            517 => self.module_named_block_list_1(parse_tree),
            518 => self.module_optional_named_block(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            519 => self.module_optional_named_block_list_0(&children[0], &children[1], parse_tree),
            520 => self.module_optional_named_block_list_1(parse_tree),
            521 => self.module_optional_named_block_opt_0(&children[0], &children[1], parse_tree),
            522 => self.module_optional_named_block_opt_1(parse_tree),
            523 => self.module_item_0(&children[0], parse_tree),
            524 => self.module_item_1(&children[0], parse_tree),
            525 => self.module_item_2(&children[0], parse_tree),
            526 => self.module_item_3(&children[0], parse_tree),
            527 => self.module_item_4(&children[0], parse_tree),
            528 => self.module_item_5(&children[0], parse_tree),
            529 => self.module_item_6(&children[0], parse_tree),
            530 => self.module_item_7(&children[0], parse_tree),
            531 => self.module_item_8(&children[0], parse_tree),
            532 => self.module_item_9(&children[0], parse_tree),
            533 => self.module_item_10(&children[0], parse_tree),
            534 => self.module_item_11(&children[0], parse_tree),
            535 => self.interface_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                parse_tree,
            ),
            536 => self.interface_declaration_list_0(&children[0], &children[1], parse_tree),
            537 => self.interface_declaration_list_1(parse_tree),
            538 => self.interface_declaration_opt_0(&children[0], parse_tree),
            539 => self.interface_declaration_opt_1(parse_tree),
            540 => self.interface_if_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                parse_tree,
            ),
            541 => self.interface_if_declaration_list_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                parse_tree,
            ),
            542 => self.interface_if_declaration_list_1(parse_tree),
            543 => self.interface_if_declaration_opt_0(&children[0], &children[1], parse_tree),
            544 => self.interface_if_declaration_opt_1(parse_tree),
            545 => self.interface_for_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
                &children[7],
                parse_tree,
            ),
            546 => self.interface_for_declaration_opt_0(
                &children[0],
                &children[1],
                &children[2],
                parse_tree,
            ),
            547 => self.interface_for_declaration_opt_1(parse_tree),
            548 => self.interface_named_block(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                parse_tree,
            ),
            549 => self.interface_named_block_list_0(&children[0], &children[1], parse_tree),
            550 => self.interface_named_block_list_1(parse_tree),
            551 => self.interface_optional_named_block(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                parse_tree,
            ),
            552 => {
                self.interface_optional_named_block_list_0(&children[0], &children[1], parse_tree)
            }
            553 => self.interface_optional_named_block_list_1(parse_tree),
            554 => {
                self.interface_optional_named_block_opt_0(&children[0], &children[1], parse_tree)
            }
            555 => self.interface_optional_named_block_opt_1(parse_tree),
            556 => self.interface_item_0(&children[0], parse_tree),
            557 => self.interface_item_1(&children[0], parse_tree),
            558 => self.interface_item_2(&children[0], parse_tree),
            559 => self.interface_item_3(&children[0], parse_tree),
            560 => self.interface_item_4(&children[0], parse_tree),
            561 => self.interface_item_5(&children[0], parse_tree),
            562 => self.interface_item_6(&children[0], parse_tree),
            563 => self.interface_item_7(&children[0], parse_tree),
            564 => self.interface_item_8(&children[0], parse_tree),
            565 => self.package_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                parse_tree,
            ),
            566 => self.package_declaration_list_0(&children[0], &children[1], parse_tree),
            567 => self.package_declaration_list_1(parse_tree),
            568 => self.package_item_0(&children[0], parse_tree),
            569 => self.package_item_1(&children[0], parse_tree),
            570 => self.package_item_2(&children[0], parse_tree),
            571 => self.package_item_3(&children[0], parse_tree),
            572 => self.package_item_4(&children[0], parse_tree),
            573 => self.description_0(&children[0], parse_tree),
            574 => self.description_1(&children[0], parse_tree),
            575 => self.description_2(&children[0], parse_tree),
            576 => self.veryl(&children[0], &children[1], parse_tree),
            577 => self.veryl_list_0(&children[0], &children[1], parse_tree),
            578 => self.veryl_list_1(parse_tree),
            _ => Err(miette!("Unhandled production number: {}", prod_num)),
        }
    }
}
